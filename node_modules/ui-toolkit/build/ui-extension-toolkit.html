<polymer-element name="ui-sparkline" attributes="data">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.06) 80%, rgba(51, 51, 51, 0.04));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: inline-block;
  overflow: hidden;
  width: 3em;
  height: 1em;
}
#plot {
  fill: none;
  vector-effect: non-scaling-stroke;
  stroke-width: 2;
}
#dot circle {
  vector-effect: non-scaling-stroke;
  stroke: #ef272d;
  fill: #ef272d;
}
svg {
  width: 100%;
  height: 100%;
  display: inline-block;
}
stop {
  stop-color: #454545;
}
</style>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-sparkline/src/ui-sparkline.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {}, {} ],
    2: [ function(require, module, exports) {
        (function(name, context, definition) {
            if (typeof module != "undefined" && module.exports) module.exports = definition(); else if (typeof define == "function" && define.amd) define(definition); else context[name] = definition();
        })("bonzo", this, function() {
            var win = window, doc = win.document, html = doc.documentElement, parentNode = "parentNode", specialAttributes = /^(checked|value|selected|disabled)$/i, specialTags = /^(select|fieldset|table|tbody|tfoot|td|tr|colgroup)$/i, simpleScriptTagRe = /\s*<script +src=['"]([^'"]+)['"]>/, table = [ "<table>", "</table>", 1 ], td = [ "<table><tbody><tr>", "</tr></tbody></table>", 3 ], option = [ "<select>", "</select>", 1 ], noscope = [ "_", "", 0, 1 ], tagMap = {
                thead: table,
                tbody: table,
                tfoot: table,
                colgroup: table,
                caption: table,
                tr: [ "<table><tbody>", "</tbody></table>", 2 ],
                th: td,
                td: td,
                col: [ "<table><colgroup>", "</colgroup></table>", 2 ],
                fieldset: [ "<form>", "</form>", 1 ],
                legend: [ "<form><fieldset>", "</fieldset></form>", 2 ],
                option: option,
                optgroup: option,
                script: noscope,
                style: noscope,
                link: noscope,
                param: noscope,
                base: noscope
            }, stateAttributes = /^(checked|selected|disabled)$/, hasClass, addClass, removeClass, uidMap = {}, uuids = 0, digit = /^-?[\d\.]+$/, dattr = /^data-(.+)$/, px = "px", setAttribute = "setAttribute", getAttribute = "getAttribute", features = function() {
                var e = doc.createElement("p");
                return {
                    transform: function() {
                        var props = [ "transform", "webkitTransform", "MozTransform", "OTransform", "msTransform" ], i;
                        for (i = 0; i < props.length; i++) {
                            if (props[i] in e.style) return props[i];
                        }
                    }(),
                    classList: "classList" in e
                };
            }(), whitespaceRegex = /\s+/, toString = String.prototype.toString, unitless = {
                lineHeight: 1,
                zoom: 1,
                zIndex: 1,
                opacity: 1,
                boxFlex: 1,
                WebkitBoxFlex: 1,
                MozBoxFlex: 1
            }, query = doc.querySelectorAll && function(selector) {
                return doc.querySelectorAll(selector);
            };
            function getStyle(el, property) {
                var value = null, computed = doc.defaultView.getComputedStyle(el, "");
                computed && (value = computed[property]);
                return el.style[property] || value;
            }
            function isNode(node) {
                return node && node.nodeName && (node.nodeType == 1 || node.nodeType == 11);
            }
            function normalize(node, host, clone) {
                var i, l, ret;
                if (typeof node == "string") return bonzo.create(node);
                if (isNode(node)) node = [ node ];
                if (clone) {
                    ret = [];
                    for (i = 0, l = node.length; i < l; i++) ret[i] = cloneNode(host, node[i]);
                    return ret;
                }
                return node;
            }
            function classReg(c) {
                return new RegExp("(^|\\s+)" + c + "(\\s+|$)");
            }
            function each(ar, fn, opt_scope, opt_rev) {
                var ind, i = 0, l = ar.length;
                for (;i < l; i++) {
                    ind = opt_rev ? ar.length - i - 1 : i;
                    fn.call(opt_scope || ar[ind], ar[ind], ind, ar);
                }
                return ar;
            }
            function deepEach(ar, fn, opt_scope) {
                for (var i = 0, l = ar.length; i < l; i++) {
                    if (isNode(ar[i])) {
                        deepEach(ar[i].childNodes, fn, opt_scope);
                        fn.call(opt_scope || ar[i], ar[i], i, ar);
                    }
                }
                return ar;
            }
            function camelize(s) {
                return s.replace(/-(.)/g, function(m, m1) {
                    return m1.toUpperCase();
                });
            }
            function decamelize(s) {
                return s ? s.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() : s;
            }
            function data(el) {
                el[getAttribute]("data-node-uid") || el[setAttribute]("data-node-uid", ++uuids);
                var uid = el[getAttribute]("data-node-uid");
                return uidMap[uid] || (uidMap[uid] = {});
            }
            function clearData(el) {
                var uid = el[getAttribute]("data-node-uid");
                if (uid) delete uidMap[uid];
            }
            function dataValue(d) {
                var f;
                try {
                    return d === null || d === undefined ? undefined : d === "true" ? true : d === "false" ? false : d === "null" ? null : (f = parseFloat(d)) == d ? f : d;
                } catch (e) {}
                return undefined;
            }
            function some(ar, fn, opt_scope) {
                for (var i = 0, j = ar.length; i < j; ++i) if (fn.call(opt_scope || null, ar[i], i, ar)) return true;
                return false;
            }
            function styleProperty(p) {
                p == "transform" && (p = features.transform) || /^transform-?[Oo]rigin$/.test(p) && (p = features.transform + "Origin");
                return p ? camelize(p) : null;
            }
            function insert(target, host, fn, rev) {
                var i = 0, self = host || this, r = [], nodes = query && typeof target == "string" && target.charAt(0) != "<" ? query(target) : target;
                each(normalize(nodes), function(t, j) {
                    each(self, function(el) {
                        fn(t, r[i++] = j > 0 ? cloneNode(self, el) : el);
                    }, null, rev);
                }, this, rev);
                self.length = i;
                each(r, function(e) {
                    self[--i] = e;
                }, null, !rev);
                return self;
            }
            function xy(el, x, y) {
                var $el = bonzo(el), style = $el.css("position"), offset = $el.offset(), rel = "relative", isRel = style == rel, delta = [ parseInt($el.css("left"), 10), parseInt($el.css("top"), 10) ];
                if (style == "static") {
                    $el.css("position", rel);
                    style = rel;
                }
                isNaN(delta[0]) && (delta[0] = isRel ? 0 : el.offsetLeft);
                isNaN(delta[1]) && (delta[1] = isRel ? 0 : el.offsetTop);
                x != null && (el.style.left = x - offset.left + delta[0] + px);
                y != null && (el.style.top = y - offset.top + delta[1] + px);
            }
            if (features.classList) {
                hasClass = function(el, c) {
                    return el.classList.contains(c);
                };
                addClass = function(el, c) {
                    el.classList.add(c);
                };
                removeClass = function(el, c) {
                    el.classList.remove(c);
                };
            } else {
                hasClass = function(el, c) {
                    return classReg(c).test(el.className);
                };
                addClass = function(el, c) {
                    el.className = (el.className + " " + c).trim();
                };
                removeClass = function(el, c) {
                    el.className = el.className.replace(classReg(c), " ").trim();
                };
            }
            function setter(el, v) {
                return typeof v == "function" ? v.call(el, el) : v;
            }
            function scroll(x, y, type) {
                var el = this[0];
                if (!el) return this;
                if (x == null && y == null) {
                    return (isBody(el) ? getWindowScroll() : {
                        x: el.scrollLeft,
                        y: el.scrollTop
                    })[type];
                }
                if (isBody(el)) {
                    win.scrollTo(x, y);
                } else {
                    x != null && (el.scrollLeft = x);
                    y != null && (el.scrollTop = y);
                }
                return this;
            }
            function Bonzo(elements) {
                this.length = 0;
                if (elements) {
                    elements = typeof elements !== "string" && !elements.nodeType && typeof elements.length !== "undefined" ? elements : [ elements ];
                    this.length = elements.length;
                    for (var i = 0; i < elements.length; i++) this[i] = elements[i];
                }
            }
            Bonzo.prototype = {
                get: function(index) {
                    return this[index] || null;
                },
                each: function(fn, opt_scope) {
                    return each(this, fn, opt_scope);
                },
                deepEach: function(fn, opt_scope) {
                    return deepEach(this, fn, opt_scope);
                },
                map: function(fn, opt_reject) {
                    var m = [], n, i;
                    for (i = 0; i < this.length; i++) {
                        n = fn.call(this, this[i], i);
                        opt_reject ? opt_reject(n) && m.push(n) : m.push(n);
                    }
                    return m;
                },
                html: function(h, opt_text) {
                    var method = opt_text ? "textContent" : "innerHTML", that = this, append = function(el, i) {
                        each(normalize(h, that, i), function(node) {
                            el.appendChild(node);
                        });
                    }, updateElement = function(el, i) {
                        try {
                            if (opt_text || typeof h == "string" && !specialTags.test(el.tagName)) {
                                return el[method] = h;
                            }
                        } catch (e) {}
                        append(el, i);
                    };
                    return typeof h != "undefined" ? this.empty().each(updateElement) : this[0] ? this[0][method] : "";
                },
                text: function(opt_text) {
                    return this.html(opt_text, true);
                },
                append: function(node) {
                    var that = this;
                    return this.each(function(el, i) {
                        each(normalize(node, that, i), function(i) {
                            el.appendChild(i);
                        });
                    });
                },
                prepend: function(node) {
                    var that = this;
                    return this.each(function(el, i) {
                        var first = el.firstChild;
                        each(normalize(node, that, i), function(i) {
                            el.insertBefore(i, first);
                        });
                    });
                },
                appendTo: function(target, opt_host) {
                    return insert.call(this, target, opt_host, function(t, el) {
                        t.appendChild(el);
                    });
                },
                prependTo: function(target, opt_host) {
                    return insert.call(this, target, opt_host, function(t, el) {
                        t.insertBefore(el, t.firstChild);
                    }, 1);
                },
                before: function(node) {
                    var that = this;
                    return this.each(function(el, i) {
                        each(normalize(node, that, i), function(i) {
                            el[parentNode].insertBefore(i, el);
                        });
                    });
                },
                after: function(node) {
                    var that = this;
                    return this.each(function(el, i) {
                        each(normalize(node, that, i), function(i) {
                            el[parentNode].insertBefore(i, el.nextSibling);
                        }, null, 1);
                    });
                },
                insertBefore: function(target, opt_host) {
                    return insert.call(this, target, opt_host, function(t, el) {
                        t[parentNode].insertBefore(el, t);
                    });
                },
                insertAfter: function(target, opt_host) {
                    return insert.call(this, target, opt_host, function(t, el) {
                        var sibling = t.nextSibling;
                        sibling ? t[parentNode].insertBefore(el, sibling) : t[parentNode].appendChild(el);
                    }, 1);
                },
                replaceWith: function(node) {
                    var that = this;
                    return this.each(function(el, i) {
                        each(normalize(node, that, i), function(i) {
                            el[parentNode] && el[parentNode].replaceChild(i, el);
                        });
                    });
                },
                clone: function(opt_host) {
                    var ret = [], l, i;
                    for (i = 0, l = this.length; i < l; i++) ret[i] = cloneNode(opt_host || this, this[i]);
                    return bonzo(ret);
                },
                addClass: function(c) {
                    c = toString.call(c).split(whitespaceRegex);
                    return this.each(function(el) {
                        each(c, function(c) {
                            if (c && !hasClass(el, setter(el, c))) addClass(el, setter(el, c));
                        });
                    });
                },
                removeClass: function(c) {
                    c = toString.call(c).split(whitespaceRegex);
                    return this.each(function(el) {
                        each(c, function(c) {
                            if (c && hasClass(el, setter(el, c))) removeClass(el, setter(el, c));
                        });
                    });
                },
                hasClass: function(c) {
                    c = toString.call(c).split(whitespaceRegex);
                    return some(this, function(el) {
                        return some(c, function(c) {
                            return c && hasClass(el, c);
                        });
                    });
                },
                toggleClass: function(c, opt_condition) {
                    c = toString.call(c).split(whitespaceRegex);
                    return this.each(function(el) {
                        each(c, function(c) {
                            if (c) {
                                typeof opt_condition !== "undefined" ? opt_condition ? !hasClass(el, c) && addClass(el, c) : removeClass(el, c) : hasClass(el, c) ? removeClass(el, c) : addClass(el, c);
                            }
                        });
                    });
                },
                show: function(opt_type) {
                    opt_type = typeof opt_type == "string" ? opt_type : "";
                    return this.each(function(el) {
                        el.style.display = opt_type;
                    });
                },
                hide: function() {
                    return this.each(function(el) {
                        el.style.display = "none";
                    });
                },
                toggle: function(opt_callback, opt_type) {
                    opt_type = typeof opt_type == "string" ? opt_type : "";
                    typeof opt_callback != "function" && (opt_callback = null);
                    return this.each(function(el) {
                        el.style.display = el.offsetWidth || el.offsetHeight ? "none" : opt_type;
                        opt_callback && opt_callback.call(el);
                    });
                },
                first: function() {
                    return bonzo(this.length ? this[0] : []);
                },
                last: function() {
                    return bonzo(this.length ? this[this.length - 1] : []);
                },
                next: function() {
                    return this.related("nextSibling");
                },
                previous: function() {
                    return this.related("previousSibling");
                },
                parent: function() {
                    return this.related(parentNode);
                },
                related: function(method) {
                    return bonzo(this.map(function(el) {
                        el = el[method];
                        while (el && el.nodeType !== 1) {
                            el = el[method];
                        }
                        return el || 0;
                    }, function(el) {
                        return el;
                    }));
                },
                focus: function() {
                    this.length && this[0].focus();
                    return this;
                },
                blur: function() {
                    this.length && this[0].blur();
                    return this;
                },
                css: function(o, opt_v) {
                    var p, iter = o;
                    if (opt_v === undefined && typeof o == "string") {
                        opt_v = this[0];
                        if (!opt_v) return null;
                        if (opt_v === doc || opt_v === win) {
                            p = opt_v === doc ? bonzo.doc() : bonzo.viewport();
                            return o == "width" ? p.width : o == "height" ? p.height : "";
                        }
                        return (o = styleProperty(o)) ? getStyle(opt_v, o) : null;
                    }
                    if (typeof o == "string") {
                        iter = {};
                        iter[o] = opt_v;
                    }
                    function fn(el, p, v) {
                        for (var k in iter) {
                            if (iter.hasOwnProperty(k)) {
                                v = iter[k];
                                (p = styleProperty(k)) && digit.test(v) && !(p in unitless) && (v += px);
                                try {
                                    el.style[p] = setter(el, v);
                                } catch (e) {}
                            }
                        }
                    }
                    return this.each(fn);
                },
                offset: function(opt_x, opt_y) {
                    if (opt_x && typeof opt_x == "object" && (typeof opt_x.top == "number" || typeof opt_x.left == "number")) {
                        return this.each(function(el) {
                            xy(el, opt_x.left, opt_x.top);
                        });
                    } else if (typeof opt_x == "number" || typeof opt_y == "number") {
                        return this.each(function(el) {
                            xy(el, opt_x, opt_y);
                        });
                    }
                    if (!this[0]) return {
                        top: 0,
                        left: 0,
                        height: 0,
                        width: 0
                    };
                    var el = this[0], de = el.ownerDocument.documentElement, bcr = el.getBoundingClientRect(), scroll = getWindowScroll(), width = el.offsetWidth, height = el.offsetHeight, top = bcr.top + scroll.y - Math.max(0, de && de.clientTop, doc.body.clientTop), left = bcr.left + scroll.x - Math.max(0, de && de.clientLeft, doc.body.clientLeft);
                    return {
                        top: top,
                        left: left,
                        height: height,
                        width: width
                    };
                },
                dim: function() {
                    if (!this.length) return {
                        height: 0,
                        width: 0
                    };
                    var el = this[0], de = el.nodeType == 9 && el.documentElement, orig = !de && !!el.style && !el.offsetWidth && !el.offsetHeight ? function(t) {
                        var s = {
                            position: el.style.position || "",
                            visibility: el.style.visibility || "",
                            display: el.style.display || ""
                        };
                        t.first().css({
                            position: "absolute",
                            visibility: "hidden",
                            display: "block"
                        });
                        return s;
                    }(this) : null, width = de ? Math.max(el.body.scrollWidth, el.body.offsetWidth, de.scrollWidth, de.offsetWidth, de.clientWidth) : el.offsetWidth, height = de ? Math.max(el.body.scrollHeight, el.body.offsetHeight, de.scrollHeight, de.offsetHeight, de.clientHeight) : el.offsetHeight;
                    orig && this.first().css(orig);
                    return {
                        height: height,
                        width: width
                    };
                },
                attr: function(k, opt_v) {
                    var el = this[0], n;
                    if (typeof k != "string" && !(k instanceof String)) {
                        for (n in k) {
                            k.hasOwnProperty(n) && this.attr(n, k[n]);
                        }
                        return this;
                    }
                    return typeof opt_v == "undefined" ? !el ? null : specialAttributes.test(k) ? stateAttributes.test(k) && typeof el[k] == "string" ? true : el[k] : el[getAttribute](k) : this.each(function(el) {
                        specialAttributes.test(k) ? el[k] = setter(el, opt_v) : el[setAttribute](k, setter(el, opt_v));
                    });
                },
                removeAttr: function(k) {
                    return this.each(function(el) {
                        stateAttributes.test(k) ? el[k] = false : el.removeAttribute(k);
                    });
                },
                val: function(s) {
                    return typeof s == "string" || typeof s == "number" ? this.attr("value", s) : this.length ? this[0].value : null;
                },
                data: function(opt_k, opt_v) {
                    var el = this[0], o, m;
                    if (typeof opt_v === "undefined") {
                        if (!el) return null;
                        o = data(el);
                        if (typeof opt_k === "undefined") {
                            each(el.attributes, function(a) {
                                (m = ("" + a.name).match(dattr)) && (o[camelize(m[1])] = dataValue(a.value));
                            });
                            return o;
                        } else {
                            if (typeof o[opt_k] === "undefined") o[opt_k] = dataValue(this.attr("data-" + decamelize(opt_k)));
                            return o[opt_k];
                        }
                    } else {
                        return this.each(function(el) {
                            data(el)[opt_k] = opt_v;
                        });
                    }
                },
                remove: function() {
                    this.deepEach(clearData);
                    return this.detach();
                },
                empty: function() {
                    return this.each(function(el) {
                        deepEach(el.childNodes, clearData);
                        while (el.firstChild) {
                            el.removeChild(el.firstChild);
                        }
                    });
                },
                detach: function() {
                    return this.each(function(el) {
                        el[parentNode] && el[parentNode].removeChild(el);
                    });
                },
                scrollTop: function(y) {
                    return scroll.call(this, null, y, "y");
                },
                scrollLeft: function(x) {
                    return scroll.call(this, x, null, "x");
                }
            };
            function cloneNode(host, el) {
                var c = el.cloneNode(true), cloneElems, elElems, i;
                if (host.$ && typeof host.cloneEvents == "function") {
                    host.$(c).cloneEvents(el);
                    cloneElems = host.$(c).find("*");
                    elElems = host.$(el).find("*");
                    for (i = 0; i < elElems.length; i++) host.$(cloneElems[i]).cloneEvents(elElems[i]);
                }
                return c;
            }
            function isBody(element) {
                return element === win || /^(?:body|html)$/i.test(element.tagName);
            }
            function getWindowScroll() {
                return {
                    x: win.pageXOffset || html.scrollLeft,
                    y: win.pageYOffset || html.scrollTop
                };
            }
            function createScriptFromHtml(html) {
                var scriptEl = document.createElement("script"), matches = html.match(simpleScriptTagRe);
                scriptEl.src = matches[1];
                return scriptEl;
            }
            function bonzo(els) {
                return new Bonzo(els);
            }
            bonzo.setQueryEngine = function(q) {
                query = q;
                delete bonzo.setQueryEngine;
            };
            bonzo.aug = function(o, target) {
                for (var k in o) {
                    o.hasOwnProperty(k) && ((target || Bonzo.prototype)[k] = o[k]);
                }
            };
            bonzo.create = function(node) {
                return typeof node == "string" && node !== "" ? function() {
                    if (simpleScriptTagRe.test(node)) return [ createScriptFromHtml(node) ];
                    var tag = node.match(/^\s*<([^\s>]+)/), el = doc.createElement("div"), els = [], p = tag ? tagMap[tag[1].toLowerCase()] : null, dep = p ? p[2] + 1 : 1, ns = p && p[3], pn = parentNode;
                    el.innerHTML = p ? p[0] + node + p[1] : node;
                    while (dep--) el = el.firstChild;
                    if (ns && el && el.nodeType !== 1) el = el.nextSibling;
                    do {
                        if (!tag || el.nodeType == 1) {
                            els.push(el);
                        }
                    } while (el = el.nextSibling);
                    each(els, function(el) {
                        el[pn] && el[pn].removeChild(el);
                    });
                    return els;
                }() : isNode(node) ? [ node.cloneNode(true) ] : [];
            };
            bonzo.doc = function() {
                var vp = bonzo.viewport();
                return {
                    width: Math.max(doc.body.scrollWidth, html.scrollWidth, vp.width),
                    height: Math.max(doc.body.scrollHeight, html.scrollHeight, vp.height)
                };
            };
            bonzo.firstChild = function(el) {
                for (var c = el.childNodes, i = 0, j = c && c.length || 0, e; i < j; i++) {
                    if (c[i].nodeType === 1) e = c[j = i];
                }
                return e;
            };
            bonzo.viewport = function() {
                return {
                    width: win.innerWidth,
                    height: win.innerHeight
                };
            };
            bonzo.isAncestor = "compareDocumentPosition" in html ? function(container, element) {
                return (container.compareDocumentPosition(element) & 16) == 16;
            } : function(container, element) {
                return container !== element && container.contains(element);
            };
            return bonzo;
        });
    }, {} ],
    3: [ function(require, module, exports) {
        "use strict";
        var Handlebars = require("./handlebars.runtime")["default"];
        var AST = require("./handlebars/compiler/ast")["default"];
        var Parser = require("./handlebars/compiler/base").parser;
        var parse = require("./handlebars/compiler/base").parse;
        var Compiler = require("./handlebars/compiler/compiler").Compiler;
        var compile = require("./handlebars/compiler/compiler").compile;
        var precompile = require("./handlebars/compiler/compiler").precompile;
        var JavaScriptCompiler = require("./handlebars/compiler/javascript-compiler")["default"];
        var _create = Handlebars.create;
        var create = function() {
            var hb = _create();
            hb.compile = function(input, options) {
                return compile(input, options, hb);
            };
            hb.precompile = function(input, options) {
                return precompile(input, options, hb);
            };
            hb.AST = AST;
            hb.Compiler = Compiler;
            hb.JavaScriptCompiler = JavaScriptCompiler;
            hb.Parser = Parser;
            hb.parse = parse;
            return hb;
        };
        Handlebars = create();
        Handlebars.create = create;
        exports["default"] = Handlebars;
    }, {
        "./handlebars.runtime": 4,
        "./handlebars/compiler/ast": 6,
        "./handlebars/compiler/base": 7,
        "./handlebars/compiler/compiler": 8,
        "./handlebars/compiler/javascript-compiler": 9
    } ],
    4: [ function(require, module, exports) {
        "use strict";
        var base = require("./handlebars/base");
        var SafeString = require("./handlebars/safe-string")["default"];
        var Exception = require("./handlebars/exception")["default"];
        var Utils = require("./handlebars/utils");
        var runtime = require("./handlebars/runtime");
        var create = function() {
            var hb = new base.HandlebarsEnvironment();
            Utils.extend(hb, base);
            hb.SafeString = SafeString;
            hb.Exception = Exception;
            hb.Utils = Utils;
            hb.VM = runtime;
            hb.template = function(spec) {
                return runtime.template(spec, hb);
            };
            return hb;
        };
        var Handlebars = create();
        Handlebars.create = create;
        exports["default"] = Handlebars;
    }, {
        "./handlebars/base": 5,
        "./handlebars/exception": 13,
        "./handlebars/runtime": 14,
        "./handlebars/safe-string": 15,
        "./handlebars/utils": 16
    } ],
    5: [ function(require, module, exports) {
        "use strict";
        var Utils = require("./utils");
        var Exception = require("./exception")["default"];
        var VERSION = "2.0.0-alpha.4";
        exports.VERSION = VERSION;
        var COMPILER_REVISION = 5;
        exports.COMPILER_REVISION = COMPILER_REVISION;
        var REVISION_CHANGES = {
            1: "<= 1.0.rc.2",
            2: "== 1.0.0-rc.3",
            3: "== 1.0.0-rc.4",
            4: "== 1.x.x",
            5: ">= 2.0.0"
        };
        exports.REVISION_CHANGES = REVISION_CHANGES;
        var isArray = Utils.isArray, isFunction = Utils.isFunction, toString = Utils.toString, objectType = "[object Object]";
        function HandlebarsEnvironment(helpers, partials) {
            this.helpers = helpers || {};
            this.partials = partials || {};
            registerDefaultHelpers(this);
        }
        exports.HandlebarsEnvironment = HandlebarsEnvironment;
        HandlebarsEnvironment.prototype = {
            constructor: HandlebarsEnvironment,
            logger: logger,
            log: log,
            registerHelper: function(name, fn, inverse) {
                if (toString.call(name) === objectType) {
                    if (inverse || fn) {
                        throw new Exception("Arg not supported with multiple helpers");
                    }
                    Utils.extend(this.helpers, name);
                } else {
                    if (inverse) {
                        fn.not = inverse;
                    }
                    this.helpers[name] = fn;
                }
            },
            unregisterHelper: function(name) {
                delete this.helpers[name];
            },
            registerPartial: function(name, str) {
                if (toString.call(name) === objectType) {
                    Utils.extend(this.partials, name);
                } else {
                    this.partials[name] = str;
                }
            },
            unregisterPartial: function(name) {
                delete this.partials[name];
            }
        };
        function registerDefaultHelpers(instance) {
            instance.registerHelper("helperMissing", function() {
                if (arguments.length === 1) {
                    return undefined;
                } else {
                    throw new Exception("Missing helper: '" + arguments[arguments.length - 1].name + "'");
                }
            });
            instance.registerHelper("blockHelperMissing", function(context, options) {
                var inverse = options.inverse || function() {}, fn = options.fn;
                if (isFunction(context)) {
                    context = context.call(this);
                }
                if (context === true) {
                    return fn(this);
                } else if (context === false || context == null) {
                    return inverse(this);
                } else if (isArray(context)) {
                    if (context.length > 0) {
                        if (options.ids) {
                            options.ids = [ options.name ];
                        }
                        return instance.helpers.each(context, options);
                    } else {
                        return inverse(this);
                    }
                } else {
                    if (options.data && options.ids) {
                        var data = createFrame(options.data);
                        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.name);
                        options = {
                            data: data
                        };
                    }
                    return fn(context, options);
                }
            });
            instance.registerHelper("each", function(context, options) {
                if (!options) {
                    options = context;
                    context = this;
                }
                var fn = options.fn, inverse = options.inverse;
                var i = 0, ret = "", data;
                var contextPath;
                if (options.data && options.ids) {
                    contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
                }
                if (isFunction(context)) {
                    context = context.call(this);
                }
                if (options.data) {
                    data = createFrame(options.data);
                }
                if (context && typeof context === "object") {
                    if (isArray(context)) {
                        for (var j = context.length; i < j; i++) {
                            if (data) {
                                data.index = i;
                                data.first = i === 0;
                                data.last = i === context.length - 1;
                                if (contextPath) {
                                    data.contextPath = contextPath + i;
                                }
                            }
                            ret = ret + fn(context[i], {
                                data: data
                            });
                        }
                    } else {
                        for (var key in context) {
                            if (context.hasOwnProperty(key)) {
                                if (data) {
                                    data.key = key;
                                    data.index = i;
                                    data.first = i === 0;
                                    if (contextPath) {
                                        data.contextPath = contextPath + key;
                                    }
                                }
                                ret = ret + fn(context[key], {
                                    data: data
                                });
                                i++;
                            }
                        }
                    }
                }
                if (i === 0) {
                    ret = inverse(this);
                }
                return ret;
            });
            instance.registerHelper("if", function(conditional, options) {
                if (isFunction(conditional)) {
                    conditional = conditional.call(this);
                }
                if (!options.hash.includeZero && !conditional || Utils.isEmpty(conditional)) {
                    return options.inverse(this);
                } else {
                    return options.fn(this);
                }
            });
            instance.registerHelper("unless", function(conditional, options) {
                return instance.helpers["if"].call(this, conditional, {
                    fn: options.inverse,
                    inverse: options.fn,
                    hash: options.hash
                });
            });
            instance.registerHelper("with", function(context, options) {
                if (isFunction(context)) {
                    context = context.call(this);
                }
                var fn = options.fn;
                if (!Utils.isEmpty(context)) {
                    if (options.data && options.ids) {
                        var data = createFrame(options.data);
                        data.contextPath = Utils.appendContextPath(options.data.contextPath, options.ids[0]);
                        options = {
                            data: data
                        };
                    }
                    return fn(context, options);
                }
            });
            instance.registerHelper("log", function(context, options) {
                var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
                instance.log(level, context);
            });
            instance.registerHelper("lookup", function(obj, field, options) {
                return obj && obj[field];
            });
        }
        var logger = {
            methodMap: {
                0: "debug",
                1: "info",
                2: "warn",
                3: "error"
            },
            DEBUG: 0,
            INFO: 1,
            WARN: 2,
            ERROR: 3,
            level: 3,
            log: function(level, obj) {
                if (logger.level <= level) {
                    var method = logger.methodMap[level];
                    if (typeof console !== "undefined" && console[method]) {
                        console[method].call(console, obj);
                    }
                }
            }
        };
        exports.logger = logger;
        function log(level, obj) {
            logger.log(level, obj);
        }
        exports.log = log;
        var createFrame = function(object) {
            var frame = Utils.extend({}, object);
            frame._parent = object;
            return frame;
        };
        exports.createFrame = createFrame;
    }, {
        "./exception": 13,
        "./utils": 16
    } ],
    6: [ function(require, module, exports) {
        "use strict";
        var Exception = require("../exception")["default"];
        function LocationInfo(locInfo) {
            locInfo = locInfo || {};
            this.firstLine = locInfo.first_line;
            this.firstColumn = locInfo.first_column;
            this.lastColumn = locInfo.last_column;
            this.lastLine = locInfo.last_line;
        }
        var AST = {
            ProgramNode: function(statements, inverseStrip, inverse, locInfo) {
                var inverseLocationInfo, firstInverseNode;
                if (arguments.length === 3) {
                    locInfo = inverse;
                    inverse = null;
                } else if (arguments.length === 2) {
                    locInfo = inverseStrip;
                    inverseStrip = null;
                }
                LocationInfo.call(this, locInfo);
                this.type = "program";
                this.statements = statements;
                this.strip = {};
                if (inverse) {
                    firstInverseNode = inverse[0];
                    if (firstInverseNode) {
                        inverseLocationInfo = {
                            first_line: firstInverseNode.firstLine,
                            last_line: firstInverseNode.lastLine,
                            last_column: firstInverseNode.lastColumn,
                            first_column: firstInverseNode.firstColumn
                        };
                        this.inverse = new AST.ProgramNode(inverse, inverseStrip, inverseLocationInfo);
                    } else {
                        this.inverse = new AST.ProgramNode(inverse, inverseStrip);
                    }
                    this.strip.right = inverseStrip.left;
                } else if (inverseStrip) {
                    this.strip.left = inverseStrip.right;
                }
            },
            MustacheNode: function(rawParams, hash, open, strip, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "mustache";
                this.strip = strip;
                if (open != null && open.charAt) {
                    var escapeFlag = open.charAt(3) || open.charAt(2);
                    this.escaped = escapeFlag !== "{" && escapeFlag !== "&";
                } else {
                    this.escaped = !!open;
                }
                if (rawParams instanceof AST.SexprNode) {
                    this.sexpr = rawParams;
                } else {
                    this.sexpr = new AST.SexprNode(rawParams, hash);
                }
                this.sexpr.isRoot = true;
                this.id = this.sexpr.id;
                this.params = this.sexpr.params;
                this.hash = this.sexpr.hash;
                this.eligibleHelper = this.sexpr.eligibleHelper;
                this.isHelper = this.sexpr.isHelper;
            },
            SexprNode: function(rawParams, hash, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "sexpr";
                this.hash = hash;
                var id = this.id = rawParams[0];
                var params = this.params = rawParams.slice(1);
                this.isHelper = !!(params.length || hash);
                this.eligibleHelper = this.isHelper || id.isSimple;
            },
            PartialNode: function(partialName, context, hash, strip, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "partial";
                this.partialName = partialName;
                this.context = context;
                this.hash = hash;
                this.strip = strip;
            },
            BlockNode: function(mustache, program, inverse, close, locInfo) {
                LocationInfo.call(this, locInfo);
                if (mustache.sexpr.id.original !== close.path.original) {
                    throw new Exception(mustache.sexpr.id.original + " doesn't match " + close.path.original, this);
                }
                this.type = "block";
                this.mustache = mustache;
                this.program = program;
                this.inverse = inverse;
                this.strip = {
                    left: mustache.strip.left,
                    right: close.strip.right
                };
                (program || inverse).strip.left = mustache.strip.right;
                (inverse || program).strip.right = close.strip.left;
                if (inverse && !program) {
                    this.isInverse = true;
                }
            },
            RawBlockNode: function(mustache, content, close, locInfo) {
                LocationInfo.call(this, locInfo);
                if (mustache.sexpr.id.original !== close) {
                    throw new Exception(mustache.sexpr.id.original + " doesn't match " + close, this);
                }
                content = new AST.ContentNode(content, locInfo);
                this.type = "block";
                this.mustache = mustache;
                this.program = new AST.ProgramNode([ content ], locInfo);
            },
            ContentNode: function(string, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "content";
                this.string = string;
            },
            HashNode: function(pairs, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "hash";
                this.pairs = pairs;
            },
            IdNode: function(parts, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "ID";
                var original = "", dig = [], depth = 0, depthString = "";
                for (var i = 0, l = parts.length; i < l; i++) {
                    var part = parts[i].part;
                    original += (parts[i].separator || "") + part;
                    if (part === ".." || part === "." || part === "this") {
                        if (dig.length > 0) {
                            throw new Exception("Invalid path: " + original, this);
                        } else if (part === "..") {
                            depth++;
                            depthString += "../";
                        } else {
                            this.isScoped = true;
                        }
                    } else {
                        dig.push(part);
                    }
                }
                this.original = original;
                this.parts = dig;
                this.string = dig.join(".");
                this.depth = depth;
                this.idName = depthString + this.string;
                this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;
                this.stringModeValue = this.string;
            },
            PartialNameNode: function(name, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "PARTIAL_NAME";
                this.name = name.original;
            },
            DataNode: function(id, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "DATA";
                this.id = id;
                this.stringModeValue = id.stringModeValue;
                this.idName = "@" + id.stringModeValue;
            },
            StringNode: function(string, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "STRING";
                this.original = this.string = this.stringModeValue = string;
            },
            NumberNode: function(number, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "NUMBER";
                this.original = this.number = number;
                this.stringModeValue = Number(number);
            },
            BooleanNode: function(bool, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "BOOLEAN";
                this.bool = bool;
                this.stringModeValue = bool === "true";
            },
            CommentNode: function(comment, locInfo) {
                LocationInfo.call(this, locInfo);
                this.type = "comment";
                this.comment = comment;
            }
        };
        exports["default"] = AST;
    }, {
        "../exception": 13
    } ],
    7: [ function(require, module, exports) {
        "use strict";
        var parser = require("./parser")["default"];
        var AST = require("./ast")["default"];
        exports.parser = parser;
        function parse(input) {
            if (input.constructor === AST.ProgramNode) {
                return input;
            }
            parser.yy = AST;
            return parser.parse(input);
        }
        exports.parse = parse;
    }, {
        "./ast": 6,
        "./parser": 10
    } ],
    8: [ function(require, module, exports) {
        "use strict";
        var Exception = require("../exception")["default"];
        function Compiler() {}
        exports.Compiler = Compiler;
        Compiler.prototype = {
            compiler: Compiler,
            disassemble: function() {
                var opcodes = this.opcodes, opcode, out = [], params, param;
                for (var i = 0, l = opcodes.length; i < l; i++) {
                    opcode = opcodes[i];
                    if (opcode.opcode === "DECLARE") {
                        out.push("DECLARE " + opcode.name + "=" + opcode.value);
                    } else {
                        params = [];
                        for (var j = 0; j < opcode.args.length; j++) {
                            param = opcode.args[j];
                            if (typeof param === "string") {
                                param = '"' + param.replace("\n", "\\n") + '"';
                            }
                            params.push(param);
                        }
                        out.push(opcode.opcode + " " + params.join(" "));
                    }
                }
                return out.join("\n");
            },
            equals: function(other) {
                var len = this.opcodes.length;
                if (other.opcodes.length !== len) {
                    return false;
                }
                for (var i = 0; i < len; i++) {
                    var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
                    if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) {
                        return false;
                    }
                    for (var j = 0; j < opcode.args.length; j++) {
                        if (opcode.args[j] !== otherOpcode.args[j]) {
                            return false;
                        }
                    }
                }
                len = this.children.length;
                if (other.children.length !== len) {
                    return false;
                }
                for (i = 0; i < len; i++) {
                    if (!this.children[i].equals(other.children[i])) {
                        return false;
                    }
                }
                return true;
            },
            guid: 0,
            compile: function(program, options) {
                this.opcodes = [];
                this.children = [];
                this.depths = {
                    list: []
                };
                this.options = options;
                this.stringParams = options.stringParams;
                this.trackIds = options.trackIds;
                var knownHelpers = this.options.knownHelpers;
                this.options.knownHelpers = {
                    helperMissing: true,
                    blockHelperMissing: true,
                    each: true,
                    "if": true,
                    unless: true,
                    "with": true,
                    log: true,
                    lookup: true
                };
                if (knownHelpers) {
                    for (var name in knownHelpers) {
                        this.options.knownHelpers[name] = knownHelpers[name];
                    }
                }
                return this.accept(program);
            },
            accept: function(node) {
                var strip = node.strip || {}, ret;
                if (strip.left) {
                    this.opcode("strip");
                }
                ret = this[node.type](node);
                if (strip.right) {
                    this.opcode("strip");
                }
                return ret;
            },
            program: function(program) {
                var statements = program.statements;
                for (var i = 0, l = statements.length; i < l; i++) {
                    this.accept(statements[i]);
                }
                this.isSimple = l === 1;
                this.depths.list = this.depths.list.sort(function(a, b) {
                    return a - b;
                });
                return this;
            },
            compileProgram: function(program) {
                var result = new this.compiler().compile(program, this.options);
                var guid = this.guid++, depth;
                this.usePartial = this.usePartial || result.usePartial;
                this.children[guid] = result;
                for (var i = 0, l = result.depths.list.length; i < l; i++) {
                    depth = result.depths.list[i];
                    if (depth < 2) {
                        continue;
                    } else {
                        this.addDepth(depth - 1);
                    }
                }
                return guid;
            },
            block: function(block) {
                var mustache = block.mustache, program = block.program, inverse = block.inverse;
                if (program) {
                    program = this.compileProgram(program);
                }
                if (inverse) {
                    inverse = this.compileProgram(inverse);
                }
                var sexpr = mustache.sexpr;
                var type = this.classifySexpr(sexpr);
                if (type === "helper") {
                    this.helperSexpr(sexpr, program, inverse);
                } else if (type === "simple") {
                    this.simpleSexpr(sexpr);
                    this.opcode("pushProgram", program);
                    this.opcode("pushProgram", inverse);
                    this.opcode("emptyHash");
                    this.opcode("blockValue", sexpr.id.original);
                } else {
                    this.ambiguousSexpr(sexpr, program, inverse);
                    this.opcode("pushProgram", program);
                    this.opcode("pushProgram", inverse);
                    this.opcode("emptyHash");
                    this.opcode("ambiguousBlockValue");
                }
                this.opcode("append");
            },
            hash: function(hash) {
                var pairs = hash.pairs, i, l;
                this.opcode("pushHash");
                for (i = 0, l = pairs.length; i < l; i++) {
                    this.pushParam(pairs[i][1]);
                }
                while (i--) {
                    this.opcode("assignToHash", pairs[i][0]);
                }
                this.opcode("popHash");
            },
            partial: function(partial) {
                var partialName = partial.partialName;
                this.usePartial = true;
                if (partial.hash) {
                    this.accept(partial.hash);
                } else {
                    this.opcode("push", "undefined");
                }
                if (partial.context) {
                    this.accept(partial.context);
                } else {
                    this.opcode("push", "depth0");
                }
                this.opcode("invokePartial", partialName.name);
                this.opcode("append");
            },
            content: function(content) {
                this.opcode("appendContent", content.string);
            },
            mustache: function(mustache) {
                this.sexpr(mustache.sexpr);
                if (mustache.escaped && !this.options.noEscape) {
                    this.opcode("appendEscaped");
                } else {
                    this.opcode("append");
                }
            },
            ambiguousSexpr: function(sexpr, program, inverse) {
                var id = sexpr.id, name = id.parts[0], isBlock = program != null || inverse != null;
                this.opcode("getContext", id.depth);
                this.opcode("pushProgram", program);
                this.opcode("pushProgram", inverse);
                this.opcode("invokeAmbiguous", name, isBlock);
            },
            simpleSexpr: function(sexpr) {
                var id = sexpr.id;
                if (id.type === "DATA") {
                    this.DATA(id);
                } else if (id.parts.length) {
                    this.ID(id);
                } else {
                    this.addDepth(id.depth);
                    this.opcode("getContext", id.depth);
                    this.opcode("pushContext");
                }
                this.opcode("resolvePossibleLambda");
            },
            helperSexpr: function(sexpr, program, inverse) {
                var params = this.setupFullMustacheParams(sexpr, program, inverse), id = sexpr.id, name = id.parts[0];
                if (this.options.knownHelpers[name]) {
                    this.opcode("invokeKnownHelper", params.length, name);
                } else if (this.options.knownHelpersOnly) {
                    throw new Exception("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
                } else {
                    this.ID(id);
                    this.opcode("invokeHelper", params.length, id.original, sexpr.isRoot);
                }
            },
            sexpr: function(sexpr) {
                var type = this.classifySexpr(sexpr);
                if (type === "simple") {
                    this.simpleSexpr(sexpr);
                } else if (type === "helper") {
                    this.helperSexpr(sexpr);
                } else {
                    this.ambiguousSexpr(sexpr);
                }
            },
            ID: function(id) {
                this.addDepth(id.depth);
                this.opcode("getContext", id.depth);
                var name = id.parts[0];
                if (!name) {
                    this.opcode("pushContext");
                } else {
                    this.opcode("lookupOnContext", id.parts[0]);
                }
                for (var i = 1, l = id.parts.length; i < l; i++) {
                    this.opcode("lookup", id.parts[i]);
                }
            },
            DATA: function(data) {
                this.options.data = true;
                this.opcode("lookupData", data.id.depth);
                var parts = data.id.parts;
                for (var i = 0, l = parts.length; i < l; i++) {
                    this.opcode("lookup", parts[i]);
                }
            },
            STRING: function(string) {
                this.opcode("pushString", string.string);
            },
            NUMBER: function(number) {
                this.opcode("pushLiteral", number.number);
            },
            BOOLEAN: function(bool) {
                this.opcode("pushLiteral", bool.bool);
            },
            comment: function() {},
            opcode: function(name) {
                this.opcodes.push({
                    opcode: name,
                    args: [].slice.call(arguments, 1)
                });
            },
            declare: function(name, value) {
                this.opcodes.push({
                    opcode: "DECLARE",
                    name: name,
                    value: value
                });
            },
            addDepth: function(depth) {
                if (depth === 0) {
                    return;
                }
                if (!this.depths[depth]) {
                    this.depths[depth] = true;
                    this.depths.list.push(depth);
                }
            },
            classifySexpr: function(sexpr) {
                var isHelper = sexpr.isHelper;
                var isEligible = sexpr.eligibleHelper;
                var options = this.options;
                if (isEligible && !isHelper) {
                    var name = sexpr.id.parts[0];
                    if (options.knownHelpers[name]) {
                        isHelper = true;
                    } else if (options.knownHelpersOnly) {
                        isEligible = false;
                    }
                }
                if (isHelper) {
                    return "helper";
                } else if (isEligible) {
                    return "ambiguous";
                } else {
                    return "simple";
                }
            },
            pushParams: function(params) {
                for (var i = 0, l = params.length; i < l; i++) {
                    this.pushParam(params[i]);
                }
            },
            pushParam: function(val) {
                if (this.stringParams) {
                    if (val.depth) {
                        this.addDepth(val.depth);
                    }
                    this.opcode("getContext", val.depth || 0);
                    this.opcode("pushStringParam", val.stringModeValue, val.type);
                    if (val.type === "sexpr") {
                        this.sexpr(val);
                    }
                } else {
                    if (this.trackIds) {
                        this.opcode("pushId", val.type, val.idName || val.stringModeValue);
                    }
                    this.accept(val);
                }
            },
            setupFullMustacheParams: function(sexpr, program, inverse) {
                var params = sexpr.params;
                this.pushParams(params);
                this.opcode("pushProgram", program);
                this.opcode("pushProgram", inverse);
                if (sexpr.hash) {
                    this.hash(sexpr.hash);
                } else {
                    this.opcode("emptyHash");
                }
                return params;
            }
        };
        function precompile(input, options, env) {
            if (input == null || typeof input !== "string" && input.constructor !== env.AST.ProgramNode) {
                throw new Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
            }
            options = options || {};
            if (!("data" in options)) {
                options.data = true;
            }
            var ast = env.parse(input);
            var environment = new env.Compiler().compile(ast, options);
            return new env.JavaScriptCompiler().compile(environment, options);
        }
        exports.precompile = precompile;
        function compile(input, options, env) {
            if (input == null || typeof input !== "string" && input.constructor !== env.AST.ProgramNode) {
                throw new Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
            }
            options = options || {};
            if (!("data" in options)) {
                options.data = true;
            }
            var compiled;
            function compileInput() {
                var ast = env.parse(input);
                var environment = new env.Compiler().compile(ast, options);
                var templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
                return env.template(templateSpec);
            }
            var ret = function(context, options) {
                if (!compiled) {
                    compiled = compileInput();
                }
                return compiled.call(this, context, options);
            };
            ret._setup = function(options) {
                if (!compiled) {
                    compiled = compileInput();
                }
                return compiled._setup(options);
            };
            ret._child = function(i) {
                if (!compiled) {
                    compiled = compileInput();
                }
                return compiled._child(i);
            };
            return ret;
        }
        exports.compile = compile;
    }, {
        "../exception": 13
    } ],
    9: [ function(require, module, exports) {
        "use strict";
        var COMPILER_REVISION = require("../base").COMPILER_REVISION;
        var REVISION_CHANGES = require("../base").REVISION_CHANGES;
        var log = require("../base").log;
        var Exception = require("../exception")["default"];
        function Literal(value) {
            this.value = value;
        }
        function JavaScriptCompiler() {}
        JavaScriptCompiler.prototype = {
            nameLookup: function(parent, name) {
                var wrap, ret;
                if (parent.indexOf("depth") === 0) {
                    wrap = true;
                }
                if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
                    ret = parent + "." + name;
                } else {
                    ret = parent + "['" + name + "']";
                }
                if (wrap) {
                    return "(" + parent + " && " + ret + ")";
                } else {
                    return ret;
                }
            },
            compilerInfo: function() {
                var revision = COMPILER_REVISION, versions = REVISION_CHANGES[revision];
                return [ revision, versions ];
            },
            appendToBuffer: function(string) {
                if (this.environment.isSimple) {
                    return "return " + string + ";";
                } else {
                    return {
                        appendToBuffer: true,
                        content: string,
                        toString: function() {
                            return "buffer += " + string + ";";
                        }
                    };
                }
            },
            initializeBuffer: function() {
                return this.quotedString("");
            },
            namespace: "Handlebars",
            compile: function(environment, options, context, asObject) {
                this.environment = environment;
                this.options = options || {};
                this.stringParams = this.options.stringParams;
                this.trackIds = this.options.trackIds;
                this.precompile = !asObject;
                log("debug", this.environment.disassemble() + "\n\n");
                this.name = this.environment.name;
                this.isChild = !!context;
                this.context = context || {
                    programs: [],
                    environments: []
                };
                this.preamble();
                this.stackSlot = 0;
                this.stackVars = [];
                this.aliases = {};
                this.registers = {
                    list: []
                };
                this.hashes = [];
                this.compileStack = [];
                this.inlineStack = [];
                this.compileChildren(environment, options);
                var opcodes = environment.opcodes, opcode, i, l;
                for (i = 0, l = opcodes.length; i < l; i++) {
                    opcode = opcodes[i];
                    if (opcode.opcode === "DECLARE") {
                        this[opcode.name] = opcode.value;
                    } else {
                        this[opcode.opcode].apply(this, opcode.args);
                    }
                    if (opcode.opcode !== this.stripNext) {
                        this.stripNext = false;
                    }
                }
                this.pushSource("");
                if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
                    throw new Exception("Compile completed with content left on stack");
                }
                var fn = this.createFunctionContext(asObject);
                if (!this.isChild) {
                    var ret = {
                        compiler: this.compilerInfo(),
                        main: fn
                    };
                    var programs = this.context.programs;
                    for (i = 0, l = programs.length; i < l; i++) {
                        if (programs[i]) {
                            ret[i] = programs[i];
                        }
                    }
                    if (this.environment.usePartial) {
                        ret.usePartial = true;
                    }
                    if (this.options.data) {
                        ret.useData = true;
                    }
                    if (!asObject) {
                        ret.compiler = JSON.stringify(ret.compiler);
                        ret = this.objectLiteral(ret);
                    }
                    return ret;
                } else {
                    return fn;
                }
            },
            preamble: function() {
                this.lastContext = 0;
                this.source = [];
            },
            createFunctionContext: function(asObject) {
                var varDeclarations = "";
                var locals = this.stackVars.concat(this.registers.list);
                if (locals.length > 0) {
                    varDeclarations += ", " + locals.join(", ");
                }
                for (var alias in this.aliases) {
                    if (this.aliases.hasOwnProperty(alias)) {
                        varDeclarations += ", " + alias + "=" + this.aliases[alias];
                    }
                }
                var params = [ "depth0", "helpers", "partials", "data" ];
                for (var i = 0, l = this.environment.depths.list.length; i < l; i++) {
                    params.push("depth" + this.environment.depths.list[i]);
                }
                var source = this.mergeSource(varDeclarations);
                if (asObject) {
                    params.push(source);
                    return Function.apply(this, params);
                } else {
                    return "function(" + params.join(",") + ") {\n  " + source + "}";
                }
            },
            mergeSource: function(varDeclarations) {
                var source = "", buffer, appendOnly = !this.forceBuffer, appendFirst;
                for (var i = 0, len = this.source.length; i < len; i++) {
                    var line = this.source[i];
                    if (line.appendToBuffer) {
                        if (buffer) {
                            buffer = buffer + "\n    + " + line.content;
                        } else {
                            buffer = line.content;
                        }
                    } else {
                        if (buffer) {
                            if (!source) {
                                appendFirst = true;
                                source = buffer + ";\n  ";
                            } else {
                                source += "buffer += " + buffer + ";\n  ";
                            }
                            buffer = undefined;
                        }
                        source += line + "\n  ";
                        if (!this.environment.isSimple) {
                            appendOnly = false;
                        }
                    }
                }
                if (appendOnly) {
                    if (buffer || !source) {
                        source += "return " + (buffer || '""') + ";\n";
                    }
                } else {
                    varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
                    if (buffer) {
                        source += "return buffer + " + buffer + ";\n";
                    } else {
                        source += "return buffer;\n";
                    }
                }
                if (varDeclarations) {
                    source = "var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n  ") + source;
                }
                return source;
            },
            blockValue: function(name) {
                this.aliases.blockHelperMissing = "helpers.blockHelperMissing";
                var params = [ "depth0" ];
                this.setupParams(name, 0, params);
                this.replaceStack(function(current) {
                    params.splice(1, 0, current);
                    return "blockHelperMissing.call(" + params.join(", ") + ")";
                });
            },
            ambiguousBlockValue: function() {
                this.aliases.blockHelperMissing = "helpers.blockHelperMissing";
                var params = [ "depth0" ];
                this.setupParams("", 0, params, true);
                this.flushInline();
                var current = this.topStack();
                params.splice(1, 0, current);
                this.pushSource("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
            },
            appendContent: function(content) {
                if (this.pendingContent) {
                    content = this.pendingContent + content;
                }
                if (this.stripNext) {
                    content = content.replace(/^\s+/, "");
                }
                this.pendingContent = content;
            },
            strip: function() {
                if (this.pendingContent) {
                    this.pendingContent = this.pendingContent.replace(/\s+$/, "");
                }
                this.stripNext = "strip";
            },
            append: function() {
                this.flushInline();
                var local = this.popStack();
                this.pushSource("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
                if (this.environment.isSimple) {
                    this.pushSource("else { " + this.appendToBuffer("''") + " }");
                }
            },
            appendEscaped: function() {
                this.aliases.escapeExpression = "this.escapeExpression";
                this.pushSource(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
            },
            getContext: function(depth) {
                if (this.lastContext !== depth) {
                    this.lastContext = depth;
                }
            },
            lookupOnContext: function(name) {
                this.push(this.nameLookup("depth" + this.lastContext, name, "context"));
            },
            pushContext: function() {
                this.pushStackLiteral("depth" + this.lastContext);
            },
            resolvePossibleLambda: function() {
                this.aliases.functionType = '"function"';
                this.replaceStack(function(current) {
                    return "typeof " + current + " === functionType ? " + current + ".apply(depth0) : " + current;
                });
            },
            lookup: function(name) {
                this.replaceStack(function(current) {
                    return current + " == null || " + current + " === false ? " + current + " : " + this.nameLookup(current, name, "context");
                });
            },
            lookupData: function(depth) {
                if (!depth) {
                    this.pushStackLiteral("data");
                } else {
                    this.pushStackLiteral("this.data(data, " + depth + ")");
                }
            },
            pushStringParam: function(string, type) {
                this.pushStackLiteral("depth" + this.lastContext);
                this.pushString(type);
                if (type !== "sexpr") {
                    if (typeof string === "string") {
                        this.pushString(string);
                    } else {
                        this.pushStackLiteral(string);
                    }
                }
            },
            emptyHash: function() {
                this.pushStackLiteral("{}");
                if (this.trackIds) {
                    this.push("{}");
                }
                if (this.stringParams) {
                    this.push("{}");
                    this.push("{}");
                }
            },
            pushHash: function() {
                if (this.hash) {
                    this.hashes.push(this.hash);
                }
                this.hash = {
                    values: [],
                    types: [],
                    contexts: [],
                    ids: []
                };
            },
            popHash: function() {
                var hash = this.hash;
                this.hash = this.hashes.pop();
                if (this.trackIds) {
                    this.push("{" + hash.ids.join(",") + "}");
                }
                if (this.stringParams) {
                    this.push("{" + hash.contexts.join(",") + "}");
                    this.push("{" + hash.types.join(",") + "}");
                }
                this.push("{\n    " + hash.values.join(",\n    ") + "\n  }");
            },
            pushString: function(string) {
                this.pushStackLiteral(this.quotedString(string));
            },
            push: function(expr) {
                this.inlineStack.push(expr);
                return expr;
            },
            pushLiteral: function(value) {
                this.pushStackLiteral(value);
            },
            pushProgram: function(guid) {
                if (guid != null) {
                    this.pushStackLiteral(this.programExpression(guid));
                } else {
                    this.pushStackLiteral(null);
                }
            },
            invokeHelper: function(paramSize, name, isRoot) {
                this.aliases.helperMissing = "helpers.helperMissing";
                this.useRegister("helper");
                var nonHelper = this.popStack();
                var helper = this.setupHelper(paramSize, name);
                var lookup = "helper = " + helper.name + " || " + nonHelper + " || helperMissing";
                if (helper.paramsInit) {
                    lookup += "," + helper.paramsInit;
                }
                this.push("(" + lookup + ",helper.call(" + helper.callParams + "))");
                if (!isRoot) {
                    this.flushInline();
                }
            },
            invokeKnownHelper: function(paramSize, name) {
                var helper = this.setupHelper(paramSize, name);
                this.push(helper.name + ".call(" + helper.callParams + ")");
            },
            invokeAmbiguous: function(name, helperCall) {
                this.aliases.functionType = '"function"';
                this.useRegister("helper");
                this.emptyHash();
                var helper = this.setupHelper(0, name, helperCall);
                var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
                var nonHelper = this.nameLookup("depth" + this.lastContext, name, "context");
                this.push("((helper = " + helperName + " || " + nonHelper + (helper.paramsInit ? "),(" + helper.paramsInit : "") + ")," + "(typeof helper === functionType ? helper.call(" + helper.callParams + ") : helper))");
            },
            invokePartial: function(name) {
                var params = [ this.nameLookup("partials", name, "partial"), "'" + name + "'", this.popStack(), this.popStack(), "helpers", "partials" ];
                if (this.options.data) {
                    params.push("data");
                }
                this.push("this.invokePartial(" + params.join(", ") + ")");
            },
            assignToHash: function(key) {
                var value = this.popStack(), context, type, id;
                if (this.trackIds) {
                    id = this.popStack();
                }
                if (this.stringParams) {
                    type = this.popStack();
                    context = this.popStack();
                }
                var hash = this.hash;
                if (context) {
                    hash.contexts.push("'" + key + "': " + context);
                }
                if (type) {
                    hash.types.push("'" + key + "': " + type);
                }
                if (id) {
                    hash.ids.push("'" + key + "': " + id);
                }
                hash.values.push("'" + key + "': (" + value + ")");
            },
            pushId: function(type, name) {
                if (type === "ID" || type === "DATA") {
                    this.pushString(name);
                } else if (type === "sexpr") {
                    this.pushStackLiteral("true");
                } else {
                    this.pushStackLiteral("null");
                }
            },
            compiler: JavaScriptCompiler,
            compileChildren: function(environment, options) {
                var children = environment.children, child, compiler;
                for (var i = 0, l = children.length; i < l; i++) {
                    child = children[i];
                    compiler = new this.compiler();
                    var index = this.matchExistingProgram(child);
                    if (index == null) {
                        this.context.programs.push("");
                        index = this.context.programs.length;
                        child.index = index;
                        child.name = "program" + index;
                        this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
                        this.context.environments[index] = child;
                    } else {
                        child.index = index;
                        child.name = "program" + index;
                    }
                }
            },
            matchExistingProgram: function(child) {
                for (var i = 0, len = this.context.environments.length; i < len; i++) {
                    var environment = this.context.environments[i];
                    if (environment && environment.equals(child)) {
                        return i;
                    }
                }
            },
            programExpression: function(guid) {
                if (guid == null) {
                    return "this.noop";
                }
                var child = this.environment.children[guid], depths = child.depths.list, depth;
                var programParams = [ child.index, "data" ];
                for (var i = 0, l = depths.length; i < l; i++) {
                    depth = depths[i];
                    programParams.push("depth" + (depth - 1));
                }
                return (depths.length === 0 ? "this.program(" : "this.programWithDepth(") + programParams.join(", ") + ")";
            },
            register: function(name, val) {
                this.useRegister(name);
                this.pushSource(name + " = " + val + ";");
            },
            useRegister: function(name) {
                if (!this.registers[name]) {
                    this.registers[name] = true;
                    this.registers.list.push(name);
                }
            },
            pushStackLiteral: function(item) {
                return this.push(new Literal(item));
            },
            pushSource: function(source) {
                if (this.pendingContent) {
                    this.source.push(this.appendToBuffer(this.quotedString(this.pendingContent)));
                    this.pendingContent = undefined;
                }
                if (source) {
                    this.source.push(source);
                }
            },
            pushStack: function(item) {
                this.flushInline();
                var stack = this.incrStack();
                if (item) {
                    this.pushSource(stack + " = " + item + ";");
                }
                this.compileStack.push(stack);
                return stack;
            },
            replaceStack: function(callback) {
                var prefix = "", inline = this.isInline(), stack, createdStack, usedLiteral;
                if (inline) {
                    var top = this.popStack(true);
                    if (top instanceof Literal) {
                        stack = top.value;
                        usedLiteral = true;
                    } else {
                        createdStack = !this.stackSlot;
                        var name = !createdStack ? this.topStackName() : this.incrStack();
                        prefix = "(" + this.push(name) + " = " + top + "),";
                        stack = this.topStack();
                    }
                } else {
                    stack = this.topStack();
                }
                var item = callback.call(this, stack);
                if (inline) {
                    if (!usedLiteral) {
                        this.popStack();
                    }
                    if (createdStack) {
                        this.stackSlot--;
                    }
                    this.push("(" + prefix + item + ")");
                } else {
                    if (!/^stack/.test(stack)) {
                        stack = this.nextStack();
                    }
                    this.pushSource(stack + " = (" + prefix + item + ");");
                }
                return stack;
            },
            nextStack: function() {
                return this.pushStack();
            },
            incrStack: function() {
                this.stackSlot++;
                if (this.stackSlot > this.stackVars.length) {
                    this.stackVars.push("stack" + this.stackSlot);
                }
                return this.topStackName();
            },
            topStackName: function() {
                return "stack" + this.stackSlot;
            },
            flushInline: function() {
                var inlineStack = this.inlineStack;
                if (inlineStack.length) {
                    this.inlineStack = [];
                    for (var i = 0, len = inlineStack.length; i < len; i++) {
                        var entry = inlineStack[i];
                        if (entry instanceof Literal) {
                            this.compileStack.push(entry);
                        } else {
                            this.pushStack(entry);
                        }
                    }
                }
            },
            isInline: function() {
                return this.inlineStack.length;
            },
            popStack: function(wrapped) {
                var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
                if (!wrapped && item instanceof Literal) {
                    return item.value;
                } else {
                    if (!inline) {
                        if (!this.stackSlot) {
                            throw new Exception("Invalid stack pop");
                        }
                        this.stackSlot--;
                    }
                    return item;
                }
            },
            topStack: function(wrapped) {
                var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
                if (!wrapped && item instanceof Literal) {
                    return item.value;
                } else {
                    return item;
                }
            },
            quotedString: function(str) {
                return '"' + str.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
            },
            objectLiteral: function(obj) {
                var pairs = [];
                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        pairs.push(this.quotedString(key) + ":" + obj[key]);
                    }
                }
                return "{" + pairs.join(",") + "}";
            },
            setupHelper: function(paramSize, name, blockHelper) {
                var params = [], paramsInit = this.setupParams(name, paramSize, params, blockHelper);
                var foundHelper = this.nameLookup("helpers", name, "helper");
                return {
                    params: params,
                    paramsInit: paramsInit,
                    name: foundHelper,
                    callParams: [ "depth0" ].concat(params).join(", ")
                };
            },
            setupOptions: function(helper, paramSize, params) {
                var options = {}, contexts = [], types = [], ids = [], param, inverse, program;
                options.name = this.quotedString(helper);
                options.hash = this.popStack();
                if (this.trackIds) {
                    options.hashIds = this.popStack();
                }
                if (this.stringParams) {
                    options.hashTypes = this.popStack();
                    options.hashContexts = this.popStack();
                }
                inverse = this.popStack();
                program = this.popStack();
                if (program || inverse) {
                    if (!program) {
                        program = "this.noop";
                    }
                    if (!inverse) {
                        inverse = "this.noop";
                    }
                    options.fn = program;
                    options.inverse = inverse;
                }
                var i = paramSize;
                while (i--) {
                    param = this.popStack();
                    params[i] = param;
                    if (this.trackIds) {
                        ids[i] = this.popStack();
                    }
                    if (this.stringParams) {
                        types[i] = this.popStack();
                        contexts[i] = this.popStack();
                    }
                }
                if (this.trackIds) {
                    options.ids = "[" + ids.join(",") + "]";
                }
                if (this.stringParams) {
                    options.types = "[" + types.join(",") + "]";
                    options.contexts = "[" + contexts.join(",") + "]";
                }
                if (this.options.data) {
                    options.data = "data";
                }
                return options;
            },
            setupParams: function(helperName, paramSize, params, useRegister) {
                var options = this.objectLiteral(this.setupOptions(helperName, paramSize, params));
                if (useRegister) {
                    this.useRegister("options");
                    params.push("options");
                    return "options=" + options;
                } else {
                    params.push(options);
                    return "";
                }
            }
        };
        var reservedWords = ("break else new var" + " case finally return void" + " catch for switch while" + " continue function this with" + " default if throw" + " delete in try" + " do instanceof typeof" + " abstract enum int short" + " boolean export interface static" + " byte extends long super" + " char final native synchronized" + " class float package throws" + " const goto private transient" + " debugger implements protected volatile" + " double import public let yield").split(" ");
        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
        for (var i = 0, l = reservedWords.length; i < l; i++) {
            compilerWords[reservedWords[i]] = true;
        }
        JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
            return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
        };
        exports["default"] = JavaScriptCompiler;
    }, {
        "../base": 5,
        "../exception": 13
    } ],
    10: [ function(require, module, exports) {
        "use strict";
        var handlebars = function() {
            var parser = {
                trace: function trace() {},
                yy: {},
                symbols_: {
                    error: 2,
                    root: 3,
                    statements: 4,
                    EOF: 5,
                    program: 6,
                    simpleInverse: 7,
                    statement: 8,
                    openRawBlock: 9,
                    CONTENT: 10,
                    END_RAW_BLOCK: 11,
                    openInverse: 12,
                    closeBlock: 13,
                    openBlock: 14,
                    mustache: 15,
                    partial: 16,
                    COMMENT: 17,
                    OPEN_RAW_BLOCK: 18,
                    sexpr: 19,
                    CLOSE_RAW_BLOCK: 20,
                    OPEN_BLOCK: 21,
                    CLOSE: 22,
                    OPEN_INVERSE: 23,
                    OPEN_ENDBLOCK: 24,
                    path: 25,
                    OPEN: 26,
                    OPEN_UNESCAPED: 27,
                    CLOSE_UNESCAPED: 28,
                    OPEN_PARTIAL: 29,
                    partialName: 30,
                    param: 31,
                    partial_option0: 32,
                    partial_option1: 33,
                    sexpr_repetition0: 34,
                    sexpr_option0: 35,
                    dataName: 36,
                    STRING: 37,
                    NUMBER: 38,
                    BOOLEAN: 39,
                    OPEN_SEXPR: 40,
                    CLOSE_SEXPR: 41,
                    hash: 42,
                    hash_repetition_plus0: 43,
                    hashSegment: 44,
                    ID: 45,
                    EQUALS: 46,
                    DATA: 47,
                    pathSegments: 48,
                    SEP: 49,
                    $accept: 0,
                    $end: 1
                },
                terminals_: {
                    2: "error",
                    5: "EOF",
                    10: "CONTENT",
                    11: "END_RAW_BLOCK",
                    17: "COMMENT",
                    18: "OPEN_RAW_BLOCK",
                    20: "CLOSE_RAW_BLOCK",
                    21: "OPEN_BLOCK",
                    22: "CLOSE",
                    23: "OPEN_INVERSE",
                    24: "OPEN_ENDBLOCK",
                    26: "OPEN",
                    27: "OPEN_UNESCAPED",
                    28: "CLOSE_UNESCAPED",
                    29: "OPEN_PARTIAL",
                    37: "STRING",
                    38: "NUMBER",
                    39: "BOOLEAN",
                    40: "OPEN_SEXPR",
                    41: "CLOSE_SEXPR",
                    45: "ID",
                    46: "EQUALS",
                    47: "DATA",
                    49: "SEP"
                },
                productions_: [ 0, [ 3, 2 ], [ 3, 1 ], [ 6, 2 ], [ 6, 3 ], [ 6, 2 ], [ 6, 1 ], [ 6, 1 ], [ 6, 0 ], [ 4, 1 ], [ 4, 2 ], [ 8, 3 ], [ 8, 3 ], [ 8, 3 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 8, 1 ], [ 9, 3 ], [ 14, 3 ], [ 12, 3 ], [ 13, 3 ], [ 15, 3 ], [ 15, 3 ], [ 16, 5 ], [ 16, 4 ], [ 7, 2 ], [ 19, 3 ], [ 19, 1 ], [ 31, 1 ], [ 31, 1 ], [ 31, 1 ], [ 31, 1 ], [ 31, 1 ], [ 31, 3 ], [ 42, 1 ], [ 44, 3 ], [ 30, 1 ], [ 30, 1 ], [ 30, 1 ], [ 36, 2 ], [ 25, 1 ], [ 48, 3 ], [ 48, 1 ], [ 32, 0 ], [ 32, 1 ], [ 33, 0 ], [ 33, 1 ], [ 34, 0 ], [ 34, 2 ], [ 35, 0 ], [ 35, 1 ], [ 43, 1 ], [ 43, 2 ] ],
                performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
                    var $0 = $$.length - 1;
                    switch (yystate) {
                      case 1:
                        return new yy.ProgramNode($$[$0 - 1], this._$);
                        break;

                      case 2:
                        return new yy.ProgramNode([], this._$);
                        break;

                      case 3:
                        this.$ = new yy.ProgramNode([], $$[$0 - 1], $$[$0], this._$);
                        break;

                      case 4:
                        this.$ = new yy.ProgramNode($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                        break;

                      case 5:
                        this.$ = new yy.ProgramNode($$[$0 - 1], $$[$0], [], this._$);
                        break;

                      case 6:
                        this.$ = new yy.ProgramNode($$[$0], this._$);
                        break;

                      case 7:
                        this.$ = new yy.ProgramNode([], this._$);
                        break;

                      case 8:
                        this.$ = new yy.ProgramNode([], this._$);
                        break;

                      case 9:
                        this.$ = [ $$[$0] ];
                        break;

                      case 10:
                        $$[$0 - 1].push($$[$0]);
                        this.$ = $$[$0 - 1];
                        break;

                      case 11:
                        this.$ = new yy.RawBlockNode($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                        break;

                      case 12:
                        this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1].inverse, $$[$0 - 1], $$[$0], this._$);
                        break;

                      case 13:
                        this.$ = new yy.BlockNode($$[$0 - 2], $$[$0 - 1], $$[$0 - 1].inverse, $$[$0], this._$);
                        break;

                      case 14:
                        this.$ = $$[$0];
                        break;

                      case 15:
                        this.$ = $$[$0];
                        break;

                      case 16:
                        this.$ = new yy.ContentNode($$[$0], this._$);
                        break;

                      case 17:
                        this.$ = new yy.CommentNode($$[$0], this._$);
                        break;

                      case 18:
                        this.$ = new yy.MustacheNode($$[$0 - 1], null, "", "", this._$);
                        break;

                      case 19:
                        this.$ = new yy.MustacheNode($$[$0 - 1], null, $$[$0 - 2], stripFlags($$[$0 - 2], $$[$0]), this._$);
                        break;

                      case 20:
                        this.$ = new yy.MustacheNode($$[$0 - 1], null, $$[$0 - 2], stripFlags($$[$0 - 2], $$[$0]), this._$);
                        break;

                      case 21:
                        this.$ = {
                            path: $$[$0 - 1],
                            strip: stripFlags($$[$0 - 2], $$[$0])
                        };
                        break;

                      case 22:
                        this.$ = new yy.MustacheNode($$[$0 - 1], null, $$[$0 - 2], stripFlags($$[$0 - 2], $$[$0]), this._$);
                        break;

                      case 23:
                        this.$ = new yy.MustacheNode($$[$0 - 1], null, $$[$0 - 2], stripFlags($$[$0 - 2], $$[$0]), this._$);
                        break;

                      case 24:
                        this.$ = new yy.PartialNode($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], stripFlags($$[$0 - 4], $$[$0]), this._$);
                        break;

                      case 25:
                        this.$ = new yy.PartialNode($$[$0 - 2], undefined, $$[$0 - 1], stripFlags($$[$0 - 3], $$[$0]), this._$);
                        break;

                      case 26:
                        this.$ = stripFlags($$[$0 - 1], $$[$0]);
                        break;

                      case 27:
                        this.$ = new yy.SexprNode([ $$[$0 - 2] ].concat($$[$0 - 1]), $$[$0], this._$);
                        break;

                      case 28:
                        this.$ = new yy.SexprNode([ $$[$0] ], null, this._$);
                        break;

                      case 29:
                        this.$ = $$[$0];
                        break;

                      case 30:
                        this.$ = new yy.StringNode($$[$0], this._$);
                        break;

                      case 31:
                        this.$ = new yy.NumberNode($$[$0], this._$);
                        break;

                      case 32:
                        this.$ = new yy.BooleanNode($$[$0], this._$);
                        break;

                      case 33:
                        this.$ = $$[$0];
                        break;

                      case 34:
                        $$[$0 - 1].isHelper = true;
                        this.$ = $$[$0 - 1];
                        break;

                      case 35:
                        this.$ = new yy.HashNode($$[$0], this._$);
                        break;

                      case 36:
                        this.$ = [ $$[$0 - 2], $$[$0] ];
                        break;

                      case 37:
                        this.$ = new yy.PartialNameNode($$[$0], this._$);
                        break;

                      case 38:
                        this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0], this._$), this._$);
                        break;

                      case 39:
                        this.$ = new yy.PartialNameNode(new yy.NumberNode($$[$0], this._$));
                        break;

                      case 40:
                        this.$ = new yy.DataNode($$[$0], this._$);
                        break;

                      case 41:
                        this.$ = new yy.IdNode($$[$0], this._$);
                        break;

                      case 42:
                        $$[$0 - 2].push({
                            part: $$[$0],
                            separator: $$[$0 - 1]
                        });
                        this.$ = $$[$0 - 2];
                        break;

                      case 43:
                        this.$ = [ {
                            part: $$[$0]
                        } ];
                        break;

                      case 48:
                        this.$ = [];
                        break;

                      case 49:
                        $$[$0 - 1].push($$[$0]);
                        break;

                      case 52:
                        this.$ = [ $$[$0] ];
                        break;

                      case 53:
                        $$[$0 - 1].push($$[$0]);
                        break;
                    }
                },
                table: [ {
                    3: 1,
                    4: 2,
                    5: [ 1, 3 ],
                    8: 4,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 13 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    1: [ 3 ]
                }, {
                    5: [ 1, 18 ],
                    8: 19,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 13 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    1: [ 2, 2 ]
                }, {
                    5: [ 2, 9 ],
                    10: [ 2, 9 ],
                    17: [ 2, 9 ],
                    18: [ 2, 9 ],
                    21: [ 2, 9 ],
                    23: [ 2, 9 ],
                    24: [ 2, 9 ],
                    26: [ 2, 9 ],
                    27: [ 2, 9 ],
                    29: [ 2, 9 ]
                }, {
                    10: [ 1, 20 ]
                }, {
                    4: 23,
                    6: 21,
                    7: 22,
                    8: 4,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 24 ],
                    24: [ 2, 8 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    4: 23,
                    6: 25,
                    7: 22,
                    8: 4,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 24 ],
                    24: [ 2, 8 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    5: [ 2, 14 ],
                    10: [ 2, 14 ],
                    17: [ 2, 14 ],
                    18: [ 2, 14 ],
                    21: [ 2, 14 ],
                    23: [ 2, 14 ],
                    24: [ 2, 14 ],
                    26: [ 2, 14 ],
                    27: [ 2, 14 ],
                    29: [ 2, 14 ]
                }, {
                    5: [ 2, 15 ],
                    10: [ 2, 15 ],
                    17: [ 2, 15 ],
                    18: [ 2, 15 ],
                    21: [ 2, 15 ],
                    23: [ 2, 15 ],
                    24: [ 2, 15 ],
                    26: [ 2, 15 ],
                    27: [ 2, 15 ],
                    29: [ 2, 15 ]
                }, {
                    5: [ 2, 16 ],
                    10: [ 2, 16 ],
                    17: [ 2, 16 ],
                    18: [ 2, 16 ],
                    21: [ 2, 16 ],
                    23: [ 2, 16 ],
                    24: [ 2, 16 ],
                    26: [ 2, 16 ],
                    27: [ 2, 16 ],
                    29: [ 2, 16 ]
                }, {
                    5: [ 2, 17 ],
                    10: [ 2, 17 ],
                    17: [ 2, 17 ],
                    18: [ 2, 17 ],
                    21: [ 2, 17 ],
                    23: [ 2, 17 ],
                    24: [ 2, 17 ],
                    26: [ 2, 17 ],
                    27: [ 2, 17 ],
                    29: [ 2, 17 ]
                }, {
                    19: 26,
                    25: 27,
                    36: 28,
                    45: [ 1, 31 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    19: 32,
                    25: 27,
                    36: 28,
                    45: [ 1, 31 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    19: 33,
                    25: 27,
                    36: 28,
                    45: [ 1, 31 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    19: 34,
                    25: 27,
                    36: 28,
                    45: [ 1, 31 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    19: 35,
                    25: 27,
                    36: 28,
                    45: [ 1, 31 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    25: 37,
                    30: 36,
                    37: [ 1, 38 ],
                    38: [ 1, 39 ],
                    45: [ 1, 31 ],
                    48: 29
                }, {
                    1: [ 2, 1 ]
                }, {
                    5: [ 2, 10 ],
                    10: [ 2, 10 ],
                    17: [ 2, 10 ],
                    18: [ 2, 10 ],
                    21: [ 2, 10 ],
                    23: [ 2, 10 ],
                    24: [ 2, 10 ],
                    26: [ 2, 10 ],
                    27: [ 2, 10 ],
                    29: [ 2, 10 ]
                }, {
                    11: [ 1, 40 ]
                }, {
                    13: 41,
                    24: [ 1, 42 ]
                }, {
                    4: 43,
                    8: 4,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 13 ],
                    24: [ 2, 7 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    7: 44,
                    8: 19,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 24 ],
                    24: [ 2, 6 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    19: 32,
                    22: [ 1, 45 ],
                    25: 27,
                    36: 28,
                    45: [ 1, 31 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    13: 46,
                    24: [ 1, 42 ]
                }, {
                    20: [ 1, 47 ]
                }, {
                    20: [ 2, 48 ],
                    22: [ 2, 48 ],
                    28: [ 2, 48 ],
                    34: 48,
                    37: [ 2, 48 ],
                    38: [ 2, 48 ],
                    39: [ 2, 48 ],
                    40: [ 2, 48 ],
                    41: [ 2, 48 ],
                    45: [ 2, 48 ],
                    47: [ 2, 48 ]
                }, {
                    20: [ 2, 28 ],
                    22: [ 2, 28 ],
                    28: [ 2, 28 ],
                    41: [ 2, 28 ]
                }, {
                    20: [ 2, 41 ],
                    22: [ 2, 41 ],
                    28: [ 2, 41 ],
                    37: [ 2, 41 ],
                    38: [ 2, 41 ],
                    39: [ 2, 41 ],
                    40: [ 2, 41 ],
                    41: [ 2, 41 ],
                    45: [ 2, 41 ],
                    47: [ 2, 41 ],
                    49: [ 1, 49 ]
                }, {
                    25: 50,
                    45: [ 1, 31 ],
                    48: 29
                }, {
                    20: [ 2, 43 ],
                    22: [ 2, 43 ],
                    28: [ 2, 43 ],
                    37: [ 2, 43 ],
                    38: [ 2, 43 ],
                    39: [ 2, 43 ],
                    40: [ 2, 43 ],
                    41: [ 2, 43 ],
                    45: [ 2, 43 ],
                    47: [ 2, 43 ],
                    49: [ 2, 43 ]
                }, {
                    22: [ 1, 51 ]
                }, {
                    22: [ 1, 52 ]
                }, {
                    22: [ 1, 53 ]
                }, {
                    28: [ 1, 54 ]
                }, {
                    22: [ 2, 46 ],
                    25: 57,
                    31: 55,
                    33: 56,
                    36: 61,
                    37: [ 1, 58 ],
                    38: [ 1, 59 ],
                    39: [ 1, 60 ],
                    40: [ 1, 62 ],
                    42: 63,
                    43: 64,
                    44: 66,
                    45: [ 1, 65 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    22: [ 2, 37 ],
                    37: [ 2, 37 ],
                    38: [ 2, 37 ],
                    39: [ 2, 37 ],
                    40: [ 2, 37 ],
                    45: [ 2, 37 ],
                    47: [ 2, 37 ]
                }, {
                    22: [ 2, 38 ],
                    37: [ 2, 38 ],
                    38: [ 2, 38 ],
                    39: [ 2, 38 ],
                    40: [ 2, 38 ],
                    45: [ 2, 38 ],
                    47: [ 2, 38 ]
                }, {
                    22: [ 2, 39 ],
                    37: [ 2, 39 ],
                    38: [ 2, 39 ],
                    39: [ 2, 39 ],
                    40: [ 2, 39 ],
                    45: [ 2, 39 ],
                    47: [ 2, 39 ]
                }, {
                    5: [ 2, 11 ],
                    10: [ 2, 11 ],
                    17: [ 2, 11 ],
                    18: [ 2, 11 ],
                    21: [ 2, 11 ],
                    23: [ 2, 11 ],
                    24: [ 2, 11 ],
                    26: [ 2, 11 ],
                    27: [ 2, 11 ],
                    29: [ 2, 11 ]
                }, {
                    5: [ 2, 12 ],
                    10: [ 2, 12 ],
                    17: [ 2, 12 ],
                    18: [ 2, 12 ],
                    21: [ 2, 12 ],
                    23: [ 2, 12 ],
                    24: [ 2, 12 ],
                    26: [ 2, 12 ],
                    27: [ 2, 12 ],
                    29: [ 2, 12 ]
                }, {
                    25: 67,
                    45: [ 1, 31 ],
                    48: 29
                }, {
                    8: 19,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 13 ],
                    24: [ 2, 3 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    4: 68,
                    8: 4,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 13 ],
                    24: [ 2, 5 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    10: [ 2, 26 ],
                    17: [ 2, 26 ],
                    18: [ 2, 26 ],
                    21: [ 2, 26 ],
                    23: [ 2, 26 ],
                    24: [ 2, 26 ],
                    26: [ 2, 26 ],
                    27: [ 2, 26 ],
                    29: [ 2, 26 ]
                }, {
                    5: [ 2, 13 ],
                    10: [ 2, 13 ],
                    17: [ 2, 13 ],
                    18: [ 2, 13 ],
                    21: [ 2, 13 ],
                    23: [ 2, 13 ],
                    24: [ 2, 13 ],
                    26: [ 2, 13 ],
                    27: [ 2, 13 ],
                    29: [ 2, 13 ]
                }, {
                    10: [ 2, 18 ]
                }, {
                    20: [ 2, 50 ],
                    22: [ 2, 50 ],
                    25: 57,
                    28: [ 2, 50 ],
                    31: 70,
                    35: 69,
                    36: 61,
                    37: [ 1, 58 ],
                    38: [ 1, 59 ],
                    39: [ 1, 60 ],
                    40: [ 1, 62 ],
                    41: [ 2, 50 ],
                    42: 71,
                    43: 64,
                    44: 66,
                    45: [ 1, 65 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    45: [ 1, 72 ]
                }, {
                    20: [ 2, 40 ],
                    22: [ 2, 40 ],
                    28: [ 2, 40 ],
                    37: [ 2, 40 ],
                    38: [ 2, 40 ],
                    39: [ 2, 40 ],
                    40: [ 2, 40 ],
                    41: [ 2, 40 ],
                    45: [ 2, 40 ],
                    47: [ 2, 40 ]
                }, {
                    10: [ 2, 20 ],
                    17: [ 2, 20 ],
                    18: [ 2, 20 ],
                    21: [ 2, 20 ],
                    23: [ 2, 20 ],
                    24: [ 2, 20 ],
                    26: [ 2, 20 ],
                    27: [ 2, 20 ],
                    29: [ 2, 20 ]
                }, {
                    10: [ 2, 19 ],
                    17: [ 2, 19 ],
                    18: [ 2, 19 ],
                    21: [ 2, 19 ],
                    23: [ 2, 19 ],
                    24: [ 2, 19 ],
                    26: [ 2, 19 ],
                    27: [ 2, 19 ],
                    29: [ 2, 19 ]
                }, {
                    5: [ 2, 22 ],
                    10: [ 2, 22 ],
                    17: [ 2, 22 ],
                    18: [ 2, 22 ],
                    21: [ 2, 22 ],
                    23: [ 2, 22 ],
                    24: [ 2, 22 ],
                    26: [ 2, 22 ],
                    27: [ 2, 22 ],
                    29: [ 2, 22 ]
                }, {
                    5: [ 2, 23 ],
                    10: [ 2, 23 ],
                    17: [ 2, 23 ],
                    18: [ 2, 23 ],
                    21: [ 2, 23 ],
                    23: [ 2, 23 ],
                    24: [ 2, 23 ],
                    26: [ 2, 23 ],
                    27: [ 2, 23 ],
                    29: [ 2, 23 ]
                }, {
                    22: [ 2, 44 ],
                    32: 73,
                    42: 74,
                    43: 64,
                    44: 66,
                    45: [ 1, 75 ]
                }, {
                    22: [ 1, 76 ]
                }, {
                    20: [ 2, 29 ],
                    22: [ 2, 29 ],
                    28: [ 2, 29 ],
                    37: [ 2, 29 ],
                    38: [ 2, 29 ],
                    39: [ 2, 29 ],
                    40: [ 2, 29 ],
                    41: [ 2, 29 ],
                    45: [ 2, 29 ],
                    47: [ 2, 29 ]
                }, {
                    20: [ 2, 30 ],
                    22: [ 2, 30 ],
                    28: [ 2, 30 ],
                    37: [ 2, 30 ],
                    38: [ 2, 30 ],
                    39: [ 2, 30 ],
                    40: [ 2, 30 ],
                    41: [ 2, 30 ],
                    45: [ 2, 30 ],
                    47: [ 2, 30 ]
                }, {
                    20: [ 2, 31 ],
                    22: [ 2, 31 ],
                    28: [ 2, 31 ],
                    37: [ 2, 31 ],
                    38: [ 2, 31 ],
                    39: [ 2, 31 ],
                    40: [ 2, 31 ],
                    41: [ 2, 31 ],
                    45: [ 2, 31 ],
                    47: [ 2, 31 ]
                }, {
                    20: [ 2, 32 ],
                    22: [ 2, 32 ],
                    28: [ 2, 32 ],
                    37: [ 2, 32 ],
                    38: [ 2, 32 ],
                    39: [ 2, 32 ],
                    40: [ 2, 32 ],
                    41: [ 2, 32 ],
                    45: [ 2, 32 ],
                    47: [ 2, 32 ]
                }, {
                    20: [ 2, 33 ],
                    22: [ 2, 33 ],
                    28: [ 2, 33 ],
                    37: [ 2, 33 ],
                    38: [ 2, 33 ],
                    39: [ 2, 33 ],
                    40: [ 2, 33 ],
                    41: [ 2, 33 ],
                    45: [ 2, 33 ],
                    47: [ 2, 33 ]
                }, {
                    19: 77,
                    25: 27,
                    36: 28,
                    45: [ 1, 31 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    22: [ 2, 47 ]
                }, {
                    20: [ 2, 35 ],
                    22: [ 2, 35 ],
                    28: [ 2, 35 ],
                    41: [ 2, 35 ],
                    44: 78,
                    45: [ 1, 75 ]
                }, {
                    20: [ 2, 43 ],
                    22: [ 2, 43 ],
                    28: [ 2, 43 ],
                    37: [ 2, 43 ],
                    38: [ 2, 43 ],
                    39: [ 2, 43 ],
                    40: [ 2, 43 ],
                    41: [ 2, 43 ],
                    45: [ 2, 43 ],
                    46: [ 1, 79 ],
                    47: [ 2, 43 ],
                    49: [ 2, 43 ]
                }, {
                    20: [ 2, 52 ],
                    22: [ 2, 52 ],
                    28: [ 2, 52 ],
                    41: [ 2, 52 ],
                    45: [ 2, 52 ]
                }, {
                    22: [ 1, 80 ]
                }, {
                    8: 19,
                    9: 5,
                    10: [ 1, 10 ],
                    12: 6,
                    14: 7,
                    15: 8,
                    16: 9,
                    17: [ 1, 11 ],
                    18: [ 1, 12 ],
                    21: [ 1, 14 ],
                    23: [ 1, 13 ],
                    24: [ 2, 4 ],
                    26: [ 1, 15 ],
                    27: [ 1, 16 ],
                    29: [ 1, 17 ]
                }, {
                    20: [ 2, 27 ],
                    22: [ 2, 27 ],
                    28: [ 2, 27 ],
                    41: [ 2, 27 ]
                }, {
                    20: [ 2, 49 ],
                    22: [ 2, 49 ],
                    28: [ 2, 49 ],
                    37: [ 2, 49 ],
                    38: [ 2, 49 ],
                    39: [ 2, 49 ],
                    40: [ 2, 49 ],
                    41: [ 2, 49 ],
                    45: [ 2, 49 ],
                    47: [ 2, 49 ]
                }, {
                    20: [ 2, 51 ],
                    22: [ 2, 51 ],
                    28: [ 2, 51 ],
                    41: [ 2, 51 ]
                }, {
                    20: [ 2, 42 ],
                    22: [ 2, 42 ],
                    28: [ 2, 42 ],
                    37: [ 2, 42 ],
                    38: [ 2, 42 ],
                    39: [ 2, 42 ],
                    40: [ 2, 42 ],
                    41: [ 2, 42 ],
                    45: [ 2, 42 ],
                    47: [ 2, 42 ],
                    49: [ 2, 42 ]
                }, {
                    22: [ 1, 81 ]
                }, {
                    22: [ 2, 45 ]
                }, {
                    46: [ 1, 79 ]
                }, {
                    5: [ 2, 25 ],
                    10: [ 2, 25 ],
                    17: [ 2, 25 ],
                    18: [ 2, 25 ],
                    21: [ 2, 25 ],
                    23: [ 2, 25 ],
                    24: [ 2, 25 ],
                    26: [ 2, 25 ],
                    27: [ 2, 25 ],
                    29: [ 2, 25 ]
                }, {
                    41: [ 1, 82 ]
                }, {
                    20: [ 2, 53 ],
                    22: [ 2, 53 ],
                    28: [ 2, 53 ],
                    41: [ 2, 53 ],
                    45: [ 2, 53 ]
                }, {
                    25: 57,
                    31: 83,
                    36: 61,
                    37: [ 1, 58 ],
                    38: [ 1, 59 ],
                    39: [ 1, 60 ],
                    40: [ 1, 62 ],
                    45: [ 1, 31 ],
                    47: [ 1, 30 ],
                    48: 29
                }, {
                    5: [ 2, 21 ],
                    10: [ 2, 21 ],
                    17: [ 2, 21 ],
                    18: [ 2, 21 ],
                    21: [ 2, 21 ],
                    23: [ 2, 21 ],
                    24: [ 2, 21 ],
                    26: [ 2, 21 ],
                    27: [ 2, 21 ],
                    29: [ 2, 21 ]
                }, {
                    5: [ 2, 24 ],
                    10: [ 2, 24 ],
                    17: [ 2, 24 ],
                    18: [ 2, 24 ],
                    21: [ 2, 24 ],
                    23: [ 2, 24 ],
                    24: [ 2, 24 ],
                    26: [ 2, 24 ],
                    27: [ 2, 24 ],
                    29: [ 2, 24 ]
                }, {
                    20: [ 2, 34 ],
                    22: [ 2, 34 ],
                    28: [ 2, 34 ],
                    37: [ 2, 34 ],
                    38: [ 2, 34 ],
                    39: [ 2, 34 ],
                    40: [ 2, 34 ],
                    41: [ 2, 34 ],
                    45: [ 2, 34 ],
                    47: [ 2, 34 ]
                }, {
                    20: [ 2, 36 ],
                    22: [ 2, 36 ],
                    28: [ 2, 36 ],
                    41: [ 2, 36 ],
                    45: [ 2, 36 ]
                } ],
                defaultActions: {
                    3: [ 2, 2 ],
                    18: [ 2, 1 ],
                    47: [ 2, 18 ],
                    63: [ 2, 47 ],
                    74: [ 2, 45 ]
                },
                parseError: function parseError(str, hash) {
                    throw new Error(str);
                },
                parse: function parse(input) {
                    var self = this, stack = [ 0 ], vstack = [ null ], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
                    this.lexer.setInput(input);
                    this.lexer.yy = this.yy;
                    this.yy.lexer = this.lexer;
                    this.yy.parser = this;
                    if (typeof this.lexer.yylloc == "undefined") this.lexer.yylloc = {};
                    var yyloc = this.lexer.yylloc;
                    lstack.push(yyloc);
                    var ranges = this.lexer.options && this.lexer.options.ranges;
                    if (typeof this.yy.parseError === "function") this.parseError = this.yy.parseError;
                    function popStack(n) {
                        stack.length = stack.length - 2 * n;
                        vstack.length = vstack.length - n;
                        lstack.length = lstack.length - n;
                    }
                    function lex() {
                        var token;
                        token = self.lexer.lex() || 1;
                        if (typeof token !== "number") {
                            token = self.symbols_[token] || token;
                        }
                        return token;
                    }
                    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
                    while (true) {
                        state = stack[stack.length - 1];
                        if (this.defaultActions[state]) {
                            action = this.defaultActions[state];
                        } else {
                            if (symbol === null || typeof symbol == "undefined") {
                                symbol = lex();
                            }
                            action = table[state] && table[state][symbol];
                        }
                        if (typeof action === "undefined" || !action.length || !action[0]) {
                            var errStr = "";
                            if (!recovering) {
                                expected = [];
                                for (p in table[state]) if (this.terminals_[p] && p > 2) {
                                    expected.push("'" + this.terminals_[p] + "'");
                                }
                                if (this.lexer.showPosition) {
                                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                                } else {
                                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                                }
                                this.parseError(errStr, {
                                    text: this.lexer.match,
                                    token: this.terminals_[symbol] || symbol,
                                    line: this.lexer.yylineno,
                                    loc: yyloc,
                                    expected: expected
                                });
                            }
                        }
                        if (action[0] instanceof Array && action.length > 1) {
                            throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
                        }
                        switch (action[0]) {
                          case 1:
                            stack.push(symbol);
                            vstack.push(this.lexer.yytext);
                            lstack.push(this.lexer.yylloc);
                            stack.push(action[1]);
                            symbol = null;
                            if (!preErrorSymbol) {
                                yyleng = this.lexer.yyleng;
                                yytext = this.lexer.yytext;
                                yylineno = this.lexer.yylineno;
                                yyloc = this.lexer.yylloc;
                                if (recovering > 0) recovering--;
                            } else {
                                symbol = preErrorSymbol;
                                preErrorSymbol = null;
                            }
                            break;

                          case 2:
                            len = this.productions_[action[1]][1];
                            yyval.$ = vstack[vstack.length - len];
                            yyval._$ = {
                                first_line: lstack[lstack.length - (len || 1)].first_line,
                                last_line: lstack[lstack.length - 1].last_line,
                                first_column: lstack[lstack.length - (len || 1)].first_column,
                                last_column: lstack[lstack.length - 1].last_column
                            };
                            if (ranges) {
                                yyval._$.range = [ lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1] ];
                            }
                            r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                            if (typeof r !== "undefined") {
                                return r;
                            }
                            if (len) {
                                stack = stack.slice(0, -1 * len * 2);
                                vstack = vstack.slice(0, -1 * len);
                                lstack = lstack.slice(0, -1 * len);
                            }
                            stack.push(this.productions_[action[1]][0]);
                            vstack.push(yyval.$);
                            lstack.push(yyval._$);
                            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                            stack.push(newState);
                            break;

                          case 3:
                            return true;
                        }
                    }
                    return true;
                }
            };
            function stripFlags(open, close) {
                return {
                    left: open.charAt(2) === "~",
                    right: close.charAt(0) === "~" || close.charAt(1) === "~"
                };
            }
            var lexer = function() {
                var lexer = {
                    EOF: 1,
                    parseError: function parseError(str, hash) {
                        if (this.yy.parser) {
                            this.yy.parser.parseError(str, hash);
                        } else {
                            throw new Error(str);
                        }
                    },
                    setInput: function(input) {
                        this._input = input;
                        this._more = this._less = this.done = false;
                        this.yylineno = this.yyleng = 0;
                        this.yytext = this.matched = this.match = "";
                        this.conditionStack = [ "INITIAL" ];
                        this.yylloc = {
                            first_line: 1,
                            first_column: 0,
                            last_line: 1,
                            last_column: 0
                        };
                        if (this.options.ranges) this.yylloc.range = [ 0, 0 ];
                        this.offset = 0;
                        return this;
                    },
                    input: function() {
                        var ch = this._input[0];
                        this.yytext += ch;
                        this.yyleng++;
                        this.offset++;
                        this.match += ch;
                        this.matched += ch;
                        var lines = ch.match(/(?:\r\n?|\n).*/g);
                        if (lines) {
                            this.yylineno++;
                            this.yylloc.last_line++;
                        } else {
                            this.yylloc.last_column++;
                        }
                        if (this.options.ranges) this.yylloc.range[1]++;
                        this._input = this._input.slice(1);
                        return ch;
                    },
                    unput: function(ch) {
                        var len = ch.length;
                        var lines = ch.split(/(?:\r\n?|\n)/g);
                        this._input = ch + this._input;
                        this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                        this.offset -= len;
                        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                        this.match = this.match.substr(0, this.match.length - 1);
                        this.matched = this.matched.substr(0, this.matched.length - 1);
                        if (lines.length - 1) this.yylineno -= lines.length - 1;
                        var r = this.yylloc.range;
                        this.yylloc = {
                            first_line: this.yylloc.first_line,
                            last_line: this.yylineno + 1,
                            first_column: this.yylloc.first_column,
                            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                        };
                        if (this.options.ranges) {
                            this.yylloc.range = [ r[0], r[0] + this.yyleng - len ];
                        }
                        return this;
                    },
                    more: function() {
                        this._more = true;
                        return this;
                    },
                    less: function(n) {
                        this.unput(this.match.slice(n));
                    },
                    pastInput: function() {
                        var past = this.matched.substr(0, this.matched.length - this.match.length);
                        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
                    },
                    upcomingInput: function() {
                        var next = this.match;
                        if (next.length < 20) {
                            next += this._input.substr(0, 20 - next.length);
                        }
                        return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
                    },
                    showPosition: function() {
                        var pre = this.pastInput();
                        var c = new Array(pre.length + 1).join("-");
                        return pre + this.upcomingInput() + "\n" + c + "^";
                    },
                    next: function() {
                        if (this.done) {
                            return this.EOF;
                        }
                        if (!this._input) this.done = true;
                        var token, match, tempMatch, index, col, lines;
                        if (!this._more) {
                            this.yytext = "";
                            this.match = "";
                        }
                        var rules = this._currentRules();
                        for (var i = 0; i < rules.length; i++) {
                            tempMatch = this._input.match(this.rules[rules[i]]);
                            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                                match = tempMatch;
                                index = i;
                                if (!this.options.flex) break;
                            }
                        }
                        if (match) {
                            lines = match[0].match(/(?:\r\n?|\n).*/g);
                            if (lines) this.yylineno += lines.length;
                            this.yylloc = {
                                first_line: this.yylloc.last_line,
                                last_line: this.yylineno + 1,
                                first_column: this.yylloc.last_column,
                                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                            };
                            this.yytext += match[0];
                            this.match += match[0];
                            this.matches = match;
                            this.yyleng = this.yytext.length;
                            if (this.options.ranges) {
                                this.yylloc.range = [ this.offset, this.offset += this.yyleng ];
                            }
                            this._more = false;
                            this._input = this._input.slice(match[0].length);
                            this.matched += match[0];
                            token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                            if (this.done && this._input) this.done = false;
                            if (token) return token; else return;
                        }
                        if (this._input === "") {
                            return this.EOF;
                        } else {
                            return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                                text: "",
                                token: null,
                                line: this.yylineno
                            });
                        }
                    },
                    lex: function lex() {
                        var r = this.next();
                        if (typeof r !== "undefined") {
                            return r;
                        } else {
                            return this.lex();
                        }
                    },
                    begin: function begin(condition) {
                        this.conditionStack.push(condition);
                    },
                    popState: function popState() {
                        return this.conditionStack.pop();
                    },
                    _currentRules: function _currentRules() {
                        return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
                    },
                    topState: function() {
                        return this.conditionStack[this.conditionStack.length - 2];
                    },
                    pushState: function begin(condition) {
                        this.begin(condition);
                    }
                };
                lexer.options = {};
                lexer.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
                    function strip(start, end) {
                        return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng - end);
                    }
                    var YYSTATE = YY_START;
                    switch ($avoiding_name_collisions) {
                      case 0:
                        if (yy_.yytext.slice(-2) === "\\\\") {
                            strip(0, 1);
                            this.begin("mu");
                        } else if (yy_.yytext.slice(-1) === "\\") {
                            strip(0, 1);
                            this.begin("emu");
                        } else {
                            this.begin("mu");
                        }
                        if (yy_.yytext) return 10;
                        break;

                      case 1:
                        return 10;
                        break;

                      case 2:
                        this.popState();
                        return 10;
                        break;

                      case 3:
                        yy_.yytext = yy_.yytext.substr(5, yy_.yyleng - 9);
                        this.popState();
                        return 11;
                        break;

                      case 4:
                        return 10;
                        break;

                      case 5:
                        strip(0, 4);
                        this.popState();
                        return 17;
                        break;

                      case 6:
                        return 40;
                        break;

                      case 7:
                        return 41;
                        break;

                      case 8:
                        return 18;
                        break;

                      case 9:
                        this.popState();
                        this.begin("raw");
                        return 20;
                        break;

                      case 10:
                        yy_.yytext = yy_.yytext.substr(4, yy_.yyleng - 8);
                        this.popState();
                        return "RAW_BLOCK";
                        break;

                      case 11:
                        return 29;
                        break;

                      case 12:
                        return 21;
                        break;

                      case 13:
                        return 24;
                        break;

                      case 14:
                        return 23;
                        break;

                      case 15:
                        return 23;
                        break;

                      case 16:
                        return 27;
                        break;

                      case 17:
                        return 26;
                        break;

                      case 18:
                        this.popState();
                        this.begin("com");
                        break;

                      case 19:
                        strip(3, 5);
                        this.popState();
                        return 17;
                        break;

                      case 20:
                        return 26;
                        break;

                      case 21:
                        return 46;
                        break;

                      case 22:
                        return 45;
                        break;

                      case 23:
                        return 45;
                        break;

                      case 24:
                        return 49;
                        break;

                      case 25:
                        break;

                      case 26:
                        this.popState();
                        return 28;
                        break;

                      case 27:
                        this.popState();
                        return 22;
                        break;

                      case 28:
                        yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                        return 37;
                        break;

                      case 29:
                        yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                        return 37;
                        break;

                      case 30:
                        return 47;
                        break;

                      case 31:
                        return 39;
                        break;

                      case 32:
                        return 39;
                        break;

                      case 33:
                        return 38;
                        break;

                      case 34:
                        return 45;
                        break;

                      case 35:
                        yy_.yytext = strip(1, 2);
                        return 45;
                        break;

                      case 36:
                        return "INVALID";
                        break;

                      case 37:
                        return 5;
                        break;
                    }
                };
                lexer.rules = [ /^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]*?(?=(\{\{\{\{\/)))/, /^(?:[\s\S]*?--\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{\{\{[^\x00]*\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{!--)/, /^(?:\{\{![\s\S]*?\}\})/, /^(?:\{\{(~)?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)]))))/, /^(?:\[[^\]]*\])/, /^(?:.)/, /^(?:$)/ ];
                lexer.conditions = {
                    mu: {
                        rules: [ 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37 ],
                        inclusive: false
                    },
                    emu: {
                        rules: [ 2 ],
                        inclusive: false
                    },
                    com: {
                        rules: [ 5 ],
                        inclusive: false
                    },
                    raw: {
                        rules: [ 3, 4 ],
                        inclusive: false
                    },
                    INITIAL: {
                        rules: [ 0, 1, 37 ],
                        inclusive: true
                    }
                };
                return lexer;
            }();
            parser.lexer = lexer;
            function Parser() {
                this.yy = {};
            }
            Parser.prototype = parser;
            parser.Parser = Parser;
            return new Parser();
        }();
        exports["default"] = handlebars;
    }, {} ],
    11: [ function(require, module, exports) {
        "use strict";
        var Visitor = require("./visitor")["default"];
        function print(ast) {
            return new PrintVisitor().accept(ast);
        }
        exports.print = print;
        function PrintVisitor() {
            this.padding = 0;
        }
        exports.PrintVisitor = PrintVisitor;
        PrintVisitor.prototype = new Visitor();
        PrintVisitor.prototype.pad = function(string, newline) {
            var out = "";
            for (var i = 0, l = this.padding; i < l; i++) {
                out = out + "  ";
            }
            out = out + string;
            if (newline !== false) {
                out = out + "\n";
            }
            return out;
        };
        PrintVisitor.prototype.program = function(program) {
            var out = "", statements = program.statements, i, l;
            for (i = 0, l = statements.length; i < l; i++) {
                out = out + this.accept(statements[i]);
            }
            this.padding--;
            return out;
        };
        PrintVisitor.prototype.block = function(block) {
            var out = "";
            out = out + this.pad("BLOCK:");
            this.padding++;
            out = out + this.accept(block.mustache);
            if (block.program) {
                out = out + this.pad("PROGRAM:");
                this.padding++;
                out = out + this.accept(block.program);
                this.padding--;
            }
            if (block.inverse) {
                if (block.program) {
                    this.padding++;
                }
                out = out + this.pad("{{^}}");
                this.padding++;
                out = out + this.accept(block.inverse);
                this.padding--;
                if (block.program) {
                    this.padding--;
                }
            }
            this.padding--;
            return out;
        };
        PrintVisitor.prototype.sexpr = function(sexpr) {
            var params = sexpr.params, paramStrings = [], hash;
            for (var i = 0, l = params.length; i < l; i++) {
                paramStrings.push(this.accept(params[i]));
            }
            params = "[" + paramStrings.join(", ") + "]";
            hash = sexpr.hash ? " " + this.accept(sexpr.hash) : "";
            return this.accept(sexpr.id) + " " + params + hash;
        };
        PrintVisitor.prototype.mustache = function(mustache) {
            return this.pad("{{ " + this.accept(mustache.sexpr) + " }}");
        };
        PrintVisitor.prototype.partial = function(partial) {
            var content = this.accept(partial.partialName);
            if (partial.context) {
                content += " " + this.accept(partial.context);
            }
            if (partial.hash) {
                content += " " + this.accept(partial.hash);
            }
            return this.pad("{{> " + content + " }}");
        };
        PrintVisitor.prototype.hash = function(hash) {
            var pairs = hash.pairs;
            var joinedPairs = [], left, right;
            for (var i = 0, l = pairs.length; i < l; i++) {
                left = pairs[i][0];
                right = this.accept(pairs[i][1]);
                joinedPairs.push(left + "=" + right);
            }
            return "HASH{" + joinedPairs.join(", ") + "}";
        };
        PrintVisitor.prototype.STRING = function(string) {
            return '"' + string.string + '"';
        };
        PrintVisitor.prototype.NUMBER = function(number) {
            return "NUMBER{" + number.number + "}";
        };
        PrintVisitor.prototype.BOOLEAN = function(bool) {
            return "BOOLEAN{" + bool.bool + "}";
        };
        PrintVisitor.prototype.ID = function(id) {
            var path = id.parts.join("/");
            if (id.parts.length > 1) {
                return "PATH:" + path;
            } else {
                return "ID:" + path;
            }
        };
        PrintVisitor.prototype.PARTIAL_NAME = function(partialName) {
            return "PARTIAL:" + partialName.name;
        };
        PrintVisitor.prototype.DATA = function(data) {
            return "@" + this.accept(data.id);
        };
        PrintVisitor.prototype.content = function(content) {
            return this.pad("CONTENT[ '" + content.string + "' ]");
        };
        PrintVisitor.prototype.comment = function(comment) {
            return this.pad("{{! '" + comment.comment + "' }}");
        };
    }, {
        "./visitor": 12
    } ],
    12: [ function(require, module, exports) {
        "use strict";
        function Visitor() {}
        Visitor.prototype = {
            constructor: Visitor,
            accept: function(object) {
                return this[object.type](object);
            }
        };
        exports["default"] = Visitor;
    }, {} ],
    13: [ function(require, module, exports) {
        "use strict";
        var errorProps = [ "description", "fileName", "lineNumber", "message", "name", "number", "stack" ];
        function Exception(message, node) {
            var line;
            if (node && node.firstLine) {
                line = node.firstLine;
                message += " - " + line + ":" + node.firstColumn;
            }
            var tmp = Error.prototype.constructor.call(this, message);
            for (var idx = 0; idx < errorProps.length; idx++) {
                this[errorProps[idx]] = tmp[errorProps[idx]];
            }
            if (line) {
                this.lineNumber = line;
                this.column = node.firstColumn;
            }
        }
        Exception.prototype = new Error();
        exports["default"] = Exception;
    }, {} ],
    14: [ function(require, module, exports) {
        "use strict";
        var Utils = require("./utils");
        var Exception = require("./exception")["default"];
        var COMPILER_REVISION = require("./base").COMPILER_REVISION;
        var REVISION_CHANGES = require("./base").REVISION_CHANGES;
        var createFrame = require("./base").createFrame;
        function checkRevision(compilerInfo) {
            var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = COMPILER_REVISION;
            if (compilerRevision !== currentRevision) {
                if (compilerRevision < currentRevision) {
                    var runtimeVersions = REVISION_CHANGES[currentRevision], compilerVersions = REVISION_CHANGES[compilerRevision];
                    throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. " + "Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
                } else {
                    throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. " + "Please update your runtime to a newer version (" + compilerInfo[1] + ").");
                }
            }
        }
        exports.checkRevision = checkRevision;
        function template(templateSpec, env) {
            if (!env) {
                throw new Exception("No environment passed to template");
            }
            env.VM.checkRevision(templateSpec.compiler);
            var invokePartialWrapper = function(partial, name, context, hash, helpers, partials, data) {
                if (hash) {
                    context = Utils.extend({}, context, hash);
                }
                var result = env.VM.invokePartial.call(this, partial, name, context, helpers, partials, data);
                if (result != null) {
                    return result;
                }
                if (env.compile) {
                    var options = {
                        helpers: helpers,
                        partials: partials,
                        data: data
                    };
                    partials[name] = env.compile(partial, {
                        data: data !== undefined
                    }, env);
                    return partials[name](context, options);
                } else {
                    throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
                }
            };
            var container = {
                escapeExpression: Utils.escapeExpression,
                invokePartial: invokePartialWrapper,
                fn: function(i) {
                    return templateSpec[i];
                },
                programs: [],
                program: function(i, data) {
                    var programWrapper = this.programs[i], fn = this.fn(i);
                    if (data) {
                        programWrapper = program(this, i, fn, data);
                    } else if (!programWrapper) {
                        programWrapper = this.programs[i] = program(this, i, fn);
                    }
                    return programWrapper;
                },
                programWithDepth: env.VM.programWithDepth,
                data: function(data, depth) {
                    while (data && depth--) {
                        data = data._parent;
                    }
                    return data;
                },
                merge: function(param, common) {
                    var ret = param || common;
                    if (param && common && param !== common) {
                        ret = Utils.extend({}, common, param);
                    }
                    return ret;
                },
                noop: env.VM.noop,
                compilerInfo: templateSpec.compiler
            };
            var ret = function(context, options) {
                options = options || {};
                var helpers, partials, data = options.data;
                ret._setup(options);
                if (!options.partial && templateSpec.useData) {
                    data = initData(context, data);
                }
                return templateSpec.main.call(container, context, container.helpers, container.partials, data);
            };
            ret._setup = function(options) {
                if (!options.partial) {
                    container.helpers = container.merge(options.helpers, env.helpers);
                    if (templateSpec.usePartial) {
                        container.partials = container.merge(options.partials, env.partials);
                    }
                } else {
                    container.helpers = options.helpers;
                    container.partials = options.partials;
                }
            };
            ret._child = function(i) {
                return container.programWithDepth(i);
            };
            return ret;
        }
        exports.template = template;
        function programWithDepth(i, data) {
            var args = Array.prototype.slice.call(arguments, 2), container = this, fn = container.fn(i);
            var prog = function(context, options) {
                options = options || {};
                return fn.apply(container, [ context, container.helpers, container.partials, options.data || data ].concat(args));
            };
            prog.program = i;
            prog.depth = args.length;
            return prog;
        }
        exports.programWithDepth = programWithDepth;
        function program(container, i, fn, data) {
            var prog = function(context, options) {
                options = options || {};
                return fn.call(container, context, container.helpers, container.partials, options.data || data);
            };
            prog.program = i;
            prog.depth = 0;
            return prog;
        }
        exports.program = program;
        function invokePartial(partial, name, context, helpers, partials, data) {
            var options = {
                partial: true,
                helpers: helpers,
                partials: partials,
                data: data
            };
            if (partial === undefined) {
                throw new Exception("The partial " + name + " could not be found");
            } else if (partial instanceof Function) {
                return partial(context, options);
            }
        }
        exports.invokePartial = invokePartial;
        function noop() {
            return "";
        }
        exports.noop = noop;
        function initData(context, data) {
            if (!data || !("root" in data)) {
                data = data ? createFrame(data) : {};
                data.root = context;
            }
            return data;
        }
    }, {
        "./base": 5,
        "./exception": 13,
        "./utils": 16
    } ],
    15: [ function(require, module, exports) {
        "use strict";
        function SafeString(string) {
            this.string = string;
        }
        SafeString.prototype.toString = function() {
            return "" + this.string;
        };
        exports["default"] = SafeString;
    }, {} ],
    16: [ function(require, module, exports) {
        "use strict";
        var SafeString = require("./safe-string")["default"];
        var escape = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
        };
        var badChars = /[&<>"'`]/g;
        var possible = /[&<>"'`]/;
        function escapeChar(chr) {
            return escape[chr] || "&amp;";
        }
        function extend(obj) {
            for (var i = 1; i < arguments.length; i++) {
                for (var key in arguments[i]) {
                    if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                        obj[key] = arguments[i][key];
                    }
                }
            }
            return obj;
        }
        exports.extend = extend;
        var toString = Object.prototype.toString;
        exports.toString = toString;
        var isFunction = function(value) {
            return typeof value === "function";
        };
        if (isFunction(/x/)) {
            isFunction = function(value) {
                return typeof value === "function" && toString.call(value) === "[object Function]";
            };
        }
        var isFunction;
        exports.isFunction = isFunction;
        var isArray = Array.isArray || function(value) {
            return value && typeof value === "object" ? toString.call(value) === "[object Array]" : false;
        };
        exports.isArray = isArray;
        function escapeExpression(string) {
            if (string instanceof SafeString) {
                return string.toString();
            } else if (!string && string !== 0) {
                return "";
            }
            string = "" + string;
            if (!possible.test(string)) {
                return string;
            }
            return string.replace(badChars, escapeChar);
        }
        exports.escapeExpression = escapeExpression;
        function isEmpty(value) {
            if (!value && value !== 0) {
                return true;
            } else if (isArray(value) && value.length === 0) {
                return true;
            } else {
                return false;
            }
        }
        exports.isEmpty = isEmpty;
        function appendContextPath(contextPath, id) {
            return (contextPath ? contextPath + "." : "") + id;
        }
        exports.appendContextPath = appendContextPath;
    }, {
        "./safe-string": 15
    } ],
    17: [ function(require, module, exports) {
        var handlebars = require("../dist/cjs/handlebars")["default"];
        handlebars.Visitor = require("../dist/cjs/handlebars/compiler/visitor")["default"];
        var printer = require("../dist/cjs/handlebars/compiler/printer");
        handlebars.PrintVisitor = printer.PrintVisitor;
        handlebars.print = printer.print;
        module.exports = handlebars;
        if (typeof require !== "undefined" && require.extensions) {
            var extension = function(module, filename) {
                var fs = require("fs");
                var templateString = fs.readFileSync(filename, "utf8");
                module.exports = handlebars.compile(templateString);
            };
            require.extensions[".handlebars"] = extension;
            require.extensions[".hbs"] = extension;
        }
    }, {
        "../dist/cjs/handlebars": 3,
        "../dist/cjs/handlebars/compiler/printer": 11,
        "../dist/cjs/handlebars/compiler/visitor": 12,
        fs: 1
    } ],
    18: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var undefined;
                var arrayPool = [], objectPool = [];
                var idCounter = 0;
                var keyPrefix = +new Date() + "";
                var largeArraySize = 75;
                var maxPoolSize = 40;
                var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reFuncName = /^\s*function[ \n\r\t]+\w/;
                var reInterpolate = /<%=([\s\S]+?)%>/g;
                var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
                var reNoMatch = /($^)/;
                var reThis = /\bthis\b/;
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
                var contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
                var templateCounter = 0;
                var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
                var debounceOptions = {
                    leading: false,
                    maxWait: 0,
                    trailing: false
                };
                var descriptor = {
                    configurable: false,
                    enumerable: false,
                    value: null,
                    writable: false
                };
                var objectTypes = {
                    "boolean": false,
                    "function": true,
                    object: true,
                    number: false,
                    string: false,
                    undefined: false
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "	": "t",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var root = objectTypes[typeof window] && window || this;
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;
                    if (type == "boolean" || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != "number" && type != "string") {
                        type = "object";
                    }
                    var key = type == "number" ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];
                    return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
                }
                function cachePush(value) {
                    var cache = this.cache, type = typeof value;
                    if (type == "boolean" || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != "number" && type != "string") {
                            type = "object";
                        }
                        var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                        if (type == "object") {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }
                function compareAscending(a, b) {
                    var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
                    while (++index < length) {
                        var value = ac[index], other = bc[index];
                        if (value !== other) {
                            if (value > other || typeof value == "undefined") {
                                return 1;
                            }
                            if (value < other || typeof other == "undefined") {
                                return -1;
                            }
                        }
                    }
                    return a.index - b.index;
                }
                function createCache(array) {
                    var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
                    if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
                        return false;
                    }
                    var cache = getObject();
                    cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;
                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }
                function escapeStringChar(match) {
                    return "\\" + stringEscapes[match];
                }
                function getArray() {
                    return arrayPool.pop() || [];
                }
                function getObject() {
                    return objectPool.pop() || {
                        array: null,
                        cache: null,
                        criteria: null,
                        "false": false,
                        index: 0,
                        "null": false,
                        number: null,
                        object: null,
                        push: null,
                        string: null,
                        "true": false,
                        undefined: false,
                        value: null
                    };
                }
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == "undefined") {
                        end = array ? array.length : 0;
                    }
                    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }
                function runInContext(context) {
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayRef = [];
                    var objectProto = Object.prototype;
                    var oldDash = context._;
                    var toString = objectProto.toString;
                    var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
                    var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
                    var defineProperty = function() {
                        try {
                            var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }();
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;
                    function lodash(value) {
                        return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
                    }
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    lodashWrapper.prototype = lodash.prototype;
                    var support = lodash.support = {};
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
                    support.funcNames = typeof Function.name == "string";
                    lodash.templateSettings = {
                        escape: /<%-([\s\S]+?)%>/g,
                        evaluate: /<%([\s\S]+?)%>/g,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    function baseBind(bindData) {
                        var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
                        function bound() {
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (this instanceof bound) {
                                var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != "undefined") {
                                return result;
                            }
                        }
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                              case boolClass:
                              case dateClass:
                                return new ctor(+value);

                              case numberClass:
                              case stringClass:
                                return new ctor(value);

                              case regexpClass:
                                result = ctor(value.source, reFlags.exec(value));
                                result.lastIndex = value.lastIndex;
                                return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());
                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        if (isArr) {
                            if (hasOwnProperty.call(value, "index")) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, "input")) {
                                result.input = value.input;
                            }
                        }
                        if (!isDeep) {
                            return result;
                        }
                        stackA.push(value);
                        stackB.push(result);
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    if (!nativeCreate) {
                        baseCreate = function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object();
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }();
                    }
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != "function") {
                            return identity;
                        }
                        if (typeof thisArg == "undefined" || !("prototype" in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == "undefined") {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        if (bindData === false || bindData !== true && bindData[1] & 1) {
                            return func;
                        }
                        switch (argCount) {
                          case 1:
                            return function(value) {
                                return func.call(thisArg, value);
                            };

                          case 2:
                            return function(a, b) {
                                return func.call(thisArg, a, b);
                            };

                          case 3:
                            return function(value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                          case 4:
                            return function(accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };
                        }
                        return bind(func, thisArg);
                    }
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseDifference(array, values) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1, valLength = value.length, resIndex = result.length;
                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != "undefined") {
                                return !!result;
                            }
                        }
                        if (a === b) {
                            return a !== 0 || 1 / a == 1 / b;
                        }
                        var type = typeof a, otherType = typeof b;
                        if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                            return false;
                        }
                        if (a == null || b == null) {
                            return a === b;
                        }
                        var className = toString.call(a), otherClass = toString.call(b);
                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                          case boolClass:
                          case dateClass:
                            return +a == +b;

                          case numberClass:
                            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

                          case regexpClass:
                          case stringClass:
                            return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            if (className != objectClass) {
                                return false;
                            }
                            var ctorA = a.constructor, ctorB = b.constructor;
                            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                                return false;
                            }
                        }
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;
                        stackA.push(a);
                        stackB.push(b);
                        if (isArr) {
                            length = a.length;
                            size = b.length;
                            result = size == length;
                            if (result || isWhere) {
                                while (size--) {
                                    var index = length, value = b[size];
                                    if (isWhere) {
                                        while (index--) {
                                            if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    size++;
                                    return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                                }
                            });
                            if (result && !isWhere) {
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        return result = --size > -1;
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found, isArr, result = source, value = object[key];
                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if (found = stackA[stackLength] == source) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if (isShallow = typeof result != "undefined") {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                    }
                                    stackA.push(source);
                                    stackB.push(value);
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == "undefined") {
                                        result = source;
                                    }
                                }
                                if (typeof result != "undefined") {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }
                    function baseUniq(array, isSorted, callback) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index], computed = callback ? callback(value, index, array) : value;
                            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);
                            var index = -1, length = collection ? collection.length : 0;
                            if (typeof length == "number") {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError();
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
                        return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
                    }
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }
                    function isNative(value) {
                        return typeof value == "function" && reNative.test(value);
                    }
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, "__bindData__", descriptor);
                    };
                    function shimIsPlainObject(value) {
                        var ctor, result;
                        if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
                        isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == "undefined" || hasOwnProperty.call(value, result);
                    }
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }
                    function isArguments(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
                    }
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
                    };
                    var shimKeys = function(object) {
                        var index, iterable = object, result = [];
                        if (!iterable) return result;
                        if (!objectTypes[typeof object]) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result;
                    };
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };
                    var htmlEscapes = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    var htmlUnescapes = invert(htmlEscapes);
                    var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
                    var assign = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function clone(value, isDeep, callback, thisArg) {
                        if (typeof isDeep != "boolean" && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }
                    var defaults = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == "undefined") result[index] = iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];
                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });
                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object), length = props.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }
                    function invert(object) {
                        var index = -1, props = keys(object), length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }
                    function isBoolean(value) {
                        return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
                    }
                    function isDate(value) {
                        return value && typeof value == "object" && toString.call(value) == dateClass || false;
                    }
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value), length = value.length;
                        if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return result = false;
                        });
                        return result;
                    }
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
                    }
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }
                    function isFunction(value) {
                        return typeof value == "function";
                    }
                    function isObject(value) {
                        return !!(value && objectTypes[typeof value]);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
                    }
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                    };
                    function isRegExp(value) {
                        return value && typeof value == "object" && toString.call(value) == regexpClass || false;
                    }
                    function isString(value) {
                        return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
                    }
                    function isUndefined(value) {
                        return typeof value == "undefined";
                    }
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }
                    function merge(object) {
                        var args = arguments, length = 2;
                        if (!isObject(object)) {
                            return object;
                        }
                        if (typeof args[2] != "number") {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == "function") {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == "function") {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function pairs(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            var key = props[index];
                            result[index] = [ key, object[key] ];
                        }
                        return result;
                    }
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }
                    function values(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }
                    function at(collection) {
                        var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }
                    function contains(collection, target, fromIndex) {
                        var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == "number") {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                    });
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return result = !!callback(value, index, collection);
                            });
                        }
                        return result;
                    }
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }
                    function forEach(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }
                    function map(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    function min(collection, callback, thisArg) {
                        var computed = Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    var pluck = map;
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        var index = -1, length = collection.length;
                        if (typeof length == "number") {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                            });
                        }
                        return accumulator;
                    }
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != "number") {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }
                    function shuffle(collection) {
                        var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == "number" ? length : keys(collection).length;
                    }
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (result = callback(collection[index], index, collection)) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }
                    function sortBy(collection, callback, thisArg) {
                        var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });
                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }
                    function toArray(collection) {
                        if (collection && typeof collection.length == "number") {
                            return slice(collection);
                        }
                        return values(collection);
                    }
                    var where = filter;
                    function compact(array) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }
                    function findIndex(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function first(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }
                    function flatten(array, isShallow, callback, thisArg) {
                        if (typeof isShallow != "boolean" && isShallow != null) {
                            thisArg = callback;
                            callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == "number") {
                            var length = array ? array.length : 0;
                            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }
                    function initial(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }
                    function intersection() {
                        var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0], index = -1, length = array ? array.length : 0, result = [];
                        outer: while (++index < length) {
                            var cache = caches[0];
                            value = array[index];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                argsIndex = argsLength;
                                (cache || seen).push(value);
                                while (--argsIndex) {
                                    cache = caches[argsIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                        }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }
                    function last(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == "number") {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function pull(array) {
                        var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
                        while (++argsIndex < argsLength) {
                            var index = -1, value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == "number" ? step : +step || 1;
                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function remove(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }
                    function rest(array, callback, thisArg) {
                        if (typeof callback != "number" && callback != null) {
                            var n = 0, index = -1, length = array ? array.length : 0;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0, high = array ? array.length : low;
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);
                        while (low < high) {
                            var mid = low + high >>> 1;
                            callback(array[mid]) < value ? low = mid + 1 : high = mid;
                        }
                        return low;
                    }
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }
                    function uniq(array, isSorted, callback, thisArg) {
                        if (typeof isSorted != "boolean" && isSorted != null) {
                            thisArg = callback;
                            callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }
                    function xor() {
                        var index = -1, length = arguments.length;
                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                            }
                        }
                        return result || [];
                    }
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }
                    function zipObject(keys, values) {
                        var index = -1, length = keys ? keys.length : 0, result = {};
                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function bind(func, thisArg) {
                        return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
                    }
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }
                    function bindKey(object, key) {
                        return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
                    }
                    function compose() {
                        var funcs = arguments, length = funcs.length;
                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError();
                            }
                        }
                        return function() {
                            var args = arguments, length = funcs.length;
                            while (length--) {
                                args = [ funcs[length].apply(this, args) ];
                            }
                            return args[0];
                        };
                    }
                    function curry(func, arity) {
                        arity = typeof arity == "number" ? arity : +arity || func.length;
                        return createWrapper(func, 4, null, null, null, arity);
                    }
                    function debounce(func, wait, options) {
                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };
                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || maxWait !== wait) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };
                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);
                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var memoized = function() {
                            var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                        };
                        memoized.cache = {};
                        return memoized;
                    }
                    function once(func) {
                        var ran, result;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);
                            func = null;
                            return result;
                        };
                    }
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = "leading" in options ? options.leading : leading;
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;
                        return debounce(func, wait, debounceOptions);
                    }
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [ value ]);
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == "function") {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        if (type != "object") {
                            return property(func);
                        }
                        var props = keys(func), key = props[0], a = func[key];
                        if (props.length == 1 && a === a && !isObject(a)) {
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || 1 / a == 1 / b);
                            };
                        }
                        return function(object) {
                            var length = props.length, result = false;
                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }
                    function escape(string) {
                        return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }
                    function identity(value) {
                        return value;
                    }
                    function mixin(object, source, options) {
                        var chain = true, methodNames = source && functions(source);
                        if (!source || !options && !methodNames.length) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && "chain" in options) {
                            chain = options.chain;
                        }
                        var ctor = object, isFunc = isFunction(ctor);
                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }
                    function noop() {}
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };
                    var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
                    };
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }
                    function random(min, max, floating) {
                        var noMin = min == null, noMax = max == null;
                        if (floating == null) {
                            if (typeof min == "boolean" && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == "boolean") {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                        }
                        return baseRandom(min, max);
                    }
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }
                    function template(text, data, options) {
                        var settings = lodash.templateSettings;
                        text = String(text || "");
                        options = defaults({}, options, settings);
                        var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                        var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = options.variable, hasVariable = variable;
                        if (!hasVariable) {
                            variable = "obj";
                            source = "with (" + variable + ") {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
                        try {
                            var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        result.source = source;
                        return result;
                    }
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1, result = Array(n);
                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }
                    function unescape(string) {
                        return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? "" : prefix) + id;
                    }
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;
                    mixin(lodash);
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;
                    mixin(function() {
                        var source = {};
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;
                    lodash.take = first;
                    lodash.head = first;
                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== "sample";
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                                return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                            };
                        }
                    });
                    lodash.VERSION = "2.4.1";
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;
                    forEach([ "join", "pop", "shift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                            return chainAll ? new lodashWrapper(result, chainAll) : result;
                        };
                    });
                    forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });
                    forEach([ "concat", "slice", "splice" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });
                    return lodash;
                }
                var _ = runInContext();
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    root._ = _;
                    define(function() {
                        return _;
                    });
                } else if (freeExports && freeModule) {
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    } else {
                        freeExports._ = _;
                    }
                } else {
                    root._ = _;
                }
            }).call(this);
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    19: [ function(require, module, exports) {
        var bonzo, graphic, handlebars, _;
        _ = require("lodash");
        graphic = require("./ui-sparkline.svg");
        bonzo = require("bonzo");
        handlebars = require("handlebars");
        graphic = handlebars.compile(graphic);
        console.log("ui-sparkline");
        Polymer("ui-sparkline", {
            dataChanged: function() {
                var length, max, min, path, plot, range;
                if (typeof this.data === "string") {
                    this.data = _.map(this.data.split(" "), function(n) {
                        return Number(n);
                    });
                }
                length = this.data.length;
                min = _.min(this.data);
                max = _.max(this.data);
                range = max - min;
                plot = [];
                path = [];
                _.each(this.data, function(n, i, all) {
                    var x, y;
                    x = i / all.length;
                    y = (n - min) / range;
                    plot.push("" + x + "," + y);
                    if (i === 0) {
                        return path.push("M " + x + "," + y);
                    } else {
                        return path.push("L " + x + "," + y);
                    }
                });
                bonzo(this.shadowRoot.querySelector("svg")).remove();
                return bonzo(this.shadowRoot).append(graphic({
                    plot: plot.join(" "),
                    path: path.join(" "),
                    points: this.data.length
                }));
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {
        "./ui-sparkline.svg": 20,
        bonzo: 2,
        handlebars: 17,
        lodash: 18
    } ],
    20: [ function(require, module, exports) {
        module.exports = "<svg\n" + '  version="1.1" xmlns="http://www.w3.org/2000/svg"\n' + '  viewBox="0 0 1.1 1.1"\n' + '  preserveAspectRatio="none"\n' + '  xmlns:xlink="http://www.w3.org/1999/xlink">\n' + "  <defs>\n" + '    <linearGradient id="shade">\n' + '      <stop stop-opacity="0.7" offset="0"/>\n' + '      <stop stop-opacity="0.9" offset="90%"/>\n' + '      <stop stop-opacity="1.0" offset="100%"/>\n' + "    </linearGradient>\n" + "  </defs>\n" + '  <g transform="matrix(1 0 0 -1 0 1)">\n' + '    <polyline id="plot" viewBox="0 0 1 1" preserveAspectRatio="none" points="{{plot}}" stroke="url(#shade)"></polyline>\n' + "  </g>\n" + "</svg>\n" + "";
    }, {} ]
}, {}, [ 19 ]);</script>
</polymer-element>

<polymer-element name="ui-view" attributes="viewData title">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
container {
  display: block;
  max-width: 60em;
  margin-top: 0;
  margin-right: auto;
  margin-bottom: 0;
  margin-left: auto;
  overflow: visible;
}
box {
  padding: 1em;
  margin-top: 0.5em;
  margin-right: 0;
  margin-bottom: 1em;
  margin-left: 0;
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  display: block;
  border: 1px solid rgba(51, 51, 51, 0.1);
}
border,
.border {
  display: block;
  border: 1px solid rgba(51, 51, 51, 0.1);
}
background,
.background {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  background-color: rgba(51, 51, 51, 0.1);
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
[border] {
  border: 1px solid rgba(51, 51, 51, 0.1);
}
panel,
.panel {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
}
heading,
.heading {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  background-color: rgba(51, 51, 51, 0.1);
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
heading p,
.heading p,
heading h1,
.heading h1,
heading h2,
.heading h2,
heading h3,
.heading h3,
heading h4,
.heading h4,
heading h5,
.heading h5,
heading h6,
.heading h6,
heading ul,
.heading ul,
heading ol,
.heading ol,
heading dl,
.heading dl,
heading blockquote,
.heading blockquote {
  margin: 0;
}
well,
.well {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  padding: 1em;
}
[fullscreen],
[full],
.full {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
[fill],
.fill {
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
[leftdock] {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
}
:host {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  padding: 1em;
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
  transform-origin: 0 0;
  -webkit-transform-origin: 0 0;
  transform: rotate3d(0, 0, 0, 0) translate3d(110%, 0, 0);
  -webkit-transform: rotate3d(0, 0, 0, 0) translate3d(110%, 0, 0);
  overflow-y: scroll;
}
:host([current]) {
  transform: rotate3d(0, 0, 0, 0) translate3d(0, 0, 0);
  -webkit-transform: rotate3d(0, 0, 0, 0) translate3d(0, 0, 0);
}
:host([history]) {
  transform: rotate3d(0, 1, 0, 90deg) translate3d(-50%, 0, 0);
  -webkit-transform: rotate3d(0, 1, 0, 90deg) translate3d(-50%, 0, 0);
}
</style>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-navigation/node_modules/ui-view/src/ui-view.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-view", {
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-navigation" attributes="view views backView" on-click="{{navigate}}">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
container {
  display: block;
  max-width: 60em;
  margin-top: 0;
  margin-right: auto;
  margin-bottom: 0;
  margin-left: auto;
  overflow: visible;
}
box {
  padding: 1em;
  margin-top: 0.5em;
  margin-right: 0;
  margin-bottom: 1em;
  margin-left: 0;
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  display: block;
  border: 1px solid rgba(51, 51, 51, 0.1);
}
border,
.border {
  display: block;
  border: 1px solid rgba(51, 51, 51, 0.1);
}
background,
.background {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  background-color: rgba(51, 51, 51, 0.1);
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
[border] {
  border: 1px solid rgba(51, 51, 51, 0.1);
}
panel,
.panel {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
}
heading,
.heading {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  background-color: rgba(51, 51, 51, 0.1);
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
heading p,
.heading p,
heading h1,
.heading h1,
heading h2,
.heading h2,
heading h3,
.heading h3,
heading h4,
.heading h4,
heading h5,
.heading h5,
heading h6,
.heading h6,
heading ul,
.heading ul,
heading ol,
.heading ol,
heading dl,
.heading dl,
heading blockquote,
.heading blockquote {
  margin: 0;
}
well,
.well {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  padding: 1em;
}
[fullscreen],
[full],
.full {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
[fill],
.fill {
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
[leftdock] {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
}
[inverted] {
  color: #ffffff;
}
[inverted] hr,
[inverted] blockquote,
[inverted] abbr,
[inverted] li {
  color: #ffffff;
  border-color: rgba(255, 255, 255, 0.33);
}
html {
  font-style: normal;
  font-weight: 200;
  color: #454545;
  -webkit-font-smoothing: antialiased;
}
hr {
  border: 0;
  border-bottom: 1px solid rgba(51, 51, 51, 0.1);
}
a {
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
  padding-top: 0;
  padding-right: 0;
  padding-bottom: 0;
  padding-left: 0;
  background: transparent;
  vertical-align: baseline;
  font-style: normal;
  font-weight: normal;
  font-weight: 700;
  color: #ef272d;
  text-decoration: none;
  cursor: pointer;
}
a img {
  border: 0 none;
  text-decoration: none;
}
a:hover {
  color: #d31016;
}
h1 {
  font-size: 3rem;
  font-weight: 100;
}
h2 {
  font-size: 2.4rem;
  font-weight: 100;
}
h3 {
  font-size: 2.2rem;
  font-weight: 100;
}
h4 {
  font-size: 2rem;
  font-weight: 100;
}
h5 {
  font-size: 1.8rem;
  font-weight: 100;
}
h6 {
  font-size: 1.6rem;
  font-weight: 100;
}
small {
  display: inline-block;
  *zoom: 1;
  *display: inline;
}
p,
h1,
h2,
h3,
h4,
h5,
h6,
ul,
ol,
dl,
blockquote {
  line-height: 1.2em;
  letter-spacing: .035em;
  clear: inherit;
  margin-bottom: 0.33333em;
  margin-top: 0;
  vertical-align: middle;
  padding: 0;
}
p {
  word-wrap: break-word;
  font-weight: 200;
}
p:only-child {
  margin-top: 0;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
}
b {
  font-weight: 700;
}
blockquote {
  width: 75%;
  margin-top: 0;
  margin-right: auto;
  margin-bottom: 0;
  margin-left: auto;
  border-left: 3px solid rgba(51, 51, 51, 0.61);
  color: rgba(51, 51, 51, 0.61);
  font-style: italic;
  padding-left: 1em;
}
q {
  quotes: "\201C" "\201D" "\2018" "\2019";
}
abbr {
  border-bottom: 1px dotted rgba(51, 51, 51, 0.61);
  cursor: help;
}
address {
  font-style: normal;
}
mark {
  background: yellow;
}
pre {
  margin-top: 1em;
  margin-right: 0;
  margin-bottom: 0;
  margin-left: 0;
  -webkit-background-clip: padding-box;
  -moz-background-clip: padding-box;
  background-clip: padding-box;
  overflow: auto;
  padding: 1em;
  word-wrap: break-word;
}
ul {
  list-style: none;
}
li {
  padding-top: .25em;
  padding-bottom: .25em;
  border-bottom: 1px dotted rgba(51, 51, 51, 0.1);
}
li:last-child {
  border-bottom: 0;
}
input,
textarea {
  font-family: inherit;
  font-weight: inherit;
}
info {
  color: #0088cc;
  display: inline;
}
error {
  color: #9b0d10;
  display: inline;
}
success {
  color: #719a2e;
  display: inline;
}
:host {
  display: block;
  overflow: hidden;
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
:host nav {
  display: flex;
  justify-content: center;
  align-content: center;
  text-align: center;
  background-color: rgba(51, 51, 51, 0.1);
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  align-items: center;
}
:host nav p,
:host nav h1,
:host nav h2,
:host nav h3,
:host nav h4,
:host nav h5,
:host nav h6,
:host nav ul,
:host nav ol,
:host nav dl,
:host nav blockquote {
  margin: 0;
}
:host nav h6 {
  display: block;
  margin: 0;
  line-height: 2em;
}
:host nav h6[back] {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  margin: 0;
  width: auto;
  margin-left: 0.5em;
  line-height: 2em;
  transform-origin: 0 50%;
  -webkit-transform-origin: 0 50%;
  transform: scale3d(0.7, 0.7, 1);
  -webkit-transform: scale3d(0.7, 0.7, 1);
}
:host nav h6[back]:before {
  content: '\27e8';
}
:host #view {
  position: absolute;
  top: 3em;
  left: 0;
  right: 0;
  bottom: 0;
}
</style>
  <nav>
    <template if="{{backView}}">
      <info><h6 back="" on-click="{{pop}}">{{backView.title}}</h6></info>
    </template>
    <h6>{{view.title}}</h6>
  </nav>
  <section id="view">
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-navigation/src/ui-navigation.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-navigation", {
            push: function(idOrElement) {
                if (this.view) {
                    this.view.setAttribute("history", "");
                    this.backView = this.view;
                }
                if (idOrElement.tagName != null) {
                    this.view = idOrElement;
                } else {
                    this.view = this.querySelector(idOrElement);
                }
                this.views.push(this.view);
                return this.view.setAttribute("current", "");
            },
            pop: function() {
                if (this.views.length > 1) {
                    this.view.removeAttribute("current");
                    this.views.pop();
                    this.view = this.views[this.views.length - 1];
                    this.backView = this.views[this.views.length - 2];
                    return this.view.removeAttribute("history");
                }
            },
            navigate: function(evt) {
                var recurse;
                recurse = function(_this) {
                    return function(element) {
                        if (element) {
                            if (element.getAttribute("push-screen")) {
                                return _this.push(element.getAttribute("push-screen"));
                            } else {
                                return recurse(element.parentElement);
                            }
                        }
                    };
                }(this);
                return recurse(evt.target);
            },
            created: function() {
                this.view = void 0;
                return this.views = [];
            },
            ready: function() {},
            attached: function() {
                return this.push(this.querySelector("ui-view"));
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-sidebar" attributes="" inverted="">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
container {
  display: block;
  max-width: 60em;
  margin-top: 0;
  margin-right: auto;
  margin-bottom: 0;
  margin-left: auto;
  overflow: visible;
}
box {
  padding: 1em;
  margin-top: 0.5em;
  margin-right: 0;
  margin-bottom: 1em;
  margin-left: 0;
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  display: block;
  border: 1px solid rgba(51, 51, 51, 0.1);
}
border,
.border {
  display: block;
  border: 1px solid rgba(51, 51, 51, 0.1);
}
background,
.background {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  background-color: rgba(51, 51, 51, 0.1);
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
[border] {
  border: 1px solid rgba(51, 51, 51, 0.1);
}
panel,
.panel {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
}
heading,
.heading {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  background-color: rgba(51, 51, 51, 0.1);
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
heading p,
.heading p,
heading h1,
.heading h1,
heading h2,
.heading h2,
heading h3,
.heading h3,
heading h4,
.heading h4,
heading h5,
.heading h5,
heading h6,
.heading h6,
heading ul,
.heading ul,
heading ol,
.heading ol,
heading dl,
.heading dl,
heading blockquote,
.heading blockquote {
  margin: 0;
}
well,
.well {
  display: flex;
  justify-content: center;
  align-content: center;
  align-items: center;
  text-align: center;
  padding: 1em;
}
[fullscreen],
[full],
.full {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
[fill],
.fill {
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}
[leftdock] {
  position: fixed;
  top: 0;
  left: 0;
  bottom: 0;
}
:host {
  display: block;
  overflow: hidden;
}
:host #page {
  overflow: hidden;
  z-index: 1000;
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
  transform: translate3d(0, 0, 0px);
  -webkit-transform: translate3d(0, 0, 0px);
}
:host #sidebar {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
  padding: 1em;
  box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.61);
  -webkit-box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.61);
}
:host #hamburger {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
  z-index: 1;
  cursor: pointer;
  line-height: 2rem;
  width: 2rem;
  height: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.61);
  -webkit-box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.61);
}
:host #hamburger:before {
  font-size: 2rem;
  color: #ffffff;
  content: '\2261';
}
:host([no-hamburger]) #hamburger {
  display: none;
}
</style>
  <section id="page" leftdock="" layout="" horizontal="">
    <section id="sidebar">
      <section id="sizer">
        <content></content>
      </section>
    </section>
    <section id="hamburger" on-click="{{toggle}}"></section>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-sidebar/src/ui-sidebar.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        module.exports = function(element, callback) {
            function addResizeListener(element, callback) {
                if (window.OverflowEvent) {
                    element.addEventListener("overflowchanged", function(e) {
                        callback.call(this, e);
                    });
                } else {
                    element.addEventListener("overflow", function(e) {
                        callback.call(this, e);
                    });
                    element.addEventListener("underflow", function(e) {
                        callback.call(this, e);
                    });
                }
            }
            function EventQueue() {
                this.q = [];
                this.add = function(ev) {
                    this.q.push(ev);
                };
                var i, j;
                this.call = function() {
                    for (i = 0, j = this.q.length; i < j; i++) {
                        this.q[i].call();
                    }
                };
            }
            function getComputedStyle(element, prop) {
                if (element.currentStyle) {
                    return element.currentStyle[prop];
                } else if (window.getComputedStyle) {
                    return window.getComputedStyle(element, null).getPropertyValue(prop);
                } else {
                    return element.style[prop];
                }
            }
            function attachResizeEvent(element, resized) {
                if (!element.resizedAttached) {
                    element.resizedAttached = new EventQueue();
                    element.resizedAttached.add(resized);
                } else if (element.resizedAttached) {
                    element.resizedAttached.add(resized);
                    return;
                }
                var myResized = function() {
                    if (setupSensor()) {
                        element.resizedAttached.call();
                    }
                };
                element.resizeSensor = document.createElement("div");
                element.resizeSensor.className = "resize-sensor";
                var style = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1;";
                element.resizeSensor.style.cssText = style;
                element.resizeSensor.innerHTML = '<div class="resize-sensor-overflow" style="' + style + '">' + "<div></div>" + "</div>" + '<div class="resize-sensor-underflow" style="' + style + '">' + "<div></div>" + "</div>";
                element.appendChild(element.resizeSensor);
                if ("absolute" !== getComputedStyle(element, "position")) {
                    element.style.position = "relative";
                }
                var x = -1, y = -1, firstStyle = element.resizeSensor.firstElementChild.firstChild.style, lastStyle = element.resizeSensor.lastElementChild.firstChild.style;
                function setupSensor() {
                    var change = false, width = element.resizeSensor.offsetWidth, height = element.resizeSensor.offsetHeight;
                    if (x != width) {
                        firstStyle.width = width - 1 + "px";
                        lastStyle.width = width + 1 + "px";
                        change = true;
                        x = width;
                    }
                    if (y != height) {
                        firstStyle.height = height - 1 + "px";
                        lastStyle.height = height + 1 + "px";
                        change = true;
                        y = height;
                    }
                    return change;
                }
                setupSensor();
                addResizeListener(element.resizeSensor, myResized);
                addResizeListener(element.resizeSensor.firstElementChild, myResized);
                addResizeListener(element.resizeSensor.lastElementChild, myResized);
            }
            if ("array" === typeof element || "undefined" !== typeof jQuery && element instanceof jQuery || "undefined" !== typeof Elements && element instanceof Elements) {
                var i = 0, j = element.length;
                for (;i < j; i++) {
                    attachResizeEvent(element[i], callback);
                }
            } else {
                attachResizeEvent(element, callback);
            }
        };
    }, {} ],
    2: [ function(require, module, exports) {
        var ResizeSensor;
        ResizeSensor = require("./ResizeSensor");
        Polymer("ui-sidebar", {
            resize: function() {
                if (this.$.hamburger.hasAttribute("style")) {
                    return this.show();
                }
            },
            hide: function() {
                this.visible = false;
                return this.$.page.style["-webkit-transform"] = "translate3d(-" + this.$.sidebar.clientWidth + "px, 0, 0)";
            },
            show: function() {
                this.visible = true;
                return this.$.page.style["-webkit-transform"] = "translate3d(0, 0, 0)";
            },
            toggle: function() {
                if (this.visible) {
                    return this.hide();
                } else {
                    return this.show();
                }
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                this.sensor = new ResizeSensor(this.$.sizer, function(_this) {
                    return function() {
                        return _this.resize();
                    };
                }(this));
                window.addEventListener("resize", function(_this) {
                    return function() {
                        return _this.resize();
                    };
                }(this));
                this.resize();
                return this.hide();
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {
        "./ResizeSensor": 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
ui-toast {
  color: #ffffff;
}
</style>
<polymer-element name="ui-toast" attributes="timeout" on-click="{{onClick}}">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
:host {
  box-sizing: border-box;
  display: block;
}
:host #backdrop {
  box-sizing: border-box;
  z-index: 99999;
  display: flex;
  padding: 0.6em;
  position: fixed;
  bottom: 0;
  left: 0;
  min-width: 12em;
  min-height: 4em;
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
  transform: translate3d(0, 0, 0);
  -webkit-transform: translate3d(0, 0, 0);
}
:host #backdrop.fadeout {
  transform: translate3d(-100%, 0, 0);
  -webkit-transform: translate3d(-100%, 0, 0);
}
:host #effect {
  box-sizing: border-box;
  flex: 1;
  padding: 1em 1.5em 1em 1.5em;
  background-color: #333333;
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
  box-shadow: 0px 4px 1em rgba(51, 51, 51, 0.61);
  -webkit-box-shadow: 0px 4px 1em rgba(51, 51, 51, 0.61);
}
</style>
  <section id="backdrop" horizontal="" layout="" center="">
    <section id="effect" horizontal="" layout="" center="">
      <content></content>
    </section>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-toast/src/ui-toast.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-toast", {
            timeout: 3e3,
            timeoutChanged: function() {
                return this.timeout = Number(this.timeout);
            },
            show: function() {
                this.$.backdrop.classList.remove("fadeout");
                return this.async(this.hide, null, this.timeout);
            },
            hide: function() {
                return this.$.backdrop.classList.add("fadeout");
            },
            onClick: function(evt) {
                this.hide();
                return evt.stopPropagation();
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                return this.hide();
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-button" attributes="enabled icon label" on-mousedown="{{pointerdown}}" on-mouseup="{{pointerup}}" on-mouseenter="{{pointerenter}}" on-mouseleave="{{pointerleave}}">
<template>
  <style>.fa {
  display: inline-block;
  font-family: FontAwesome;
  font-style: normal;
  font-weight: normal;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-fw {
  width: 1.28571429em;
  text-align: center;
}
.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}
.fa-li.fa-lg {
  left: -1.85714286em;
}
.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eeeeee;
  border-radius: .1em;
}
.pull-right {
  float: right;
}
.pull-left {
  float: left;
}
.fa.pull-left {
  margin-right: .3em;
}
.fa.pull-right {
  margin-left: .3em;
}
.fa-spin {
  -webkit-animation: spin 2s infinite linear;
  -moz-animation: spin 2s infinite linear;
  -o-animation: spin 2s infinite linear;
  animation: spin 2s infinite linear;
}
@-moz-keyframes spin {
  0% {
    -moz-transform: rotate(0deg);
  }
  100% {
    -moz-transform: rotate(359deg);
  }
}
@-webkit-keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
  }
}
@-o-keyframes spin {
  0% {
    -o-transform: rotate(0deg);
  }
  100% {
    -o-transform: rotate(359deg);
  }
}
@keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
.fa-rotate-90 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
  -webkit-transform: rotate(90deg);
  -moz-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  -o-transform: rotate(90deg);
  transform: rotate(90deg);
}
.fa-rotate-180 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2);
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  transform: rotate(180deg);
}
.fa-rotate-270 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
  -webkit-transform: rotate(270deg);
  -moz-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  -o-transform: rotate(270deg);
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);
  -webkit-transform: scale(-1, 1);
  -moz-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  -o-transform: scale(-1, 1);
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);
  -webkit-transform: scale(1, -1);
  -moz-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  -o-transform: scale(1, -1);
  transform: scale(1, -1);
}
.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #ffffff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
  content: "\f000";
}
.fa-music:before {
  content: "\f001";
}
.fa-search:before {
  content: "\f002";
}
.fa-envelope-o:before {
  content: "\f003";
}
.fa-heart:before {
  content: "\f004";
}
.fa-star:before {
  content: "\f005";
}
.fa-star-o:before {
  content: "\f006";
}
.fa-user:before {
  content: "\f007";
}
.fa-film:before {
  content: "\f008";
}
.fa-th-large:before {
  content: "\f009";
}
.fa-th:before {
  content: "\f00a";
}
.fa-th-list:before {
  content: "\f00b";
}
.fa-check:before {
  content: "\f00c";
}
.fa-times:before {
  content: "\f00d";
}
.fa-search-plus:before {
  content: "\f00e";
}
.fa-search-minus:before {
  content: "\f010";
}
.fa-power-off:before {
  content: "\f011";
}
.fa-signal:before {
  content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
  content: "\f013";
}
.fa-trash-o:before {
  content: "\f014";
}
.fa-home:before {
  content: "\f015";
}
.fa-file-o:before {
  content: "\f016";
}
.fa-clock-o:before {
  content: "\f017";
}
.fa-road:before {
  content: "\f018";
}
.fa-download:before {
  content: "\f019";
}
.fa-arrow-circle-o-down:before {
  content: "\f01a";
}
.fa-arrow-circle-o-up:before {
  content: "\f01b";
}
.fa-inbox:before {
  content: "\f01c";
}
.fa-play-circle-o:before {
  content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
  content: "\f01e";
}
.fa-refresh:before {
  content: "\f021";
}
.fa-list-alt:before {
  content: "\f022";
}
.fa-lock:before {
  content: "\f023";
}
.fa-flag:before {
  content: "\f024";
}
.fa-headphones:before {
  content: "\f025";
}
.fa-volume-off:before {
  content: "\f026";
}
.fa-volume-down:before {
  content: "\f027";
}
.fa-volume-up:before {
  content: "\f028";
}
.fa-qrcode:before {
  content: "\f029";
}
.fa-barcode:before {
  content: "\f02a";
}
.fa-tag:before {
  content: "\f02b";
}
.fa-tags:before {
  content: "\f02c";
}
.fa-book:before {
  content: "\f02d";
}
.fa-bookmark:before {
  content: "\f02e";
}
.fa-print:before {
  content: "\f02f";
}
.fa-camera:before {
  content: "\f030";
}
.fa-font:before {
  content: "\f031";
}
.fa-bold:before {
  content: "\f032";
}
.fa-italic:before {
  content: "\f033";
}
.fa-text-height:before {
  content: "\f034";
}
.fa-text-width:before {
  content: "\f035";
}
.fa-align-left:before {
  content: "\f036";
}
.fa-align-center:before {
  content: "\f037";
}
.fa-align-right:before {
  content: "\f038";
}
.fa-align-justify:before {
  content: "\f039";
}
.fa-list:before {
  content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
  content: "\f03b";
}
.fa-indent:before {
  content: "\f03c";
}
.fa-video-camera:before {
  content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\f03e";
}
.fa-pencil:before {
  content: "\f040";
}
.fa-map-marker:before {
  content: "\f041";
}
.fa-adjust:before {
  content: "\f042";
}
.fa-tint:before {
  content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\f044";
}
.fa-share-square-o:before {
  content: "\f045";
}
.fa-check-square-o:before {
  content: "\f046";
}
.fa-arrows:before {
  content: "\f047";
}
.fa-step-backward:before {
  content: "\f048";
}
.fa-fast-backward:before {
  content: "\f049";
}
.fa-backward:before {
  content: "\f04a";
}
.fa-play:before {
  content: "\f04b";
}
.fa-pause:before {
  content: "\f04c";
}
.fa-stop:before {
  content: "\f04d";
}
.fa-forward:before {
  content: "\f04e";
}
.fa-fast-forward:before {
  content: "\f050";
}
.fa-step-forward:before {
  content: "\f051";
}
.fa-eject:before {
  content: "\f052";
}
.fa-chevron-left:before {
  content: "\f053";
}
.fa-chevron-right:before {
  content: "\f054";
}
.fa-plus-circle:before {
  content: "\f055";
}
.fa-minus-circle:before {
  content: "\f056";
}
.fa-times-circle:before {
  content: "\f057";
}
.fa-check-circle:before {
  content: "\f058";
}
.fa-question-circle:before {
  content: "\f059";
}
.fa-info-circle:before {
  content: "\f05a";
}
.fa-crosshairs:before {
  content: "\f05b";
}
.fa-times-circle-o:before {
  content: "\f05c";
}
.fa-check-circle-o:before {
  content: "\f05d";
}
.fa-ban:before {
  content: "\f05e";
}
.fa-arrow-left:before {
  content: "\f060";
}
.fa-arrow-right:before {
  content: "\f061";
}
.fa-arrow-up:before {
  content: "\f062";
}
.fa-arrow-down:before {
  content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
  content: "\f064";
}
.fa-expand:before {
  content: "\f065";
}
.fa-compress:before {
  content: "\f066";
}
.fa-plus:before {
  content: "\f067";
}
.fa-minus:before {
  content: "\f068";
}
.fa-asterisk:before {
  content: "\f069";
}
.fa-exclamation-circle:before {
  content: "\f06a";
}
.fa-gift:before {
  content: "\f06b";
}
.fa-leaf:before {
  content: "\f06c";
}
.fa-fire:before {
  content: "\f06d";
}
.fa-eye:before {
  content: "\f06e";
}
.fa-eye-slash:before {
  content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\f071";
}
.fa-plane:before {
  content: "\f072";
}
.fa-calendar:before {
  content: "\f073";
}
.fa-random:before {
  content: "\f074";
}
.fa-comment:before {
  content: "\f075";
}
.fa-magnet:before {
  content: "\f076";
}
.fa-chevron-up:before {
  content: "\f077";
}
.fa-chevron-down:before {
  content: "\f078";
}
.fa-retweet:before {
  content: "\f079";
}
.fa-shopping-cart:before {
  content: "\f07a";
}
.fa-folder:before {
  content: "\f07b";
}
.fa-folder-open:before {
  content: "\f07c";
}
.fa-arrows-v:before {
  content: "\f07d";
}
.fa-arrows-h:before {
  content: "\f07e";
}
.fa-bar-chart-o:before {
  content: "\f080";
}
.fa-twitter-square:before {
  content: "\f081";
}
.fa-facebook-square:before {
  content: "\f082";
}
.fa-camera-retro:before {
  content: "\f083";
}
.fa-key:before {
  content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
  content: "\f085";
}
.fa-comments:before {
  content: "\f086";
}
.fa-thumbs-o-up:before {
  content: "\f087";
}
.fa-thumbs-o-down:before {
  content: "\f088";
}
.fa-star-half:before {
  content: "\f089";
}
.fa-heart-o:before {
  content: "\f08a";
}
.fa-sign-out:before {
  content: "\f08b";
}
.fa-linkedin-square:before {
  content: "\f08c";
}
.fa-thumb-tack:before {
  content: "\f08d";
}
.fa-external-link:before {
  content: "\f08e";
}
.fa-sign-in:before {
  content: "\f090";
}
.fa-trophy:before {
  content: "\f091";
}
.fa-github-square:before {
  content: "\f092";
}
.fa-upload:before {
  content: "\f093";
}
.fa-lemon-o:before {
  content: "\f094";
}
.fa-phone:before {
  content: "\f095";
}
.fa-square-o:before {
  content: "\f096";
}
.fa-bookmark-o:before {
  content: "\f097";
}
.fa-phone-square:before {
  content: "\f098";
}
.fa-twitter:before {
  content: "\f099";
}
.fa-facebook:before {
  content: "\f09a";
}
.fa-github:before {
  content: "\f09b";
}
.fa-unlock:before {
  content: "\f09c";
}
.fa-credit-card:before {
  content: "\f09d";
}
.fa-rss:before {
  content: "\f09e";
}
.fa-hdd-o:before {
  content: "\f0a0";
}
.fa-bullhorn:before {
  content: "\f0a1";
}
.fa-bell:before {
  content: "\f0f3";
}
.fa-certificate:before {
  content: "\f0a3";
}
.fa-hand-o-right:before {
  content: "\f0a4";
}
.fa-hand-o-left:before {
  content: "\f0a5";
}
.fa-hand-o-up:before {
  content: "\f0a6";
}
.fa-hand-o-down:before {
  content: "\f0a7";
}
.fa-arrow-circle-left:before {
  content: "\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\f0aa";
}
.fa-arrow-circle-down:before {
  content: "\f0ab";
}
.fa-globe:before {
  content: "\f0ac";
}
.fa-wrench:before {
  content: "\f0ad";
}
.fa-tasks:before {
  content: "\f0ae";
}
.fa-filter:before {
  content: "\f0b0";
}
.fa-briefcase:before {
  content: "\f0b1";
}
.fa-arrows-alt:before {
  content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
  content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
  content: "\f0c1";
}
.fa-cloud:before {
  content: "\f0c2";
}
.fa-flask:before {
  content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
  content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
  content: "\f0c5";
}
.fa-paperclip:before {
  content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
  content: "\f0c7";
}
.fa-square:before {
  content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\f0c9";
}
.fa-list-ul:before {
  content: "\f0ca";
}
.fa-list-ol:before {
  content: "\f0cb";
}
.fa-strikethrough:before {
  content: "\f0cc";
}
.fa-underline:before {
  content: "\f0cd";
}
.fa-table:before {
  content: "\f0ce";
}
.fa-magic:before {
  content: "\f0d0";
}
.fa-truck:before {
  content: "\f0d1";
}
.fa-pinterest:before {
  content: "\f0d2";
}
.fa-pinterest-square:before {
  content: "\f0d3";
}
.fa-google-plus-square:before {
  content: "\f0d4";
}
.fa-google-plus:before {
  content: "\f0d5";
}
.fa-money:before {
  content: "\f0d6";
}
.fa-caret-down:before {
  content: "\f0d7";
}
.fa-caret-up:before {
  content: "\f0d8";
}
.fa-caret-left:before {
  content: "\f0d9";
}
.fa-caret-right:before {
  content: "\f0da";
}
.fa-columns:before {
  content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
  content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\f0de";
}
.fa-envelope:before {
  content: "\f0e0";
}
.fa-linkedin:before {
  content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
  content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
  content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
  content: "\f0e4";
}
.fa-comment-o:before {
  content: "\f0e5";
}
.fa-comments-o:before {
  content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
  content: "\f0e7";
}
.fa-sitemap:before {
  content: "\f0e8";
}
.fa-umbrella:before {
  content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
  content: "\f0ea";
}
.fa-lightbulb-o:before {
  content: "\f0eb";
}
.fa-exchange:before {
  content: "\f0ec";
}
.fa-cloud-download:before {
  content: "\f0ed";
}
.fa-cloud-upload:before {
  content: "\f0ee";
}
.fa-user-md:before {
  content: "\f0f0";
}
.fa-stethoscope:before {
  content: "\f0f1";
}
.fa-suitcase:before {
  content: "\f0f2";
}
.fa-bell-o:before {
  content: "\f0a2";
}
.fa-coffee:before {
  content: "\f0f4";
}
.fa-cutlery:before {
  content: "\f0f5";
}
.fa-file-text-o:before {
  content: "\f0f6";
}
.fa-building-o:before {
  content: "\f0f7";
}
.fa-hospital-o:before {
  content: "\f0f8";
}
.fa-ambulance:before {
  content: "\f0f9";
}
.fa-medkit:before {
  content: "\f0fa";
}
.fa-fighter-jet:before {
  content: "\f0fb";
}
.fa-beer:before {
  content: "\f0fc";
}
.fa-h-square:before {
  content: "\f0fd";
}
.fa-plus-square:before {
  content: "\f0fe";
}
.fa-angle-double-left:before {
  content: "\f100";
}
.fa-angle-double-right:before {
  content: "\f101";
}
.fa-angle-double-up:before {
  content: "\f102";
}
.fa-angle-double-down:before {
  content: "\f103";
}
.fa-angle-left:before {
  content: "\f104";
}
.fa-angle-right:before {
  content: "\f105";
}
.fa-angle-up:before {
  content: "\f106";
}
.fa-angle-down:before {
  content: "\f107";
}
.fa-desktop:before {
  content: "\f108";
}
.fa-laptop:before {
  content: "\f109";
}
.fa-tablet:before {
  content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\f10b";
}
.fa-circle-o:before {
  content: "\f10c";
}
.fa-quote-left:before {
  content: "\f10d";
}
.fa-quote-right:before {
  content: "\f10e";
}
.fa-spinner:before {
  content: "\f110";
}
.fa-circle:before {
  content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
  content: "\f112";
}
.fa-github-alt:before {
  content: "\f113";
}
.fa-folder-o:before {
  content: "\f114";
}
.fa-folder-open-o:before {
  content: "\f115";
}
.fa-smile-o:before {
  content: "\f118";
}
.fa-frown-o:before {
  content: "\f119";
}
.fa-meh-o:before {
  content: "\f11a";
}
.fa-gamepad:before {
  content: "\f11b";
}
.fa-keyboard-o:before {
  content: "\f11c";
}
.fa-flag-o:before {
  content: "\f11d";
}
.fa-flag-checkered:before {
  content: "\f11e";
}
.fa-terminal:before {
  content: "\f120";
}
.fa-code:before {
  content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\f123";
}
.fa-location-arrow:before {
  content: "\f124";
}
.fa-crop:before {
  content: "\f125";
}
.fa-code-fork:before {
  content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
  content: "\f127";
}
.fa-question:before {
  content: "\f128";
}
.fa-info:before {
  content: "\f129";
}
.fa-exclamation:before {
  content: "\f12a";
}
.fa-superscript:before {
  content: "\f12b";
}
.fa-subscript:before {
  content: "\f12c";
}
.fa-eraser:before {
  content: "\f12d";
}
.fa-puzzle-piece:before {
  content: "\f12e";
}
.fa-microphone:before {
  content: "\f130";
}
.fa-microphone-slash:before {
  content: "\f131";
}
.fa-shield:before {
  content: "\f132";
}
.fa-calendar-o:before {
  content: "\f133";
}
.fa-fire-extinguisher:before {
  content: "\f134";
}
.fa-rocket:before {
  content: "\f135";
}
.fa-maxcdn:before {
  content: "\f136";
}
.fa-chevron-circle-left:before {
  content: "\f137";
}
.fa-chevron-circle-right:before {
  content: "\f138";
}
.fa-chevron-circle-up:before {
  content: "\f139";
}
.fa-chevron-circle-down:before {
  content: "\f13a";
}
.fa-html5:before {
  content: "\f13b";
}
.fa-css3:before {
  content: "\f13c";
}
.fa-anchor:before {
  content: "\f13d";
}
.fa-unlock-alt:before {
  content: "\f13e";
}
.fa-bullseye:before {
  content: "\f140";
}
.fa-ellipsis-h:before {
  content: "\f141";
}
.fa-ellipsis-v:before {
  content: "\f142";
}
.fa-rss-square:before {
  content: "\f143";
}
.fa-play-circle:before {
  content: "\f144";
}
.fa-ticket:before {
  content: "\f145";
}
.fa-minus-square:before {
  content: "\f146";
}
.fa-minus-square-o:before {
  content: "\f147";
}
.fa-level-up:before {
  content: "\f148";
}
.fa-level-down:before {
  content: "\f149";
}
.fa-check-square:before {
  content: "\f14a";
}
.fa-pencil-square:before {
  content: "\f14b";
}
.fa-external-link-square:before {
  content: "\f14c";
}
.fa-share-square:before {
  content: "\f14d";
}
.fa-compass:before {
  content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
  content: "\f153";
}
.fa-gbp:before {
  content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
  content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
  content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\f158";
}
.fa-won:before,
.fa-krw:before {
  content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
  content: "\f15a";
}
.fa-file:before {
  content: "\f15b";
}
.fa-file-text:before {
  content: "\f15c";
}
.fa-sort-alpha-asc:before {
  content: "\f15d";
}
.fa-sort-alpha-desc:before {
  content: "\f15e";
}
.fa-sort-amount-asc:before {
  content: "\f160";
}
.fa-sort-amount-desc:before {
  content: "\f161";
}
.fa-sort-numeric-asc:before {
  content: "\f162";
}
.fa-sort-numeric-desc:before {
  content: "\f163";
}
.fa-thumbs-up:before {
  content: "\f164";
}
.fa-thumbs-down:before {
  content: "\f165";
}
.fa-youtube-square:before {
  content: "\f166";
}
.fa-youtube:before {
  content: "\f167";
}
.fa-xing:before {
  content: "\f168";
}
.fa-xing-square:before {
  content: "\f169";
}
.fa-youtube-play:before {
  content: "\f16a";
}
.fa-dropbox:before {
  content: "\f16b";
}
.fa-stack-overflow:before {
  content: "\f16c";
}
.fa-instagram:before {
  content: "\f16d";
}
.fa-flickr:before {
  content: "\f16e";
}
.fa-adn:before {
  content: "\f170";
}
.fa-bitbucket:before {
  content: "\f171";
}
.fa-bitbucket-square:before {
  content: "\f172";
}
.fa-tumblr:before {
  content: "\f173";
}
.fa-tumblr-square:before {
  content: "\f174";
}
.fa-long-arrow-down:before {
  content: "\f175";
}
.fa-long-arrow-up:before {
  content: "\f176";
}
.fa-long-arrow-left:before {
  content: "\f177";
}
.fa-long-arrow-right:before {
  content: "\f178";
}
.fa-apple:before {
  content: "\f179";
}
.fa-windows:before {
  content: "\f17a";
}
.fa-android:before {
  content: "\f17b";
}
.fa-linux:before {
  content: "\f17c";
}
.fa-dribbble:before {
  content: "\f17d";
}
.fa-skype:before {
  content: "\f17e";
}
.fa-foursquare:before {
  content: "\f180";
}
.fa-trello:before {
  content: "\f181";
}
.fa-female:before {
  content: "\f182";
}
.fa-male:before {
  content: "\f183";
}
.fa-gittip:before {
  content: "\f184";
}
.fa-sun-o:before {
  content: "\f185";
}
.fa-moon-o:before {
  content: "\f186";
}
.fa-archive:before {
  content: "\f187";
}
.fa-bug:before {
  content: "\f188";
}
.fa-vk:before {
  content: "\f189";
}
.fa-weibo:before {
  content: "\f18a";
}
.fa-renren:before {
  content: "\f18b";
}
.fa-pagelines:before {
  content: "\f18c";
}
.fa-stack-exchange:before {
  content: "\f18d";
}
.fa-arrow-circle-o-right:before {
  content: "\f18e";
}
.fa-arrow-circle-o-left:before {
  content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\f191";
}
.fa-dot-circle-o:before {
  content: "\f192";
}
.fa-wheelchair:before {
  content: "\f193";
}
.fa-vimeo-square:before {
  content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
  content: "\f195";
}
.fa-plus-square-o:before {
  content: "\f196";
}
.fa-space-shuttle:before {
  content: "\f197";
}
.fa-slack:before {
  content: "\f198";
}
.fa-envelope-square:before {
  content: "\f199";
}
.fa-wordpress:before {
  content: "\f19a";
}
.fa-openid:before {
  content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\f19d";
}
.fa-yahoo:before {
  content: "\f19e";
}
.fa-google:before {
  content: "\f1a0";
}
.fa-reddit:before {
  content: "\f1a1";
}
.fa-reddit-square:before {
  content: "\f1a2";
}
.fa-stumbleupon-circle:before {
  content: "\f1a3";
}
.fa-stumbleupon:before {
  content: "\f1a4";
}
.fa-delicious:before {
  content: "\f1a5";
}
.fa-digg:before {
  content: "\f1a6";
}
.fa-pied-piper-square:before,
.fa-pied-piper:before {
  content: "\f1a7";
}
.fa-pied-piper-alt:before {
  content: "\f1a8";
}
.fa-drupal:before {
  content: "\f1a9";
}
.fa-joomla:before {
  content: "\f1aa";
}
.fa-language:before {
  content: "\f1ab";
}
.fa-fax:before {
  content: "\f1ac";
}
.fa-building:before {
  content: "\f1ad";
}
.fa-child:before {
  content: "\f1ae";
}
.fa-paw:before {
  content: "\f1b0";
}
.fa-spoon:before {
  content: "\f1b1";
}
.fa-cube:before {
  content: "\f1b2";
}
.fa-cubes:before {
  content: "\f1b3";
}
.fa-behance:before {
  content: "\f1b4";
}
.fa-behance-square:before {
  content: "\f1b5";
}
.fa-steam:before {
  content: "\f1b6";
}
.fa-steam-square:before {
  content: "\f1b7";
}
.fa-recycle:before {
  content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
  content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
  content: "\f1ba";
}
.fa-tree:before {
  content: "\f1bb";
}
.fa-spotify:before {
  content: "\f1bc";
}
.fa-deviantart:before {
  content: "\f1bd";
}
.fa-soundcloud:before {
  content: "\f1be";
}
.fa-database:before {
  content: "\f1c0";
}
.fa-file-pdf-o:before {
  content: "\f1c1";
}
.fa-file-word-o:before {
  content: "\f1c2";
}
.fa-file-excel-o:before {
  content: "\f1c3";
}
.fa-file-powerpoint-o:before {
  content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\f1c8";
}
.fa-file-code-o:before {
  content: "\f1c9";
}
.fa-vine:before {
  content: "\f1ca";
}
.fa-codepen:before {
  content: "\f1cb";
}
.fa-jsfiddle:before {
  content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\f1cd";
}
.fa-circle-o-notch:before {
  content: "\f1ce";
}
.fa-ra:before,
.fa-rebel:before {
  content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
  content: "\f1d1";
}
.fa-git-square:before {
  content: "\f1d2";
}
.fa-git:before {
  content: "\f1d3";
}
.fa-hacker-news:before {
  content: "\f1d4";
}
.fa-tencent-weibo:before {
  content: "\f1d5";
}
.fa-qq:before {
  content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
  content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
  content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\f1d9";
}
.fa-history:before {
  content: "\f1da";
}
.fa-circle-thin:before {
  content: "\f1db";
}
.fa-header:before {
  content: "\f1dc";
}
.fa-paragraph:before {
  content: "\f1dd";
}
.fa-sliders:before {
  content: "\f1de";
}
.fa-share-alt:before {
  content: "\f1e0";
}
.fa-share-alt-square:before {
  content: "\f1e1";
}
.fa-bomb:before {
  content: "\f1e2";
}
.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
:host {
  display: inline-block;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
:host #button {
  overflow: hidden;
  align-items: center;
  border: none;
  outline: none;
  margin: 0;
  padding: 0.65em 0.65em;
  font-weight: 200;
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
  color: rgba(69, 69, 69, 0.33);
  cursor: default;
  white-space: nowrap;
  text-overflow: ellipsis;
}
:host #button.enabled {
  color: #454545;
  cursor: pointer;
}
:host #button.pressed {
  transform: scale(0.95, 0.95);
  -webkit-transform: scale(0.95, 0.95);
}
:host #icon {
  padding-right: 0.35em;
}
:host([inverted]) #button {
  color: rgba(255, 255, 255, 0.33);
  background-color: #333333;
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
:host([inverted]) #button.enabled {
  color: #ffffff;
  cursor: pointer;
}
</style>
  <section id="button" class="{{ {enabled: enabled} | tokenList }}" on-click="{{click}}" title="{{label}}">
    <template if="{{icon}}">
      <i id="icon" class="fa {{icon}}"></i>
    </template>
    <template if="{{label}}">
      <span id="label">{{label}}</span>
    </template>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-button/src/ui-button.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-button", {
            pointerdown: function() {
                if (this.enabled) {
                    return this.$.button.classList.add("pressed");
                }
            },
            pointerup: function() {
                return this.$.button.classList.remove("pressed");
            },
            click: function(evt) {
                if (!this.enabled) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    evt.stopImmediatePropagation();
                    return false;
                }
            },
            pointerenter: function() {},
            pointerleave: function() {},
            created: function() {
                return this.enabled = true;
            },
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-switch" attributes="checked" on-click="{{onContentClick}}">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
:host {
  display: inline-block;
  box-model: border-box;
  position: relative;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
:host section,
:host label {
  cursor: pointer;
}
:host #switch {
  box-sizing: content-box;
  display: inline-block;
  width: 2.5em;
  height: 1em;
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  margin-right: 0.5em;
  padding: 3px;
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
}
:host #switchhandle {
  box-sizing: border-box;
  display: inline-block;
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  width: 1em;
  height: 1em;
  transition: 0.1s ease-out;
  -webkit-transition: 0.1s ease-out;
  margin-left: 0;
}
:host #check[checked] ~ #checklabel #switch {
  background-color: #c8ed8d;
}
:host #check[checked] ~ #checklabel #switchhandle {
  margin-left: 1.5em;
}
:host input {
  position: absolute;
  opacity: 0;
}
:host([focused]) #switch {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
</style>
  <section on-click="{{onSwitchClick}}">
    <input type="checkbox" id="check" on-click="{{onChange}}" on-change="{{onChange}}" on-focus="{{onFocus}}" on-blur="{{onBlur}}">
    <label id="checklabel" for="check" horizontal="" layout="" center="">
      <section id="switch">
        <span id="switchhandle"></span>
      </section>
      <content></content>
    </label>
</section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-switch/src/ui-switch.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-switch", {
            checkedChanged: function() {
                if (this.checked) {
                    this.$.check.setAttribute("checked", "");
                } else {
                    this.$.check.removeAttribute("checked");
                }
                return this.fire("change");
            },
            onChange: function() {
                return this.checked = this.$.check.checked;
            },
            onFocus: function() {
                return this.setAttribute("focused", "");
            },
            onBlur: function() {
                return this.removeAttribute("focused");
            },
            onContentClick: function(evt) {
                return this.checked = !this.checked;
            },
            onSwitchClick: function(evt) {
                return evt.stopPropagation();
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-check" attributes="checked" on-click="{{onContentClick}}">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
:host {
  display: inline-block;
  box-model: border-box;
  position: relative;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
:host section,
:host label {
  cursor: pointer;
}
:host #checkframe {
  box-sizing: content-box;
  display: inline-block;
  width: 1em;
  height: 1em;
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  margin-right: 0.5em;
  padding: 3px;
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
}
:host #checkfill {
  box-sizing: border-box;
  display: inline-block;
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  width: 1em;
  height: 1em;
  transition: 0.1s ease-out;
  -webkit-transition: 0.1s ease-out;
  margin-left: 0;
}
:host #check[checked] ~ #checklabel #checkfill {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
:host input {
  position: absolute;
  opacity: 0;
}
:host([focused]) #checkframe {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
</style>
  <section on-click="{{onCheckClick}}">
    <input type="checkbox" id="check" on-click="{{onChange}}" on-change="{{onChange}}" on-focus="{{onFocus}}" on-blur="{{onBlur}}">
    <label id="checklabel" for="check" horizontal="" layout="" center="">
      <section id="checkframe">
        <span id="checkfill"></span>
      </section>
      <content></content>
    </label>
</section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-check/src/ui-check.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-check", {
            checkedChanged: function(oldValue, newValue) {
                if (this.checked) {
                    this.$.check.setAttribute("checked", "");
                } else {
                    this.$.check.removeAttribute("checked");
                }
                return this.fire("change");
            },
            onChange: function(evt) {
                this.checked = this.$.check.checked;
                return evt.stopPropagation();
            },
            onFocus: function() {
                return this.setAttribute("focused", "");
            },
            onBlur: function() {
                return this.removeAttribute("focused");
            },
            onContentClick: function(evt) {
                return this.checked = !this.checked;
            },
            onCheckClick: function(evt) {
                this.checked = !this.checked;
                return evt.stopPropagation();
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-hotkey" attributes="key">
  <template> </template>
  <script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-hotkey/src/ui-hotkey.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        "use strict";
        module.exports = {
            48: "0",
            49: "1",
            50: "2",
            51: "3",
            52: "4",
            53: "5",
            54: "6",
            55: "7",
            56: "8",
            57: "9",
            59: ";",
            61: "=",
            65: "a",
            66: "b",
            67: "c",
            68: "d",
            69: "e",
            70: "f",
            71: "g",
            72: "h",
            73: "i",
            74: "j",
            75: "k",
            76: "l",
            77: "m",
            78: "n",
            79: "o",
            80: "p",
            81: "q",
            82: "r",
            83: "s",
            84: "t",
            85: "u",
            86: "v",
            87: "w",
            88: "x",
            89: "y",
            90: "z",
            107: "+",
            109: "-",
            110: ".",
            188: ",",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: '"',
            8: "backspace",
            9: "tab",
            13: "return",
            16: "shift",
            17: "control",
            18: "alt",
            19: "pause",
            27: "escape",
            32: "space",
            33: "pageup",
            34: "pagedown",
            35: "end",
            36: "home",
            37: "left",
            38: "up",
            39: "right",
            40: "down",
            44: "printscreen",
            45: "insert",
            46: "delete",
            112: "f1",
            113: "f2",
            114: "f3",
            115: "f4",
            116: "f5",
            117: "f6",
            118: "f7",
            119: "f8",
            120: "f9",
            121: "f10",
            122: "f11",
            123: "f12",
            144: "numlock",
            145: "scrolllock",
            91: "command"
        };
    }, {} ],
    2: [ function(require, module, exports) {
        var getAction, keyCodes;
        keyCodes = require("./key-codes");
        getAction = function(e) {
            var action, which;
            action = [];
            if (e.ctrlKey) {
                action.push("control");
            }
            if (e.altKey) {
                action.push("alt");
            }
            if (e.shiftKey) {
                action.push("shift");
            }
            which = keyCodes[e.which];
            if (action.indexOf(which) === -1) {
                action.push(which);
            }
            return action.join("+");
        };
        Polymer("ui-hotkey", {
            myListener: function(e) {
                var action, _ref;
                action = getAction(e);
                if (action === ((_ref = this.key) != null ? _ref.toLowerCase() : void 0)) {
                    return this.click();
                }
            },
            attached: function() {
                return document.addEventListener("keyup", function(_this) {
                    return function(e) {
                        return _this.myListener(e);
                    };
                }(this));
            },
            detached: function() {
                return document.removeEventListener("keyup", function(_this) {
                    return function(e) {
                        return _this.myListener(e);
                    };
                }(this));
            }
        });
    }, {
        "./key-codes": 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<polymer-element name="ui-fast-picker" attributes="selected radius startangle endangle" on-select="{{selectHandler}}">
<template>
  <style>[hide] {
  visibility: hidden;
  opacity: 0;
}
:host {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  vertical-align: baseline;
  cursor: pointer;
}
background {
  display: block;
  position: absolute;
  z-index: 1;
}
</style>
  <background></background>
  <content>
  </content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-fast-picker/src/ui-fast-picker.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var undefined;
                var arrayPool = [], objectPool = [];
                var idCounter = 0;
                var keyPrefix = +new Date() + "";
                var largeArraySize = 75;
                var maxPoolSize = 40;
                var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reFuncName = /^\s*function[ \n\r\t]+\w/;
                var reInterpolate = /<%=([\s\S]+?)%>/g;
                var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
                var reNoMatch = /($^)/;
                var reThis = /\bthis\b/;
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
                var contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
                var templateCounter = 0;
                var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
                var debounceOptions = {
                    leading: false,
                    maxWait: 0,
                    trailing: false
                };
                var descriptor = {
                    configurable: false,
                    enumerable: false,
                    value: null,
                    writable: false
                };
                var objectTypes = {
                    "boolean": false,
                    "function": true,
                    object: true,
                    number: false,
                    string: false,
                    undefined: false
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "	": "t",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var root = objectTypes[typeof window] && window || this;
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;
                    if (type == "boolean" || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != "number" && type != "string") {
                        type = "object";
                    }
                    var key = type == "number" ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];
                    return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
                }
                function cachePush(value) {
                    var cache = this.cache, type = typeof value;
                    if (type == "boolean" || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != "number" && type != "string") {
                            type = "object";
                        }
                        var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                        if (type == "object") {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }
                function compareAscending(a, b) {
                    var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
                    while (++index < length) {
                        var value = ac[index], other = bc[index];
                        if (value !== other) {
                            if (value > other || typeof value == "undefined") {
                                return 1;
                            }
                            if (value < other || typeof other == "undefined") {
                                return -1;
                            }
                        }
                    }
                    return a.index - b.index;
                }
                function createCache(array) {
                    var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
                    if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
                        return false;
                    }
                    var cache = getObject();
                    cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;
                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }
                function escapeStringChar(match) {
                    return "\\" + stringEscapes[match];
                }
                function getArray() {
                    return arrayPool.pop() || [];
                }
                function getObject() {
                    return objectPool.pop() || {
                        array: null,
                        cache: null,
                        criteria: null,
                        "false": false,
                        index: 0,
                        "null": false,
                        number: null,
                        object: null,
                        push: null,
                        string: null,
                        "true": false,
                        undefined: false,
                        value: null
                    };
                }
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == "undefined") {
                        end = array ? array.length : 0;
                    }
                    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }
                function runInContext(context) {
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayRef = [];
                    var objectProto = Object.prototype;
                    var oldDash = context._;
                    var toString = objectProto.toString;
                    var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
                    var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
                    var defineProperty = function() {
                        try {
                            var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }();
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;
                    function lodash(value) {
                        return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
                    }
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    lodashWrapper.prototype = lodash.prototype;
                    var support = lodash.support = {};
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
                    support.funcNames = typeof Function.name == "string";
                    lodash.templateSettings = {
                        escape: /<%-([\s\S]+?)%>/g,
                        evaluate: /<%([\s\S]+?)%>/g,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    function baseBind(bindData) {
                        var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
                        function bound() {
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (this instanceof bound) {
                                var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != "undefined") {
                                return result;
                            }
                        }
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                              case boolClass:
                              case dateClass:
                                return new ctor(+value);

                              case numberClass:
                              case stringClass:
                                return new ctor(value);

                              case regexpClass:
                                result = ctor(value.source, reFlags.exec(value));
                                result.lastIndex = value.lastIndex;
                                return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());
                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        if (isArr) {
                            if (hasOwnProperty.call(value, "index")) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, "input")) {
                                result.input = value.input;
                            }
                        }
                        if (!isDeep) {
                            return result;
                        }
                        stackA.push(value);
                        stackB.push(result);
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    if (!nativeCreate) {
                        baseCreate = function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object();
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }();
                    }
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != "function") {
                            return identity;
                        }
                        if (typeof thisArg == "undefined" || !("prototype" in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == "undefined") {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        if (bindData === false || bindData !== true && bindData[1] & 1) {
                            return func;
                        }
                        switch (argCount) {
                          case 1:
                            return function(value) {
                                return func.call(thisArg, value);
                            };

                          case 2:
                            return function(a, b) {
                                return func.call(thisArg, a, b);
                            };

                          case 3:
                            return function(value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                          case 4:
                            return function(accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };
                        }
                        return bind(func, thisArg);
                    }
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseDifference(array, values) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1, valLength = value.length, resIndex = result.length;
                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != "undefined") {
                                return !!result;
                            }
                        }
                        if (a === b) {
                            return a !== 0 || 1 / a == 1 / b;
                        }
                        var type = typeof a, otherType = typeof b;
                        if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                            return false;
                        }
                        if (a == null || b == null) {
                            return a === b;
                        }
                        var className = toString.call(a), otherClass = toString.call(b);
                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                          case boolClass:
                          case dateClass:
                            return +a == +b;

                          case numberClass:
                            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

                          case regexpClass:
                          case stringClass:
                            return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            if (className != objectClass) {
                                return false;
                            }
                            var ctorA = a.constructor, ctorB = b.constructor;
                            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                                return false;
                            }
                        }
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;
                        stackA.push(a);
                        stackB.push(b);
                        if (isArr) {
                            length = a.length;
                            size = b.length;
                            result = size == length;
                            if (result || isWhere) {
                                while (size--) {
                                    var index = length, value = b[size];
                                    if (isWhere) {
                                        while (index--) {
                                            if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    size++;
                                    return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                                }
                            });
                            if (result && !isWhere) {
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        return result = --size > -1;
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found, isArr, result = source, value = object[key];
                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if (found = stackA[stackLength] == source) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if (isShallow = typeof result != "undefined") {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                    }
                                    stackA.push(source);
                                    stackB.push(value);
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == "undefined") {
                                        result = source;
                                    }
                                }
                                if (typeof result != "undefined") {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }
                    function baseUniq(array, isSorted, callback) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index], computed = callback ? callback(value, index, array) : value;
                            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);
                            var index = -1, length = collection ? collection.length : 0;
                            if (typeof length == "number") {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError();
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
                        return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
                    }
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }
                    function isNative(value) {
                        return typeof value == "function" && reNative.test(value);
                    }
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, "__bindData__", descriptor);
                    };
                    function shimIsPlainObject(value) {
                        var ctor, result;
                        if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
                        isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == "undefined" || hasOwnProperty.call(value, result);
                    }
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }
                    function isArguments(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
                    }
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
                    };
                    var shimKeys = function(object) {
                        var index, iterable = object, result = [];
                        if (!iterable) return result;
                        if (!objectTypes[typeof object]) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result;
                    };
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };
                    var htmlEscapes = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    var htmlUnescapes = invert(htmlEscapes);
                    var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
                    var assign = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function clone(value, isDeep, callback, thisArg) {
                        if (typeof isDeep != "boolean" && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }
                    var defaults = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == "undefined") result[index] = iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];
                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });
                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object), length = props.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }
                    function invert(object) {
                        var index = -1, props = keys(object), length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }
                    function isBoolean(value) {
                        return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
                    }
                    function isDate(value) {
                        return value && typeof value == "object" && toString.call(value) == dateClass || false;
                    }
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value), length = value.length;
                        if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return result = false;
                        });
                        return result;
                    }
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
                    }
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }
                    function isFunction(value) {
                        return typeof value == "function";
                    }
                    function isObject(value) {
                        return !!(value && objectTypes[typeof value]);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
                    }
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                    };
                    function isRegExp(value) {
                        return value && typeof value == "object" && toString.call(value) == regexpClass || false;
                    }
                    function isString(value) {
                        return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
                    }
                    function isUndefined(value) {
                        return typeof value == "undefined";
                    }
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }
                    function merge(object) {
                        var args = arguments, length = 2;
                        if (!isObject(object)) {
                            return object;
                        }
                        if (typeof args[2] != "number") {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == "function") {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == "function") {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function pairs(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            var key = props[index];
                            result[index] = [ key, object[key] ];
                        }
                        return result;
                    }
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }
                    function values(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }
                    function at(collection) {
                        var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }
                    function contains(collection, target, fromIndex) {
                        var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == "number") {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                    });
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return result = !!callback(value, index, collection);
                            });
                        }
                        return result;
                    }
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }
                    function forEach(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }
                    function map(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    function min(collection, callback, thisArg) {
                        var computed = Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    var pluck = map;
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        var index = -1, length = collection.length;
                        if (typeof length == "number") {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                            });
                        }
                        return accumulator;
                    }
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != "number") {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }
                    function shuffle(collection) {
                        var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == "number" ? length : keys(collection).length;
                    }
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (result = callback(collection[index], index, collection)) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }
                    function sortBy(collection, callback, thisArg) {
                        var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });
                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }
                    function toArray(collection) {
                        if (collection && typeof collection.length == "number") {
                            return slice(collection);
                        }
                        return values(collection);
                    }
                    var where = filter;
                    function compact(array) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }
                    function findIndex(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function first(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }
                    function flatten(array, isShallow, callback, thisArg) {
                        if (typeof isShallow != "boolean" && isShallow != null) {
                            thisArg = callback;
                            callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == "number") {
                            var length = array ? array.length : 0;
                            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }
                    function initial(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }
                    function intersection() {
                        var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0], index = -1, length = array ? array.length : 0, result = [];
                        outer: while (++index < length) {
                            var cache = caches[0];
                            value = array[index];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                argsIndex = argsLength;
                                (cache || seen).push(value);
                                while (--argsIndex) {
                                    cache = caches[argsIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                        }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }
                    function last(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == "number") {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function pull(array) {
                        var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
                        while (++argsIndex < argsLength) {
                            var index = -1, value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == "number" ? step : +step || 1;
                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function remove(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }
                    function rest(array, callback, thisArg) {
                        if (typeof callback != "number" && callback != null) {
                            var n = 0, index = -1, length = array ? array.length : 0;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0, high = array ? array.length : low;
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);
                        while (low < high) {
                            var mid = low + high >>> 1;
                            callback(array[mid]) < value ? low = mid + 1 : high = mid;
                        }
                        return low;
                    }
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }
                    function uniq(array, isSorted, callback, thisArg) {
                        if (typeof isSorted != "boolean" && isSorted != null) {
                            thisArg = callback;
                            callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }
                    function xor() {
                        var index = -1, length = arguments.length;
                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                            }
                        }
                        return result || [];
                    }
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }
                    function zipObject(keys, values) {
                        var index = -1, length = keys ? keys.length : 0, result = {};
                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function bind(func, thisArg) {
                        return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
                    }
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }
                    function bindKey(object, key) {
                        return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
                    }
                    function compose() {
                        var funcs = arguments, length = funcs.length;
                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError();
                            }
                        }
                        return function() {
                            var args = arguments, length = funcs.length;
                            while (length--) {
                                args = [ funcs[length].apply(this, args) ];
                            }
                            return args[0];
                        };
                    }
                    function curry(func, arity) {
                        arity = typeof arity == "number" ? arity : +arity || func.length;
                        return createWrapper(func, 4, null, null, null, arity);
                    }
                    function debounce(func, wait, options) {
                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };
                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || maxWait !== wait) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };
                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);
                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var memoized = function() {
                            var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                        };
                        memoized.cache = {};
                        return memoized;
                    }
                    function once(func) {
                        var ran, result;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);
                            func = null;
                            return result;
                        };
                    }
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = "leading" in options ? options.leading : leading;
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;
                        return debounce(func, wait, debounceOptions);
                    }
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [ value ]);
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == "function") {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        if (type != "object") {
                            return property(func);
                        }
                        var props = keys(func), key = props[0], a = func[key];
                        if (props.length == 1 && a === a && !isObject(a)) {
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || 1 / a == 1 / b);
                            };
                        }
                        return function(object) {
                            var length = props.length, result = false;
                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }
                    function escape(string) {
                        return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }
                    function identity(value) {
                        return value;
                    }
                    function mixin(object, source, options) {
                        var chain = true, methodNames = source && functions(source);
                        if (!source || !options && !methodNames.length) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && "chain" in options) {
                            chain = options.chain;
                        }
                        var ctor = object, isFunc = isFunction(ctor);
                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }
                    function noop() {}
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };
                    var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
                    };
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }
                    function random(min, max, floating) {
                        var noMin = min == null, noMax = max == null;
                        if (floating == null) {
                            if (typeof min == "boolean" && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == "boolean") {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                        }
                        return baseRandom(min, max);
                    }
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }
                    function template(text, data, options) {
                        var settings = lodash.templateSettings;
                        text = String(text || "");
                        options = defaults({}, options, settings);
                        var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                        var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = options.variable, hasVariable = variable;
                        if (!hasVariable) {
                            variable = "obj";
                            source = "with (" + variable + ") {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
                        try {
                            var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        result.source = source;
                        return result;
                    }
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1, result = Array(n);
                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }
                    function unescape(string) {
                        return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? "" : prefix) + id;
                    }
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;
                    mixin(lodash);
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;
                    mixin(function() {
                        var source = {};
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;
                    lodash.take = first;
                    lodash.head = first;
                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== "sample";
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                                return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                            };
                        }
                    });
                    lodash.VERSION = "2.4.1";
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;
                    forEach([ "join", "pop", "shift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                            return chainAll ? new lodashWrapper(result, chainAll) : result;
                        };
                    });
                    forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });
                    forEach([ "concat", "slice", "splice" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });
                    return lodash;
                }
                var _ = runInContext();
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    root._ = _;
                    define(function() {
                        return _;
                    });
                } else if (freeExports && freeModule) {
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    } else {
                        freeExports._ = _;
                    }
                } else {
                    root._ = _;
                }
            }).call(this);
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    2: [ function(require, module, exports) {
        var _;
        _ = require("lodash");
        Polymer("ui-fast-picker", {
            radiusChanged: function() {
                var items;
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                return _.each(items, function(_this) {
                    return function(item) {
                        return item.style.width = "" + _this.radius + "px";
                    };
                }(this));
            },
            startangleChanged: function() {
                return this.layout();
            },
            endangleChanged: function() {
                return this.layout();
            },
            setup: function() {
                var first, items, offset, selected, styleDef, topBorder, topPadding, width;
                this.toggled = false;
                this.startangle || (this.startangle = 0);
                this.endangle || (this.endangle = 360);
                if (!this.querySelector("[selected]")) {
                    first = this.querySelector("ui-fast-picker-item:not([clone])");
                    if (first) {
                        first.setAttribute("selected", "");
                    }
                    if (first) {
                        this.select(first);
                    }
                }
                selected = this.querySelector("[selected]");
                this.close();
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                selected = this.querySelector("ui-fast-picker-item[clone]");
                width = (selected != null ? selected.offsetWidth : void 0) || 0;
                first = items[0];
                styleDef = window.getComputedStyle(first, null);
                if (styleDef) {
                    topPadding = styleDef.getPropertyValue("padding-top");
                    topBorder = styleDef.getPropertyValue("border-top-width");
                    offset = Number(topBorder.replace("px", "")) + Number(topPadding.replace("px", ""));
                }
                return _.each(items, function(item, index) {
                    item.style.left = "" + width / 2 + "px";
                    item.style.webkitTransformOrigin = "0% 50%";
                    return item.style.top = "-" + offset + "px";
                });
            },
            close: function() {
                var background, items, _ref;
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                _.each(items, function(_this) {
                    return function(i) {
                        return i.setAttribute("hide", "");
                    };
                }(this));
                if ((_ref = this.querySelector("ui-fast-picker-item[clone]")) != null) {
                    _ref.removeAttribute("active");
                }
                background = this.shadowRoot.querySelector("background");
                return background.setAttribute("hide", "");
            },
            open: function() {
                var background, items, _ref;
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                _.each(items, function(_this) {
                    return function(i) {
                        return i.removeAttribute("hide");
                    };
                }(this));
                if ((_ref = this.querySelector("ui-fast-picker-item[clone]")) != null) {
                    _ref.setAttribute("active", "");
                }
                background = this.shadowRoot.querySelector("background");
                background.removeAttribute("hide");
                return this.layout();
            },
            toggle: function() {
                this.toggled = !this.toggled;
                if (this.toggled) {
                    return this.open();
                } else {
                    return this.close();
                }
            },
            select: function(node) {
                var clone, existingClone, rect;
                this.selected = node.value;
                existingClone = this.querySelector("ui-fast-picker-item[clone]");
                if (existingClone === node) {
                    return this.toggle();
                } else {
                    if (existingClone) {
                        this.removeChild(existingClone);
                    }
                    clone = node.cloneNode(true);
                    clone.removeAttribute("hide");
                    clone.removeAttribute("selected");
                    clone.removeAttribute("style");
                    clone.setAttribute("clone", "");
                    _.each(clone.children, function(child) {
                        child.removeAttribute("style");
                        return clone.removeAttribute("hide");
                    });
                    this.appendChild(clone);
                    rect = clone.getBoundingClientRect();
                    this.style.width = "" + rect.width + "px";
                    return this.style.height = "" + rect.height + "px";
                }
            },
            positionBackground: function(against) {
                var background, h, styleDef, w;
                background = this.shadowRoot.querySelector("background");
                background.style.width = "" + 2 * this.radius + "px";
                background.style.height = "" + 2 * this.radius + "px";
                styleDef = window.getComputedStyle(background, null);
                if (styleDef) {
                    w = Number(styleDef.getPropertyValue("width").replace("px", ""));
                    h = Number(styleDef.getPropertyValue("height").replace("px", ""));
                    background.style.left = "-" + (w / 2 - against.offsetWidth / 2) + "px";
                    return background.style.top = "-" + (h / 2 - against.offsetHeight / 2) + "px";
                }
            },
            layout: function() {
                var clone, deg, items, numItems, offsetAngle, totalAngle, width;
                items = this.querySelectorAll("ui-fast-picker-item:not([clone])");
                numItems = items.length;
                totalAngle = Math.abs(Number(this.startangle) - Number(this.endangle));
                if (totalAngle < 360) {
                    numItems -= 1;
                }
                deg = totalAngle / numItems;
                offsetAngle = Number(this.startangle);
                clone = this.querySelector("ui-fast-picker-item[clone]");
                width = (clone != null ? clone.offsetWidth : void 0) || 0;
                this.radius || (this.radius = (clone != null ? clone.offsetWidth : void 0) * 2.5);
                _.each(items, function(_this) {
                    return function(item, index) {
                        item.setAttribute("animate", item.style.left = "" + width / 2 + "px");
                        item.style.webkitTransform = "rotate(" + (deg * index + offsetAngle) + "deg) ";
                        item.style.zIndex = items.length - index;
                        return _.each(item.children, function(child) {
                            return child.style.webkitTransform = "rotate(-" + (deg * index + offsetAngle) + "deg)";
                        });
                    };
                }(this));
                if (clone) {
                    return this.positionBackground(clone);
                }
            },
            observeChildren: function(fn) {
                fn.bind(this)();
                return this.onMutation(this, function(_this) {
                    return function() {
                        return _this.observeChildren(fn);
                    };
                }(this));
            },
            selectHandler: function(event) {
                return this.select(event.target);
            },
            attached: function() {
                this.observeChildren(this.setup);
                return this.setup();
            }
        });
    }, {
        lodash: 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<polymer-element name="ui-fast-picker-item" attributes="selected value" on-click="{{clickHandler}}" on-mousedown="{{pointerdown}}" on-mouseup="{{pointerup}}">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  position: absolute;
  box-sizing: border-box;
  text-align: right;
  visibility: visible;
  opacity: 1;
}
:host([animate]) {
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
}
:host([clone]) {
  position: relative;
  display: inline-block;
  text-align: left;
  z-index: initial;
}
:host(:not([clone])) {
  background: rgba(0, 0, 0, 0.1);
  box-shadow: 0px 0px 1px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 1px 1px rgba(0, 0, 0, 0.1) inset;
  padding-right: 0.3em;
}
:host([active]) {
  z-index: 99999;
}
:host([hide]) {
  transform: rotate(0rad) !important;
  -webkit-transform: rotate(0rad) !important;
  visibility: hidden;
  opacity: 0;
}
section[pressed] {
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  transform: scale(0.95, 0.95);
  -webkit-transform: scale(0.95, 0.95);
}
</style>
  <background></background>
  <section id="button">
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-fast-picker/src/ui-fast-picker-item.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-fast-picker-item", {
            selectedChanged: function(oldVal, newVal) {
                if (this.hasAttribute("selected")) {
                    return this.fire("select", this.value);
                }
            },
            clickHandler: function(event) {
                return this.fire("select");
            },
            pointerdown: function() {
                return this.$.button.setAttribute("pressed", "");
            },
            pointerup: function() {
                return this.$.button.removeAttribute("pressed");
            }
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-input" attributes="value multiline icon iconAnimation placeholder disabled type autofocus
 autocorrect autocapitalize autocomplete">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
.fa {
  display: inline-block;
  font-family: FontAwesome;
  font-style: normal;
  font-weight: normal;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-fw {
  width: 1.28571429em;
  text-align: center;
}
.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}
.fa-li.fa-lg {
  left: -1.85714286em;
}
.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eeeeee;
  border-radius: .1em;
}
.pull-right {
  float: right;
}
.pull-left {
  float: left;
}
.fa.pull-left {
  margin-right: .3em;
}
.fa.pull-right {
  margin-left: .3em;
}
.fa-spin {
  -webkit-animation: spin 2s infinite linear;
  -moz-animation: spin 2s infinite linear;
  -o-animation: spin 2s infinite linear;
  animation: spin 2s infinite linear;
}
@-moz-keyframes spin {
  0% {
    -moz-transform: rotate(0deg);
  }
  100% {
    -moz-transform: rotate(359deg);
  }
}
@-webkit-keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
  }
}
@-o-keyframes spin {
  0% {
    -o-transform: rotate(0deg);
  }
  100% {
    -o-transform: rotate(359deg);
  }
}
@keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
.fa-rotate-90 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
  -webkit-transform: rotate(90deg);
  -moz-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  -o-transform: rotate(90deg);
  transform: rotate(90deg);
}
.fa-rotate-180 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2);
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  transform: rotate(180deg);
}
.fa-rotate-270 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
  -webkit-transform: rotate(270deg);
  -moz-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  -o-transform: rotate(270deg);
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);
  -webkit-transform: scale(-1, 1);
  -moz-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  -o-transform: scale(-1, 1);
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);
  -webkit-transform: scale(1, -1);
  -moz-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  -o-transform: scale(1, -1);
  transform: scale(1, -1);
}
.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #ffffff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
  content: "\f000";
}
.fa-music:before {
  content: "\f001";
}
.fa-search:before {
  content: "\f002";
}
.fa-envelope-o:before {
  content: "\f003";
}
.fa-heart:before {
  content: "\f004";
}
.fa-star:before {
  content: "\f005";
}
.fa-star-o:before {
  content: "\f006";
}
.fa-user:before {
  content: "\f007";
}
.fa-film:before {
  content: "\f008";
}
.fa-th-large:before {
  content: "\f009";
}
.fa-th:before {
  content: "\f00a";
}
.fa-th-list:before {
  content: "\f00b";
}
.fa-check:before {
  content: "\f00c";
}
.fa-times:before {
  content: "\f00d";
}
.fa-search-plus:before {
  content: "\f00e";
}
.fa-search-minus:before {
  content: "\f010";
}
.fa-power-off:before {
  content: "\f011";
}
.fa-signal:before {
  content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
  content: "\f013";
}
.fa-trash-o:before {
  content: "\f014";
}
.fa-home:before {
  content: "\f015";
}
.fa-file-o:before {
  content: "\f016";
}
.fa-clock-o:before {
  content: "\f017";
}
.fa-road:before {
  content: "\f018";
}
.fa-download:before {
  content: "\f019";
}
.fa-arrow-circle-o-down:before {
  content: "\f01a";
}
.fa-arrow-circle-o-up:before {
  content: "\f01b";
}
.fa-inbox:before {
  content: "\f01c";
}
.fa-play-circle-o:before {
  content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
  content: "\f01e";
}
.fa-refresh:before {
  content: "\f021";
}
.fa-list-alt:before {
  content: "\f022";
}
.fa-lock:before {
  content: "\f023";
}
.fa-flag:before {
  content: "\f024";
}
.fa-headphones:before {
  content: "\f025";
}
.fa-volume-off:before {
  content: "\f026";
}
.fa-volume-down:before {
  content: "\f027";
}
.fa-volume-up:before {
  content: "\f028";
}
.fa-qrcode:before {
  content: "\f029";
}
.fa-barcode:before {
  content: "\f02a";
}
.fa-tag:before {
  content: "\f02b";
}
.fa-tags:before {
  content: "\f02c";
}
.fa-book:before {
  content: "\f02d";
}
.fa-bookmark:before {
  content: "\f02e";
}
.fa-print:before {
  content: "\f02f";
}
.fa-camera:before {
  content: "\f030";
}
.fa-font:before {
  content: "\f031";
}
.fa-bold:before {
  content: "\f032";
}
.fa-italic:before {
  content: "\f033";
}
.fa-text-height:before {
  content: "\f034";
}
.fa-text-width:before {
  content: "\f035";
}
.fa-align-left:before {
  content: "\f036";
}
.fa-align-center:before {
  content: "\f037";
}
.fa-align-right:before {
  content: "\f038";
}
.fa-align-justify:before {
  content: "\f039";
}
.fa-list:before {
  content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
  content: "\f03b";
}
.fa-indent:before {
  content: "\f03c";
}
.fa-video-camera:before {
  content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\f03e";
}
.fa-pencil:before {
  content: "\f040";
}
.fa-map-marker:before {
  content: "\f041";
}
.fa-adjust:before {
  content: "\f042";
}
.fa-tint:before {
  content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\f044";
}
.fa-share-square-o:before {
  content: "\f045";
}
.fa-check-square-o:before {
  content: "\f046";
}
.fa-arrows:before {
  content: "\f047";
}
.fa-step-backward:before {
  content: "\f048";
}
.fa-fast-backward:before {
  content: "\f049";
}
.fa-backward:before {
  content: "\f04a";
}
.fa-play:before {
  content: "\f04b";
}
.fa-pause:before {
  content: "\f04c";
}
.fa-stop:before {
  content: "\f04d";
}
.fa-forward:before {
  content: "\f04e";
}
.fa-fast-forward:before {
  content: "\f050";
}
.fa-step-forward:before {
  content: "\f051";
}
.fa-eject:before {
  content: "\f052";
}
.fa-chevron-left:before {
  content: "\f053";
}
.fa-chevron-right:before {
  content: "\f054";
}
.fa-plus-circle:before {
  content: "\f055";
}
.fa-minus-circle:before {
  content: "\f056";
}
.fa-times-circle:before {
  content: "\f057";
}
.fa-check-circle:before {
  content: "\f058";
}
.fa-question-circle:before {
  content: "\f059";
}
.fa-info-circle:before {
  content: "\f05a";
}
.fa-crosshairs:before {
  content: "\f05b";
}
.fa-times-circle-o:before {
  content: "\f05c";
}
.fa-check-circle-o:before {
  content: "\f05d";
}
.fa-ban:before {
  content: "\f05e";
}
.fa-arrow-left:before {
  content: "\f060";
}
.fa-arrow-right:before {
  content: "\f061";
}
.fa-arrow-up:before {
  content: "\f062";
}
.fa-arrow-down:before {
  content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
  content: "\f064";
}
.fa-expand:before {
  content: "\f065";
}
.fa-compress:before {
  content: "\f066";
}
.fa-plus:before {
  content: "\f067";
}
.fa-minus:before {
  content: "\f068";
}
.fa-asterisk:before {
  content: "\f069";
}
.fa-exclamation-circle:before {
  content: "\f06a";
}
.fa-gift:before {
  content: "\f06b";
}
.fa-leaf:before {
  content: "\f06c";
}
.fa-fire:before {
  content: "\f06d";
}
.fa-eye:before {
  content: "\f06e";
}
.fa-eye-slash:before {
  content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\f071";
}
.fa-plane:before {
  content: "\f072";
}
.fa-calendar:before {
  content: "\f073";
}
.fa-random:before {
  content: "\f074";
}
.fa-comment:before {
  content: "\f075";
}
.fa-magnet:before {
  content: "\f076";
}
.fa-chevron-up:before {
  content: "\f077";
}
.fa-chevron-down:before {
  content: "\f078";
}
.fa-retweet:before {
  content: "\f079";
}
.fa-shopping-cart:before {
  content: "\f07a";
}
.fa-folder:before {
  content: "\f07b";
}
.fa-folder-open:before {
  content: "\f07c";
}
.fa-arrows-v:before {
  content: "\f07d";
}
.fa-arrows-h:before {
  content: "\f07e";
}
.fa-bar-chart-o:before {
  content: "\f080";
}
.fa-twitter-square:before {
  content: "\f081";
}
.fa-facebook-square:before {
  content: "\f082";
}
.fa-camera-retro:before {
  content: "\f083";
}
.fa-key:before {
  content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
  content: "\f085";
}
.fa-comments:before {
  content: "\f086";
}
.fa-thumbs-o-up:before {
  content: "\f087";
}
.fa-thumbs-o-down:before {
  content: "\f088";
}
.fa-star-half:before {
  content: "\f089";
}
.fa-heart-o:before {
  content: "\f08a";
}
.fa-sign-out:before {
  content: "\f08b";
}
.fa-linkedin-square:before {
  content: "\f08c";
}
.fa-thumb-tack:before {
  content: "\f08d";
}
.fa-external-link:before {
  content: "\f08e";
}
.fa-sign-in:before {
  content: "\f090";
}
.fa-trophy:before {
  content: "\f091";
}
.fa-github-square:before {
  content: "\f092";
}
.fa-upload:before {
  content: "\f093";
}
.fa-lemon-o:before {
  content: "\f094";
}
.fa-phone:before {
  content: "\f095";
}
.fa-square-o:before {
  content: "\f096";
}
.fa-bookmark-o:before {
  content: "\f097";
}
.fa-phone-square:before {
  content: "\f098";
}
.fa-twitter:before {
  content: "\f099";
}
.fa-facebook:before {
  content: "\f09a";
}
.fa-github:before {
  content: "\f09b";
}
.fa-unlock:before {
  content: "\f09c";
}
.fa-credit-card:before {
  content: "\f09d";
}
.fa-rss:before {
  content: "\f09e";
}
.fa-hdd-o:before {
  content: "\f0a0";
}
.fa-bullhorn:before {
  content: "\f0a1";
}
.fa-bell:before {
  content: "\f0f3";
}
.fa-certificate:before {
  content: "\f0a3";
}
.fa-hand-o-right:before {
  content: "\f0a4";
}
.fa-hand-o-left:before {
  content: "\f0a5";
}
.fa-hand-o-up:before {
  content: "\f0a6";
}
.fa-hand-o-down:before {
  content: "\f0a7";
}
.fa-arrow-circle-left:before {
  content: "\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\f0aa";
}
.fa-arrow-circle-down:before {
  content: "\f0ab";
}
.fa-globe:before {
  content: "\f0ac";
}
.fa-wrench:before {
  content: "\f0ad";
}
.fa-tasks:before {
  content: "\f0ae";
}
.fa-filter:before {
  content: "\f0b0";
}
.fa-briefcase:before {
  content: "\f0b1";
}
.fa-arrows-alt:before {
  content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
  content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
  content: "\f0c1";
}
.fa-cloud:before {
  content: "\f0c2";
}
.fa-flask:before {
  content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
  content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
  content: "\f0c5";
}
.fa-paperclip:before {
  content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
  content: "\f0c7";
}
.fa-square:before {
  content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\f0c9";
}
.fa-list-ul:before {
  content: "\f0ca";
}
.fa-list-ol:before {
  content: "\f0cb";
}
.fa-strikethrough:before {
  content: "\f0cc";
}
.fa-underline:before {
  content: "\f0cd";
}
.fa-table:before {
  content: "\f0ce";
}
.fa-magic:before {
  content: "\f0d0";
}
.fa-truck:before {
  content: "\f0d1";
}
.fa-pinterest:before {
  content: "\f0d2";
}
.fa-pinterest-square:before {
  content: "\f0d3";
}
.fa-google-plus-square:before {
  content: "\f0d4";
}
.fa-google-plus:before {
  content: "\f0d5";
}
.fa-money:before {
  content: "\f0d6";
}
.fa-caret-down:before {
  content: "\f0d7";
}
.fa-caret-up:before {
  content: "\f0d8";
}
.fa-caret-left:before {
  content: "\f0d9";
}
.fa-caret-right:before {
  content: "\f0da";
}
.fa-columns:before {
  content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
  content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\f0de";
}
.fa-envelope:before {
  content: "\f0e0";
}
.fa-linkedin:before {
  content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
  content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
  content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
  content: "\f0e4";
}
.fa-comment-o:before {
  content: "\f0e5";
}
.fa-comments-o:before {
  content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
  content: "\f0e7";
}
.fa-sitemap:before {
  content: "\f0e8";
}
.fa-umbrella:before {
  content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
  content: "\f0ea";
}
.fa-lightbulb-o:before {
  content: "\f0eb";
}
.fa-exchange:before {
  content: "\f0ec";
}
.fa-cloud-download:before {
  content: "\f0ed";
}
.fa-cloud-upload:before {
  content: "\f0ee";
}
.fa-user-md:before {
  content: "\f0f0";
}
.fa-stethoscope:before {
  content: "\f0f1";
}
.fa-suitcase:before {
  content: "\f0f2";
}
.fa-bell-o:before {
  content: "\f0a2";
}
.fa-coffee:before {
  content: "\f0f4";
}
.fa-cutlery:before {
  content: "\f0f5";
}
.fa-file-text-o:before {
  content: "\f0f6";
}
.fa-building-o:before {
  content: "\f0f7";
}
.fa-hospital-o:before {
  content: "\f0f8";
}
.fa-ambulance:before {
  content: "\f0f9";
}
.fa-medkit:before {
  content: "\f0fa";
}
.fa-fighter-jet:before {
  content: "\f0fb";
}
.fa-beer:before {
  content: "\f0fc";
}
.fa-h-square:before {
  content: "\f0fd";
}
.fa-plus-square:before {
  content: "\f0fe";
}
.fa-angle-double-left:before {
  content: "\f100";
}
.fa-angle-double-right:before {
  content: "\f101";
}
.fa-angle-double-up:before {
  content: "\f102";
}
.fa-angle-double-down:before {
  content: "\f103";
}
.fa-angle-left:before {
  content: "\f104";
}
.fa-angle-right:before {
  content: "\f105";
}
.fa-angle-up:before {
  content: "\f106";
}
.fa-angle-down:before {
  content: "\f107";
}
.fa-desktop:before {
  content: "\f108";
}
.fa-laptop:before {
  content: "\f109";
}
.fa-tablet:before {
  content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\f10b";
}
.fa-circle-o:before {
  content: "\f10c";
}
.fa-quote-left:before {
  content: "\f10d";
}
.fa-quote-right:before {
  content: "\f10e";
}
.fa-spinner:before {
  content: "\f110";
}
.fa-circle:before {
  content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
  content: "\f112";
}
.fa-github-alt:before {
  content: "\f113";
}
.fa-folder-o:before {
  content: "\f114";
}
.fa-folder-open-o:before {
  content: "\f115";
}
.fa-smile-o:before {
  content: "\f118";
}
.fa-frown-o:before {
  content: "\f119";
}
.fa-meh-o:before {
  content: "\f11a";
}
.fa-gamepad:before {
  content: "\f11b";
}
.fa-keyboard-o:before {
  content: "\f11c";
}
.fa-flag-o:before {
  content: "\f11d";
}
.fa-flag-checkered:before {
  content: "\f11e";
}
.fa-terminal:before {
  content: "\f120";
}
.fa-code:before {
  content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\f123";
}
.fa-location-arrow:before {
  content: "\f124";
}
.fa-crop:before {
  content: "\f125";
}
.fa-code-fork:before {
  content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
  content: "\f127";
}
.fa-question:before {
  content: "\f128";
}
.fa-info:before {
  content: "\f129";
}
.fa-exclamation:before {
  content: "\f12a";
}
.fa-superscript:before {
  content: "\f12b";
}
.fa-subscript:before {
  content: "\f12c";
}
.fa-eraser:before {
  content: "\f12d";
}
.fa-puzzle-piece:before {
  content: "\f12e";
}
.fa-microphone:before {
  content: "\f130";
}
.fa-microphone-slash:before {
  content: "\f131";
}
.fa-shield:before {
  content: "\f132";
}
.fa-calendar-o:before {
  content: "\f133";
}
.fa-fire-extinguisher:before {
  content: "\f134";
}
.fa-rocket:before {
  content: "\f135";
}
.fa-maxcdn:before {
  content: "\f136";
}
.fa-chevron-circle-left:before {
  content: "\f137";
}
.fa-chevron-circle-right:before {
  content: "\f138";
}
.fa-chevron-circle-up:before {
  content: "\f139";
}
.fa-chevron-circle-down:before {
  content: "\f13a";
}
.fa-html5:before {
  content: "\f13b";
}
.fa-css3:before {
  content: "\f13c";
}
.fa-anchor:before {
  content: "\f13d";
}
.fa-unlock-alt:before {
  content: "\f13e";
}
.fa-bullseye:before {
  content: "\f140";
}
.fa-ellipsis-h:before {
  content: "\f141";
}
.fa-ellipsis-v:before {
  content: "\f142";
}
.fa-rss-square:before {
  content: "\f143";
}
.fa-play-circle:before {
  content: "\f144";
}
.fa-ticket:before {
  content: "\f145";
}
.fa-minus-square:before {
  content: "\f146";
}
.fa-minus-square-o:before {
  content: "\f147";
}
.fa-level-up:before {
  content: "\f148";
}
.fa-level-down:before {
  content: "\f149";
}
.fa-check-square:before {
  content: "\f14a";
}
.fa-pencil-square:before {
  content: "\f14b";
}
.fa-external-link-square:before {
  content: "\f14c";
}
.fa-share-square:before {
  content: "\f14d";
}
.fa-compass:before {
  content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
  content: "\f153";
}
.fa-gbp:before {
  content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
  content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
  content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\f158";
}
.fa-won:before,
.fa-krw:before {
  content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
  content: "\f15a";
}
.fa-file:before {
  content: "\f15b";
}
.fa-file-text:before {
  content: "\f15c";
}
.fa-sort-alpha-asc:before {
  content: "\f15d";
}
.fa-sort-alpha-desc:before {
  content: "\f15e";
}
.fa-sort-amount-asc:before {
  content: "\f160";
}
.fa-sort-amount-desc:before {
  content: "\f161";
}
.fa-sort-numeric-asc:before {
  content: "\f162";
}
.fa-sort-numeric-desc:before {
  content: "\f163";
}
.fa-thumbs-up:before {
  content: "\f164";
}
.fa-thumbs-down:before {
  content: "\f165";
}
.fa-youtube-square:before {
  content: "\f166";
}
.fa-youtube:before {
  content: "\f167";
}
.fa-xing:before {
  content: "\f168";
}
.fa-xing-square:before {
  content: "\f169";
}
.fa-youtube-play:before {
  content: "\f16a";
}
.fa-dropbox:before {
  content: "\f16b";
}
.fa-stack-overflow:before {
  content: "\f16c";
}
.fa-instagram:before {
  content: "\f16d";
}
.fa-flickr:before {
  content: "\f16e";
}
.fa-adn:before {
  content: "\f170";
}
.fa-bitbucket:before {
  content: "\f171";
}
.fa-bitbucket-square:before {
  content: "\f172";
}
.fa-tumblr:before {
  content: "\f173";
}
.fa-tumblr-square:before {
  content: "\f174";
}
.fa-long-arrow-down:before {
  content: "\f175";
}
.fa-long-arrow-up:before {
  content: "\f176";
}
.fa-long-arrow-left:before {
  content: "\f177";
}
.fa-long-arrow-right:before {
  content: "\f178";
}
.fa-apple:before {
  content: "\f179";
}
.fa-windows:before {
  content: "\f17a";
}
.fa-android:before {
  content: "\f17b";
}
.fa-linux:before {
  content: "\f17c";
}
.fa-dribbble:before {
  content: "\f17d";
}
.fa-skype:before {
  content: "\f17e";
}
.fa-foursquare:before {
  content: "\f180";
}
.fa-trello:before {
  content: "\f181";
}
.fa-female:before {
  content: "\f182";
}
.fa-male:before {
  content: "\f183";
}
.fa-gittip:before {
  content: "\f184";
}
.fa-sun-o:before {
  content: "\f185";
}
.fa-moon-o:before {
  content: "\f186";
}
.fa-archive:before {
  content: "\f187";
}
.fa-bug:before {
  content: "\f188";
}
.fa-vk:before {
  content: "\f189";
}
.fa-weibo:before {
  content: "\f18a";
}
.fa-renren:before {
  content: "\f18b";
}
.fa-pagelines:before {
  content: "\f18c";
}
.fa-stack-exchange:before {
  content: "\f18d";
}
.fa-arrow-circle-o-right:before {
  content: "\f18e";
}
.fa-arrow-circle-o-left:before {
  content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\f191";
}
.fa-dot-circle-o:before {
  content: "\f192";
}
.fa-wheelchair:before {
  content: "\f193";
}
.fa-vimeo-square:before {
  content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
  content: "\f195";
}
.fa-plus-square-o:before {
  content: "\f196";
}
.fa-space-shuttle:before {
  content: "\f197";
}
.fa-slack:before {
  content: "\f198";
}
.fa-envelope-square:before {
  content: "\f199";
}
.fa-wordpress:before {
  content: "\f19a";
}
.fa-openid:before {
  content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\f19d";
}
.fa-yahoo:before {
  content: "\f19e";
}
.fa-google:before {
  content: "\f1a0";
}
.fa-reddit:before {
  content: "\f1a1";
}
.fa-reddit-square:before {
  content: "\f1a2";
}
.fa-stumbleupon-circle:before {
  content: "\f1a3";
}
.fa-stumbleupon:before {
  content: "\f1a4";
}
.fa-delicious:before {
  content: "\f1a5";
}
.fa-digg:before {
  content: "\f1a6";
}
.fa-pied-piper-square:before,
.fa-pied-piper:before {
  content: "\f1a7";
}
.fa-pied-piper-alt:before {
  content: "\f1a8";
}
.fa-drupal:before {
  content: "\f1a9";
}
.fa-joomla:before {
  content: "\f1aa";
}
.fa-language:before {
  content: "\f1ab";
}
.fa-fax:before {
  content: "\f1ac";
}
.fa-building:before {
  content: "\f1ad";
}
.fa-child:before {
  content: "\f1ae";
}
.fa-paw:before {
  content: "\f1b0";
}
.fa-spoon:before {
  content: "\f1b1";
}
.fa-cube:before {
  content: "\f1b2";
}
.fa-cubes:before {
  content: "\f1b3";
}
.fa-behance:before {
  content: "\f1b4";
}
.fa-behance-square:before {
  content: "\f1b5";
}
.fa-steam:before {
  content: "\f1b6";
}
.fa-steam-square:before {
  content: "\f1b7";
}
.fa-recycle:before {
  content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
  content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
  content: "\f1ba";
}
.fa-tree:before {
  content: "\f1bb";
}
.fa-spotify:before {
  content: "\f1bc";
}
.fa-deviantart:before {
  content: "\f1bd";
}
.fa-soundcloud:before {
  content: "\f1be";
}
.fa-database:before {
  content: "\f1c0";
}
.fa-file-pdf-o:before {
  content: "\f1c1";
}
.fa-file-word-o:before {
  content: "\f1c2";
}
.fa-file-excel-o:before {
  content: "\f1c3";
}
.fa-file-powerpoint-o:before {
  content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\f1c8";
}
.fa-file-code-o:before {
  content: "\f1c9";
}
.fa-vine:before {
  content: "\f1ca";
}
.fa-codepen:before {
  content: "\f1cb";
}
.fa-jsfiddle:before {
  content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\f1cd";
}
.fa-circle-o-notch:before {
  content: "\f1ce";
}
.fa-ra:before,
.fa-rebel:before {
  content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
  content: "\f1d1";
}
.fa-git-square:before {
  content: "\f1d2";
}
.fa-git:before {
  content: "\f1d3";
}
.fa-hacker-news:before {
  content: "\f1d4";
}
.fa-tencent-weibo:before {
  content: "\f1d5";
}
.fa-qq:before {
  content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
  content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
  content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\f1d9";
}
.fa-history:before {
  content: "\f1da";
}
.fa-circle-thin:before {
  content: "\f1db";
}
.fa-header:before {
  content: "\f1dc";
}
.fa-paragraph:before {
  content: "\f1dd";
}
.fa-sliders:before {
  content: "\f1de";
}
.fa-share-alt:before {
  content: "\f1e0";
}
.fa-share-alt-square:before {
  content: "\f1e1";
}
.fa-bomb:before {
  content: "\f1e2";
}
:host {
  display: inline-block;
  width: 100%;
  background-color: transparent;
  font-size: 1em;
  color: rgba(69, 69, 69, 0.85);
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
  box-sizing: border-box;
}
:host #icon {
  margin-right: 0.25em;
  line-height: inherit;
}
:host #field {
  display: flex;
  align-items: center;
  margin: 0;
  padding: 0.65em 0.65em;
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
}
:host #field.focused {
  color: #454545;
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
:host #field.disabled {
  color: rgba(69, 69, 69, 0.33);
}
:host #field input,
:host #field textarea {
  flex: 1;
  height: 100%;
  background-color: transparent;
  font-size: 1em;
  outline: none;
  border: none;
  margin: 0;
  padding: 0;
  color: rgba(69, 69, 69, 0.85);
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
}
:host #field input:focus,
:host #field textarea:focus {
  color: #454545;
}
:host(.inverted) {
  color: rgba(255, 255, 255, 0.85);
  border-color: rgba(255, 255, 255, 0.33);
}
:host(.inverted) #field.focused {
  color: #ffffff;
  border-color: rgba(255, 255, 255, 0.61);
  box-shadow: 0.3em 0em 0em 0em rgba(255, 255, 255, 0.61) inset;
  -webkit-box-shadow: 0.3em 0em 0em 0em rgba(255, 255, 255, 0.61) inset;
}
:host(.inverted) #field.disabled {
  color: rgba(255, 255, 255, 0.33);
}
:host(.inverted) #field input,
:host(.inverted) #field textarea {
  color: rgba(255, 255, 255, 0.85);
}
:host(.inverted) #field input:focus,
:host(.inverted) #field textarea:focus {
  color: #ffffff;
}
input,
textarea {
  font-family: inherit;
  font-weight: inherit;
}
</style>
  <section id="field" on-keydown="{{keydown}}" class="{{ {disabled: disabled} | tokenList }}">
    <template if="{{icon}}">
      <i id="icon" class="fa {{icon}} {{iconAnimation}}"></i>
    </template>
    <template if="{{multiline}}">
      <textarea id="input" value="{{value}}" disabled?="{{disabled}}" placeholder="{{placeholder}}" aria-labelledby="placeholder" aria-invalid="{{invalid}}" on-change="{{change}}" on-focus="{{inputFocus}}" on-blur="{{blur}}" on-keyup="keyup" on-cut="cut" on-paste="paste" on-drop="drop" autocorrect="{{autocorrect}}" autocapitalize="{{autocapitalize}}" autocomplete="{{autocomplete}}" autofocus?="{{autofocus}}"></textarea>
    </template>
    <template if="{{!multiline}}">
      <input type="{{type}}" id="input" value="{{value}}" disabled?="{{disabled}}" placeholder="{{placeholder}}" autocorrect="{{autocorrect}}" autocapitalize="{{autocapitalize}}" autocomplete="{{autocomplete}}" aria-labelledby="placeholder" aria-invalid="{{invalid}}" on-change="{{change}}" on-focus="{{inputFocus}}" on-blur="{{blur}}" on-keyup="keyup" autofocus?="{{autofocus}}">
    </template>
  </section>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-input/src/ui-input.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-input", {
            bubble: function(evt) {
                return this.fire(evt.type, null, this, false);
            },
            blur: function(evt) {
                this.$.field.classList.remove("focused");
                return this.bubble(evt);
            },
            inputFocus: function(evt) {
                this.$.field.classList.add("focused");
                return this.bubble(evt);
            },
            focus: function() {
                return this.$.input.focus();
            },
            change: function(evt) {
                if (this.multiline != null) {
                    this.resize();
                }
                this.value = evt.target.value;
                return this.bubble(evt);
            },
            keyup: function(evt) {
                return this.value = evt.target.value;
            },
            keydown: function(evt) {
                if (this.multiline != null) {
                    this.resize();
                }
                if (evt.keyCode === 27) {
                    return this.value = null;
                }
            },
            cut: function(evt) {
                if (this.multiline != null) {
                    return this.resize();
                }
            },
            paste: function(evt) {
                if (this.multiline != null) {
                    return this.resize();
                }
            },
            drop: function(evt) {
                if (this.multiline != null) {
                    return this.resize();
                }
            },
            resize: function() {
                var textarea;
                textarea = this.shadowRoot.querySelector("textarea");
                return setTimeout(function() {
                    textarea.style.height = "auto";
                    return textarea.style.height = "" + textarea.scrollHeight + "px";
                });
            },
            created: function() {
                this.type = "text";
                this.autocomplete = "off";
                this.autocorrect = "off";
                return this.autocapitalize = "none";
            },
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-overlay" attributes="detail hover">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
:host {
  display: inline-block;
  position: relative;
}
#all {
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
}
#overlay {
  opacity: 0;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 1000;
  transition: opacity 0.2s ease-out;
  text-align: center;
}
#overlay.show {
  opacity: 1;
  transition: opacity 0.2s ease-out;
}
</style>
  <section id="all" on-mouseenter="{{showIt}}" on-mouseleave="{{hideIt}}" on-click="{{click}}">
    <section id="overlay" class="show">
      <content select="[overlay]" class="{{hoverclass}}"></content>
    </section>
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-overlay/src/ui-overlay.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        module.exports = function(element, callback) {
            function addResizeListener(element, callback) {
                if (window.OverflowEvent) {
                    element.addEventListener("overflowchanged", function(e) {
                        callback.call(this, e);
                    });
                } else {
                    element.addEventListener("overflow", function(e) {
                        callback.call(this, e);
                    });
                    element.addEventListener("underflow", function(e) {
                        callback.call(this, e);
                    });
                }
            }
            function EventQueue() {
                this.q = [];
                this.add = function(ev) {
                    this.q.push(ev);
                };
                var i, j;
                this.call = function() {
                    for (i = 0, j = this.q.length; i < j; i++) {
                        this.q[i].call();
                    }
                };
            }
            function getComputedStyle(element, prop) {
                if (element.currentStyle) {
                    return element.currentStyle[prop];
                } else if (window.getComputedStyle) {
                    return window.getComputedStyle(element, null).getPropertyValue(prop);
                } else {
                    return element.style[prop];
                }
            }
            function attachResizeEvent(element, resized) {
                if (!element.resizedAttached) {
                    element.resizedAttached = new EventQueue();
                    element.resizedAttached.add(resized);
                } else if (element.resizedAttached) {
                    element.resizedAttached.add(resized);
                    return;
                }
                var myResized = function() {
                    if (setupSensor()) {
                        element.resizedAttached.call();
                    }
                };
                element.resizeSensor = document.createElement("div");
                element.resizeSensor.className = "resize-sensor";
                var style = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1;";
                element.resizeSensor.style.cssText = style;
                element.resizeSensor.innerHTML = '<div class="resize-sensor-overflow" style="' + style + '">' + "<div></div>" + "</div>" + '<div class="resize-sensor-underflow" style="' + style + '">' + "<div></div>" + "</div>";
                element.appendChild(element.resizeSensor);
                if ("absolute" !== getComputedStyle(element, "position")) {
                    element.style.position = "relative";
                }
                var x = -1, y = -1, firstStyle = element.resizeSensor.firstElementChild.firstChild.style, lastStyle = element.resizeSensor.lastElementChild.firstChild.style;
                function setupSensor() {
                    var change = false, width = element.resizeSensor.offsetWidth, height = element.resizeSensor.offsetHeight;
                    if (x != width) {
                        firstStyle.width = width - 1 + "px";
                        lastStyle.width = width + 1 + "px";
                        change = true;
                        x = width;
                    }
                    if (y != height) {
                        firstStyle.height = height - 1 + "px";
                        lastStyle.height = height + 1 + "px";
                        change = true;
                        y = height;
                    }
                    return change;
                }
                setupSensor();
                addResizeListener(element.resizeSensor, myResized);
                addResizeListener(element.resizeSensor.firstElementChild, myResized);
                addResizeListener(element.resizeSensor.lastElementChild, myResized);
            }
            if ("array" === typeof element || "undefined" !== typeof jQuery && element instanceof jQuery || "undefined" !== typeof Elements && element instanceof Elements) {
                var i = 0, j = element.length;
                for (;i < j; i++) {
                    attachResizeEvent(element[i], callback);
                }
            } else {
                attachResizeEvent(element, callback);
            }
        };
    }, {} ],
    2: [ function(require, module, exports) {
        var ResizeSensor;
        ResizeSensor = require("./ResizeSensor");
        Polymer("ui-overlay", {
            click: function(evt) {
                evt.preventDefault();
                evt.stopPropagation();
                return this.fire("click", this.detail);
            },
            showIt: function() {
                this.resized();
                if (this.hover != null) {
                    return this.$.overlay.classList.add("show");
                }
            },
            hideIt: function() {
                if (this.hover != null) {
                    return this.$.overlay.classList.remove("show");
                }
            },
            resized: function() {
                var size, _ref;
                size = Math.min(this.clientWidth, this.clientHeight) / Math.max(1, (_ref = window.getComputedStyle(this.$.overlay, "before")["content"]) != null ? _ref.length : void 0);
                this.$.overlay.style["font-size"] = "" + size + "px";
                return this.$.overlay.style["line-height"] = "" + size + "px";
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                if (this.hover != null) {
                    this.$.overlay.classList.remove("show");
                }
                this.sensor = new ResizeSensor(this.$.overlay, function(_this) {
                    return function() {
                        return _this.resized();
                    };
                }(this));
                return this.resized();
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {
        "./ResizeSensor": 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<polymer-element name="ui-tooltip" attributes="label display" on-mouseenter="mouseenter" on-mouseleave="mouseleave">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
:host {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  perspective: 1000;
}
#tooltip {
  position: absolute;
  display: flex;
  white-space: nowrap;
  font-size: 0.85rem;
  border: 1px solid rgba(51, 51, 51, 0.33);
  color: #454545;
  font-weight: 200;
  background-color: #ffffff;
  z-index: 1000;
  transform-style: preserve-3d;
  padding: 0.8em 1.2em;
  opacity: 85%;
  box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.1);
  -webkit-box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.1);
  transition: 0.2s ease-out;
  -webkit-transition: 0.2s ease-out;
  transform: rotateX(0deg);
  -webkit-transform: rotateX(0deg);
}
#tooltip.hidden {
  transform: rotateX(90deg);
  -webkit-transform: rotateX(90deg);
  opacity: 0;
}
#tooltip:before {
  position: absolute;
  box-sizing: border-box;
  content: "";
  width: 0.75em;
  height: 0.75em;
  border-color: #ffffff;
  background-color: #ffffff;
  transform: rotate(45deg);
  -webkit-transform: rotate(45deg);
  z-index: 1002;
}
#tooltip.down {
  top: calc(100%);
  margin-top: 0.5em;
}
#tooltip.up {
  bottom: calc(100%);
  margin-bottom: 0.5em;
}
#tooltip.left {
  right: 25%;
}
#tooltip.right {
  left: 25%;
}
#tooltip.right.down:before {
  top: -0.4em;
  left: 0.4em;
  border-left: 1px solid rgba(51, 51, 51, 0.33);
  border-top: 1px solid rgba(51, 51, 51, 0.33);
}
#tooltip.left.down:before {
  top: -0.4em;
  right: 0.4em;
  border-left: 1px solid rgba(51, 51, 51, 0.33);
  border-top: 1px solid rgba(51, 51, 51, 0.33);
}
#tooltip.right.up:before {
  bottom: -0.4em;
  left: 0.4em;
  border-right: 1px solid rgba(51, 51, 51, 0.33);
  border-bottom: 1px solid rgba(51, 51, 51, 0.33);
  box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.1);
  -webkit-box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.1);
}
#tooltip.left.up:before {
  bottom: -0.4em;
  right: 0.4em;
  border-right: 1px solid rgba(51, 51, 51, 0.33);
  border-bottom: 1px solid rgba(51, 51, 51, 0.33);
  box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.1);
  -webkit-box-shadow: 1px 1px 1px rgba(51, 51, 51, 0.1);
}
</style>
  <div id="tooltip" class="{{display}} hidden">
    <content select="[tip]">{{label}}</content>
  </div>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-tooltip/src/ui-tooltip.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-tooltip", {
            position: function() {
                var body, offsetX, offsetY, tip, xStep, yStep;
                tip = this.getBoundingClientRect();
                body = document.querySelector("body").getBoundingClientRect();
                xStep = document.documentElement.clientWidth / 3;
                yStep = document.documentElement.clientHeight / 3;
                offsetX = "left";
                if (tip.left < xStep * 2) {
                    offsetX = "right";
                }
                offsetY = "up";
                if (tip.top < yStep * 2) {
                    offsetY = "down";
                }
                return this.display = "" + offsetX + " " + offsetY;
            },
            mouseenter: function() {
                this.position();
                return this.$.tooltip.classList.remove("hidden");
            },
            mouseleave: function() {
                this.position();
                return this.$.tooltip.classList.add("hidden");
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                return this.position();
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>




<style>.hide {
  display: none !important;
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
ui-typeahead[selected] ui-typeahead-item:not([selected]) {
  display: none;
}
ui-typeahead[selected] ui-typeahead-item[selected]::before {
  content: '(change)';
  float: right;
}
</style>
<polymer-element name="ui-typeahead" attributes="text icon placeholder debounce data">
<template>
  <style>.hide {
  display: none !important;
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: block;
  position: relative;
  box-sizing: border-box;
}
:host ui-input {
  border: 0;
}
:host([selected]) #results {
  top: 0;
  overflow: visible;
  background-color: transparent;
}
#results {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background-color: white;
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  overflow-y: scroll;
  z-index: 999;
}
#selected::before {
  float: right;
  content: "(change)";
}
</style>
  <ui-input fadeout="" id="input" icon="{{icon}}" placeholder="{{placeholder}}" value="{{text}}"></ui-input>

  <section id="results">
    <content select="ui-typeahead-item">
    </content>
  </section>

</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-typeahead/src/ui-typeahead.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var undefined;
                var arrayPool = [], objectPool = [];
                var idCounter = 0;
                var keyPrefix = +new Date() + "";
                var largeArraySize = 75;
                var maxPoolSize = 40;
                var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reFuncName = /^\s*function[ \n\r\t]+\w/;
                var reInterpolate = /<%=([\s\S]+?)%>/g;
                var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
                var reNoMatch = /($^)/;
                var reThis = /\bthis\b/;
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
                var contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
                var templateCounter = 0;
                var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
                var debounceOptions = {
                    leading: false,
                    maxWait: 0,
                    trailing: false
                };
                var descriptor = {
                    configurable: false,
                    enumerable: false,
                    value: null,
                    writable: false
                };
                var objectTypes = {
                    "boolean": false,
                    "function": true,
                    object: true,
                    number: false,
                    string: false,
                    undefined: false
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "	": "t",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var root = objectTypes[typeof window] && window || this;
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;
                    if (type == "boolean" || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != "number" && type != "string") {
                        type = "object";
                    }
                    var key = type == "number" ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];
                    return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
                }
                function cachePush(value) {
                    var cache = this.cache, type = typeof value;
                    if (type == "boolean" || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != "number" && type != "string") {
                            type = "object";
                        }
                        var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                        if (type == "object") {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }
                function compareAscending(a, b) {
                    var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
                    while (++index < length) {
                        var value = ac[index], other = bc[index];
                        if (value !== other) {
                            if (value > other || typeof value == "undefined") {
                                return 1;
                            }
                            if (value < other || typeof other == "undefined") {
                                return -1;
                            }
                        }
                    }
                    return a.index - b.index;
                }
                function createCache(array) {
                    var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
                    if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
                        return false;
                    }
                    var cache = getObject();
                    cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;
                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }
                function escapeStringChar(match) {
                    return "\\" + stringEscapes[match];
                }
                function getArray() {
                    return arrayPool.pop() || [];
                }
                function getObject() {
                    return objectPool.pop() || {
                        array: null,
                        cache: null,
                        criteria: null,
                        "false": false,
                        index: 0,
                        "null": false,
                        number: null,
                        object: null,
                        push: null,
                        string: null,
                        "true": false,
                        undefined: false,
                        value: null
                    };
                }
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == "undefined") {
                        end = array ? array.length : 0;
                    }
                    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }
                function runInContext(context) {
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayRef = [];
                    var objectProto = Object.prototype;
                    var oldDash = context._;
                    var toString = objectProto.toString;
                    var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
                    var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
                    var defineProperty = function() {
                        try {
                            var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }();
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;
                    function lodash(value) {
                        return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
                    }
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    lodashWrapper.prototype = lodash.prototype;
                    var support = lodash.support = {};
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
                    support.funcNames = typeof Function.name == "string";
                    lodash.templateSettings = {
                        escape: /<%-([\s\S]+?)%>/g,
                        evaluate: /<%([\s\S]+?)%>/g,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    function baseBind(bindData) {
                        var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
                        function bound() {
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (this instanceof bound) {
                                var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != "undefined") {
                                return result;
                            }
                        }
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                              case boolClass:
                              case dateClass:
                                return new ctor(+value);

                              case numberClass:
                              case stringClass:
                                return new ctor(value);

                              case regexpClass:
                                result = ctor(value.source, reFlags.exec(value));
                                result.lastIndex = value.lastIndex;
                                return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());
                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        if (isArr) {
                            if (hasOwnProperty.call(value, "index")) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, "input")) {
                                result.input = value.input;
                            }
                        }
                        if (!isDeep) {
                            return result;
                        }
                        stackA.push(value);
                        stackB.push(result);
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    if (!nativeCreate) {
                        baseCreate = function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object();
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }();
                    }
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != "function") {
                            return identity;
                        }
                        if (typeof thisArg == "undefined" || !("prototype" in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == "undefined") {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        if (bindData === false || bindData !== true && bindData[1] & 1) {
                            return func;
                        }
                        switch (argCount) {
                          case 1:
                            return function(value) {
                                return func.call(thisArg, value);
                            };

                          case 2:
                            return function(a, b) {
                                return func.call(thisArg, a, b);
                            };

                          case 3:
                            return function(value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                          case 4:
                            return function(accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };
                        }
                        return bind(func, thisArg);
                    }
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseDifference(array, values) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1, valLength = value.length, resIndex = result.length;
                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != "undefined") {
                                return !!result;
                            }
                        }
                        if (a === b) {
                            return a !== 0 || 1 / a == 1 / b;
                        }
                        var type = typeof a, otherType = typeof b;
                        if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                            return false;
                        }
                        if (a == null || b == null) {
                            return a === b;
                        }
                        var className = toString.call(a), otherClass = toString.call(b);
                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                          case boolClass:
                          case dateClass:
                            return +a == +b;

                          case numberClass:
                            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

                          case regexpClass:
                          case stringClass:
                            return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            if (className != objectClass) {
                                return false;
                            }
                            var ctorA = a.constructor, ctorB = b.constructor;
                            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                                return false;
                            }
                        }
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;
                        stackA.push(a);
                        stackB.push(b);
                        if (isArr) {
                            length = a.length;
                            size = b.length;
                            result = size == length;
                            if (result || isWhere) {
                                while (size--) {
                                    var index = length, value = b[size];
                                    if (isWhere) {
                                        while (index--) {
                                            if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    size++;
                                    return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                                }
                            });
                            if (result && !isWhere) {
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        return result = --size > -1;
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found, isArr, result = source, value = object[key];
                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if (found = stackA[stackLength] == source) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if (isShallow = typeof result != "undefined") {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                    }
                                    stackA.push(source);
                                    stackB.push(value);
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == "undefined") {
                                        result = source;
                                    }
                                }
                                if (typeof result != "undefined") {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }
                    function baseUniq(array, isSorted, callback) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index], computed = callback ? callback(value, index, array) : value;
                            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);
                            var index = -1, length = collection ? collection.length : 0;
                            if (typeof length == "number") {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError();
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
                        return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
                    }
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }
                    function isNative(value) {
                        return typeof value == "function" && reNative.test(value);
                    }
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, "__bindData__", descriptor);
                    };
                    function shimIsPlainObject(value) {
                        var ctor, result;
                        if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
                        isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == "undefined" || hasOwnProperty.call(value, result);
                    }
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }
                    function isArguments(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
                    }
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
                    };
                    var shimKeys = function(object) {
                        var index, iterable = object, result = [];
                        if (!iterable) return result;
                        if (!objectTypes[typeof object]) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result;
                    };
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };
                    var htmlEscapes = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    var htmlUnescapes = invert(htmlEscapes);
                    var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
                    var assign = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function clone(value, isDeep, callback, thisArg) {
                        if (typeof isDeep != "boolean" && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }
                    var defaults = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == "undefined") result[index] = iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];
                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });
                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object), length = props.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }
                    function invert(object) {
                        var index = -1, props = keys(object), length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }
                    function isBoolean(value) {
                        return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
                    }
                    function isDate(value) {
                        return value && typeof value == "object" && toString.call(value) == dateClass || false;
                    }
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value), length = value.length;
                        if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return result = false;
                        });
                        return result;
                    }
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
                    }
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }
                    function isFunction(value) {
                        return typeof value == "function";
                    }
                    function isObject(value) {
                        return !!(value && objectTypes[typeof value]);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
                    }
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                    };
                    function isRegExp(value) {
                        return value && typeof value == "object" && toString.call(value) == regexpClass || false;
                    }
                    function isString(value) {
                        return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
                    }
                    function isUndefined(value) {
                        return typeof value == "undefined";
                    }
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }
                    function merge(object) {
                        var args = arguments, length = 2;
                        if (!isObject(object)) {
                            return object;
                        }
                        if (typeof args[2] != "number") {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == "function") {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == "function") {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function pairs(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            var key = props[index];
                            result[index] = [ key, object[key] ];
                        }
                        return result;
                    }
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }
                    function values(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }
                    function at(collection) {
                        var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }
                    function contains(collection, target, fromIndex) {
                        var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == "number") {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                    });
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return result = !!callback(value, index, collection);
                            });
                        }
                        return result;
                    }
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }
                    function forEach(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }
                    function map(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    function min(collection, callback, thisArg) {
                        var computed = Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    var pluck = map;
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        var index = -1, length = collection.length;
                        if (typeof length == "number") {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                            });
                        }
                        return accumulator;
                    }
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != "number") {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }
                    function shuffle(collection) {
                        var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == "number" ? length : keys(collection).length;
                    }
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (result = callback(collection[index], index, collection)) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }
                    function sortBy(collection, callback, thisArg) {
                        var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });
                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }
                    function toArray(collection) {
                        if (collection && typeof collection.length == "number") {
                            return slice(collection);
                        }
                        return values(collection);
                    }
                    var where = filter;
                    function compact(array) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }
                    function findIndex(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function first(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }
                    function flatten(array, isShallow, callback, thisArg) {
                        if (typeof isShallow != "boolean" && isShallow != null) {
                            thisArg = callback;
                            callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == "number") {
                            var length = array ? array.length : 0;
                            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }
                    function initial(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }
                    function intersection() {
                        var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0], index = -1, length = array ? array.length : 0, result = [];
                        outer: while (++index < length) {
                            var cache = caches[0];
                            value = array[index];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                argsIndex = argsLength;
                                (cache || seen).push(value);
                                while (--argsIndex) {
                                    cache = caches[argsIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                        }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }
                    function last(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == "number") {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function pull(array) {
                        var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
                        while (++argsIndex < argsLength) {
                            var index = -1, value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == "number" ? step : +step || 1;
                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function remove(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }
                    function rest(array, callback, thisArg) {
                        if (typeof callback != "number" && callback != null) {
                            var n = 0, index = -1, length = array ? array.length : 0;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0, high = array ? array.length : low;
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);
                        while (low < high) {
                            var mid = low + high >>> 1;
                            callback(array[mid]) < value ? low = mid + 1 : high = mid;
                        }
                        return low;
                    }
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }
                    function uniq(array, isSorted, callback, thisArg) {
                        if (typeof isSorted != "boolean" && isSorted != null) {
                            thisArg = callback;
                            callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }
                    function xor() {
                        var index = -1, length = arguments.length;
                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                            }
                        }
                        return result || [];
                    }
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }
                    function zipObject(keys, values) {
                        var index = -1, length = keys ? keys.length : 0, result = {};
                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function bind(func, thisArg) {
                        return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
                    }
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }
                    function bindKey(object, key) {
                        return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
                    }
                    function compose() {
                        var funcs = arguments, length = funcs.length;
                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError();
                            }
                        }
                        return function() {
                            var args = arguments, length = funcs.length;
                            while (length--) {
                                args = [ funcs[length].apply(this, args) ];
                            }
                            return args[0];
                        };
                    }
                    function curry(func, arity) {
                        arity = typeof arity == "number" ? arity : +arity || func.length;
                        return createWrapper(func, 4, null, null, null, arity);
                    }
                    function debounce(func, wait, options) {
                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };
                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || maxWait !== wait) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };
                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);
                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var memoized = function() {
                            var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                        };
                        memoized.cache = {};
                        return memoized;
                    }
                    function once(func) {
                        var ran, result;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);
                            func = null;
                            return result;
                        };
                    }
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = "leading" in options ? options.leading : leading;
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;
                        return debounce(func, wait, debounceOptions);
                    }
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [ value ]);
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == "function") {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        if (type != "object") {
                            return property(func);
                        }
                        var props = keys(func), key = props[0], a = func[key];
                        if (props.length == 1 && a === a && !isObject(a)) {
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || 1 / a == 1 / b);
                            };
                        }
                        return function(object) {
                            var length = props.length, result = false;
                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }
                    function escape(string) {
                        return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }
                    function identity(value) {
                        return value;
                    }
                    function mixin(object, source, options) {
                        var chain = true, methodNames = source && functions(source);
                        if (!source || !options && !methodNames.length) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && "chain" in options) {
                            chain = options.chain;
                        }
                        var ctor = object, isFunc = isFunction(ctor);
                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }
                    function noop() {}
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };
                    var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
                    };
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }
                    function random(min, max, floating) {
                        var noMin = min == null, noMax = max == null;
                        if (floating == null) {
                            if (typeof min == "boolean" && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == "boolean") {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                        }
                        return baseRandom(min, max);
                    }
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }
                    function template(text, data, options) {
                        var settings = lodash.templateSettings;
                        text = String(text || "");
                        options = defaults({}, options, settings);
                        var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                        var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = options.variable, hasVariable = variable;
                        if (!hasVariable) {
                            variable = "obj";
                            source = "with (" + variable + ") {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
                        try {
                            var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        result.source = source;
                        return result;
                    }
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1, result = Array(n);
                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }
                    function unescape(string) {
                        return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? "" : prefix) + id;
                    }
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;
                    mixin(lodash);
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;
                    mixin(function() {
                        var source = {};
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;
                    lodash.take = first;
                    lodash.head = first;
                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== "sample";
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                                return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                            };
                        }
                    });
                    lodash.VERSION = "2.4.1";
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;
                    forEach([ "join", "pop", "shift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                            return chainAll ? new lodashWrapper(result, chainAll) : result;
                        };
                    });
                    forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });
                    forEach([ "concat", "slice", "splice" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });
                    return lodash;
                }
                var _ = runInContext();
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    root._ = _;
                    define(function() {
                        return _;
                    });
                } else if (freeExports && freeModule) {
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    } else {
                        freeExports._ = _;
                    }
                } else {
                    root._ = _;
                }
            }).call(this);
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    2: [ function(require, module, exports) {
        var keys, lastEmittedValue, _, __indexOf = [].indexOf || function(item) {
            for (var i = 0, l = this.length; i < l; i++) {
                if (i in this && this[i] === item) return i;
            }
            return -1;
        };
        _ = require("lodash");
        lastEmittedValue = null;
        keys = {
            up: 38,
            down: 40,
            enter: 13,
            escape: 27,
            tab: 9
        };
        Polymer("ui-typeahead", {
            selectItem: function(item) {
                var index, items;
                items = this.querySelectorAll("ui-typeahead-item");
                if (item) {
                    this.setAttribute("selected", "");
                    this.$.input.setAttribute("hide", "");
                } else {
                    this.removeAttribute("selected");
                    this.$.input.removeAttribute("hide");
                    this.$.input.focus();
                }
                _.each(items, function(_this) {
                    return function(i) {
                        i.removeAttribute("focused");
                        if (i === item) {
                            if (_this.hasAttribute("selected") && i.hasAttribute("selected")) {
                                return _this.clear(false);
                            }
                            return i.setAttribute("selected", "");
                        } else {
                            return i.removeAttribute("selected");
                        }
                    };
                }(this));
                index = _.indexOf(items, item);
                return this.fire("change", {
                    item: item,
                    index: index
                });
            },
            clear: function(clearInput) {
                if (clearInput == null) {
                    clearInput = true;
                }
                this.selectItem(null);
                if (clearInput) {
                    return this.$.input.value = null;
                }
            },
            focus: function(evt) {
                return this.classList.add("focused");
            },
            documentClick: function(evt) {
                return this.classList.remove("focused");
            },
            click: function(evt) {
                var _ref;
                evt.stopPropagation();
                if (_ref = evt.target, __indexOf.call(this.querySelectorAll("ui-typeahead-item"), _ref) >= 0) {
                    return this.selectItem(evt.target);
                }
            },
            keyup: function(evt) {
                var bottom, focusIndex, height, items, maxHeight, top, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
                items = this.querySelectorAll("ui-typeahead-item");
                focusIndex = _.findIndex(items, function(i) {
                    return i.hasAttribute("focused");
                });
                this.removeAttribute("selected");
                if (evt.which === keys.down) {
                    if ((_ref = items[focusIndex]) != null) {
                        _ref.removeAttribute("focused");
                    }
                    if ((_ref1 = items[(focusIndex + 1) % items.length]) != null) {
                        _ref1.setAttribute("focused", "");
                    }
                } else if (evt.which === keys.up) {
                    if ((_ref2 = items[focusIndex]) != null) {
                        _ref2.removeAttribute("focused");
                    }
                    if (focusIndex <= 0) {
                        focusIndex = items.length;
                    }
                    if ((_ref3 = items[focusIndex - 1]) != null) {
                        _ref3.setAttribute("focused", "");
                    }
                } else if ((_ref4 = evt.which) === keys.enter || _ref4 === keys.tab) {
                    this.selectItem(items[focusIndex]);
                } else if (evt.which === keys.escape) {
                    if ((_ref5 = items[focusIndex]) != null) {
                        _ref5.focused = false;
                    }
                    this.selectItem(null);
                    this.fire("inputChange", {
                        value: null
                    });
                } else {
                    this.debouncedKeyPress(evt);
                }
                bottom = window.scrollY + window.innerHeight;
                top = this.$.results.getBoundingClientRect().top;
                height = this.$.results.scrollHeight;
                if (top + height > bottom) {
                    maxHeight = bottom - top;
                    this.$.results.style.maxHeight = "" + maxHeight + "px";
                    if (((_ref6 = this.querySelector("[focused]")) != null ? _ref6.offsetTop : void 0) > maxHeight) {
                        this.$.results.scrollTop = (_ref7 = this.querySelector("[focused]")) != null ? _ref7.offsetTop : void 0;
                    }
                    if (((_ref8 = this.querySelector("[focused]")) != null ? _ref8.offsetTop : void 0) < this.$.results.scrollTop) {
                        return this.$.results.scrollTop = (_ref9 = this.querySelector("[focused]")) != null ? _ref9.offsetTop : void 0;
                    }
                } else {
                    return this.$.results.style.maxHeight = "";
                }
            },
            dataChanged: function(oldVal, newVal) {
                return this.querySelector("template").model = newVal;
            },
            attached: function() {
                this.debounce || (this.debounce = 300);
                this.debouncedKeyPress = _.debounce(function() {
                    if (this.$.input.value !== lastEmittedValue) {
                        lastEmittedValue = this.$.input.value;
                        return this.fire("inputChange", {
                            value: this.$.input.value
                        });
                    }
                }, this.debounce);
                this.addEventListener("click", this.click);
                this.addEventListener("focus", this.focus);
                this.addEventListener("keyup", this.keyup);
                return window.addEventListener("click", function(_this) {
                    return function(evt) {
                        return _this.documentClick(evt);
                    };
                }(this));
            },
            detached: function() {
                return window.removeEventListener("click", this.documentClick);
            }
        });
    }, {
        lodash: 1
    } ]
}, {}, [ 2 ]);</script>
</polymer-element>

<polymer-element name="ui-typeahead-item" attributes="focused selected model value">
<template>
  <style>.hide {
  display: none !important;
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: block;
  cursor: pointer;
  padding: 0.65em;
  border-bottom: 1px solid rgba(0, 0, 0, 0.1);
  color: rgba(69, 69, 69, 0.85);
  box-sizing: border-box;
}
:host([focused]) {
  background-image: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1));
}
:host([selected]) {
  border: 0;
}
</style>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-typeahead/src/ui-typeahead-item.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-typeahead-item", {
            rebubbleClick: function(evt) {
                if (evt.target !== this) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    return this.fire("click");
                }
            },
            attached: function() {
                return this.addEventListener("click", this.rebubbleClick);
            }
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-toolbar-button" attributes="icon active enabled toggle selected" on-mousedown="{{pointerdown}}" on-mouseup="{{pointerup}}" on-mouseenter="{{pointerenter}}" on-mouseleave="{{pointerleave}}" on-click="{{pointerclick}}">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
.fa {
  display: inline-block;
  font-family: FontAwesome;
  font-style: normal;
  font-weight: normal;
  line-height: 1;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
/* makes the font 33% larger relative to the icon container */
.fa-lg {
  font-size: 1.33333333em;
  line-height: 0.75em;
  vertical-align: -15%;
}
.fa-2x {
  font-size: 2em;
}
.fa-3x {
  font-size: 3em;
}
.fa-4x {
  font-size: 4em;
}
.fa-5x {
  font-size: 5em;
}
.fa-fw {
  width: 1.28571429em;
  text-align: center;
}
.fa-ul {
  padding-left: 0;
  margin-left: 2.14285714em;
  list-style-type: none;
}
.fa-ul > li {
  position: relative;
}
.fa-li {
  position: absolute;
  left: -2.14285714em;
  width: 2.14285714em;
  top: 0.14285714em;
  text-align: center;
}
.fa-li.fa-lg {
  left: -1.85714286em;
}
.fa-border {
  padding: .2em .25em .15em;
  border: solid 0.08em #eeeeee;
  border-radius: .1em;
}
.pull-right {
  float: right;
}
.pull-left {
  float: left;
}
.fa.pull-left {
  margin-right: .3em;
}
.fa.pull-right {
  margin-left: .3em;
}
.fa-spin {
  -webkit-animation: spin 2s infinite linear;
  -moz-animation: spin 2s infinite linear;
  -o-animation: spin 2s infinite linear;
  animation: spin 2s infinite linear;
}
@-moz-keyframes spin {
  0% {
    -moz-transform: rotate(0deg);
  }
  100% {
    -moz-transform: rotate(359deg);
  }
}
@-webkit-keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
  }
}
@-o-keyframes spin {
  0% {
    -o-transform: rotate(0deg);
  }
  100% {
    -o-transform: rotate(359deg);
  }
}
@keyframes spin {
  0% {
    -webkit-transform: rotate(0deg);
    transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(359deg);
    transform: rotate(359deg);
  }
}
.fa-rotate-90 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=1);
  -webkit-transform: rotate(90deg);
  -moz-transform: rotate(90deg);
  -ms-transform: rotate(90deg);
  -o-transform: rotate(90deg);
  transform: rotate(90deg);
}
.fa-rotate-180 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2);
  -webkit-transform: rotate(180deg);
  -moz-transform: rotate(180deg);
  -ms-transform: rotate(180deg);
  -o-transform: rotate(180deg);
  transform: rotate(180deg);
}
.fa-rotate-270 {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=3);
  -webkit-transform: rotate(270deg);
  -moz-transform: rotate(270deg);
  -ms-transform: rotate(270deg);
  -o-transform: rotate(270deg);
  transform: rotate(270deg);
}
.fa-flip-horizontal {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1);
  -webkit-transform: scale(-1, 1);
  -moz-transform: scale(-1, 1);
  -ms-transform: scale(-1, 1);
  -o-transform: scale(-1, 1);
  transform: scale(-1, 1);
}
.fa-flip-vertical {
  filter: progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1);
  -webkit-transform: scale(1, -1);
  -moz-transform: scale(1, -1);
  -ms-transform: scale(1, -1);
  -o-transform: scale(1, -1);
  transform: scale(1, -1);
}
.fa-stack {
  position: relative;
  display: inline-block;
  width: 2em;
  height: 2em;
  line-height: 2em;
  vertical-align: middle;
}
.fa-stack-1x,
.fa-stack-2x {
  position: absolute;
  left: 0;
  width: 100%;
  text-align: center;
}
.fa-stack-1x {
  line-height: inherit;
}
.fa-stack-2x {
  font-size: 2em;
}
.fa-inverse {
  color: #ffffff;
}
/* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
   readers do not read off random characters that represent icons */
.fa-glass:before {
  content: "\f000";
}
.fa-music:before {
  content: "\f001";
}
.fa-search:before {
  content: "\f002";
}
.fa-envelope-o:before {
  content: "\f003";
}
.fa-heart:before {
  content: "\f004";
}
.fa-star:before {
  content: "\f005";
}
.fa-star-o:before {
  content: "\f006";
}
.fa-user:before {
  content: "\f007";
}
.fa-film:before {
  content: "\f008";
}
.fa-th-large:before {
  content: "\f009";
}
.fa-th:before {
  content: "\f00a";
}
.fa-th-list:before {
  content: "\f00b";
}
.fa-check:before {
  content: "\f00c";
}
.fa-times:before {
  content: "\f00d";
}
.fa-search-plus:before {
  content: "\f00e";
}
.fa-search-minus:before {
  content: "\f010";
}
.fa-power-off:before {
  content: "\f011";
}
.fa-signal:before {
  content: "\f012";
}
.fa-gear:before,
.fa-cog:before {
  content: "\f013";
}
.fa-trash-o:before {
  content: "\f014";
}
.fa-home:before {
  content: "\f015";
}
.fa-file-o:before {
  content: "\f016";
}
.fa-clock-o:before {
  content: "\f017";
}
.fa-road:before {
  content: "\f018";
}
.fa-download:before {
  content: "\f019";
}
.fa-arrow-circle-o-down:before {
  content: "\f01a";
}
.fa-arrow-circle-o-up:before {
  content: "\f01b";
}
.fa-inbox:before {
  content: "\f01c";
}
.fa-play-circle-o:before {
  content: "\f01d";
}
.fa-rotate-right:before,
.fa-repeat:before {
  content: "\f01e";
}
.fa-refresh:before {
  content: "\f021";
}
.fa-list-alt:before {
  content: "\f022";
}
.fa-lock:before {
  content: "\f023";
}
.fa-flag:before {
  content: "\f024";
}
.fa-headphones:before {
  content: "\f025";
}
.fa-volume-off:before {
  content: "\f026";
}
.fa-volume-down:before {
  content: "\f027";
}
.fa-volume-up:before {
  content: "\f028";
}
.fa-qrcode:before {
  content: "\f029";
}
.fa-barcode:before {
  content: "\f02a";
}
.fa-tag:before {
  content: "\f02b";
}
.fa-tags:before {
  content: "\f02c";
}
.fa-book:before {
  content: "\f02d";
}
.fa-bookmark:before {
  content: "\f02e";
}
.fa-print:before {
  content: "\f02f";
}
.fa-camera:before {
  content: "\f030";
}
.fa-font:before {
  content: "\f031";
}
.fa-bold:before {
  content: "\f032";
}
.fa-italic:before {
  content: "\f033";
}
.fa-text-height:before {
  content: "\f034";
}
.fa-text-width:before {
  content: "\f035";
}
.fa-align-left:before {
  content: "\f036";
}
.fa-align-center:before {
  content: "\f037";
}
.fa-align-right:before {
  content: "\f038";
}
.fa-align-justify:before {
  content: "\f039";
}
.fa-list:before {
  content: "\f03a";
}
.fa-dedent:before,
.fa-outdent:before {
  content: "\f03b";
}
.fa-indent:before {
  content: "\f03c";
}
.fa-video-camera:before {
  content: "\f03d";
}
.fa-photo:before,
.fa-image:before,
.fa-picture-o:before {
  content: "\f03e";
}
.fa-pencil:before {
  content: "\f040";
}
.fa-map-marker:before {
  content: "\f041";
}
.fa-adjust:before {
  content: "\f042";
}
.fa-tint:before {
  content: "\f043";
}
.fa-edit:before,
.fa-pencil-square-o:before {
  content: "\f044";
}
.fa-share-square-o:before {
  content: "\f045";
}
.fa-check-square-o:before {
  content: "\f046";
}
.fa-arrows:before {
  content: "\f047";
}
.fa-step-backward:before {
  content: "\f048";
}
.fa-fast-backward:before {
  content: "\f049";
}
.fa-backward:before {
  content: "\f04a";
}
.fa-play:before {
  content: "\f04b";
}
.fa-pause:before {
  content: "\f04c";
}
.fa-stop:before {
  content: "\f04d";
}
.fa-forward:before {
  content: "\f04e";
}
.fa-fast-forward:before {
  content: "\f050";
}
.fa-step-forward:before {
  content: "\f051";
}
.fa-eject:before {
  content: "\f052";
}
.fa-chevron-left:before {
  content: "\f053";
}
.fa-chevron-right:before {
  content: "\f054";
}
.fa-plus-circle:before {
  content: "\f055";
}
.fa-minus-circle:before {
  content: "\f056";
}
.fa-times-circle:before {
  content: "\f057";
}
.fa-check-circle:before {
  content: "\f058";
}
.fa-question-circle:before {
  content: "\f059";
}
.fa-info-circle:before {
  content: "\f05a";
}
.fa-crosshairs:before {
  content: "\f05b";
}
.fa-times-circle-o:before {
  content: "\f05c";
}
.fa-check-circle-o:before {
  content: "\f05d";
}
.fa-ban:before {
  content: "\f05e";
}
.fa-arrow-left:before {
  content: "\f060";
}
.fa-arrow-right:before {
  content: "\f061";
}
.fa-arrow-up:before {
  content: "\f062";
}
.fa-arrow-down:before {
  content: "\f063";
}
.fa-mail-forward:before,
.fa-share:before {
  content: "\f064";
}
.fa-expand:before {
  content: "\f065";
}
.fa-compress:before {
  content: "\f066";
}
.fa-plus:before {
  content: "\f067";
}
.fa-minus:before {
  content: "\f068";
}
.fa-asterisk:before {
  content: "\f069";
}
.fa-exclamation-circle:before {
  content: "\f06a";
}
.fa-gift:before {
  content: "\f06b";
}
.fa-leaf:before {
  content: "\f06c";
}
.fa-fire:before {
  content: "\f06d";
}
.fa-eye:before {
  content: "\f06e";
}
.fa-eye-slash:before {
  content: "\f070";
}
.fa-warning:before,
.fa-exclamation-triangle:before {
  content: "\f071";
}
.fa-plane:before {
  content: "\f072";
}
.fa-calendar:before {
  content: "\f073";
}
.fa-random:before {
  content: "\f074";
}
.fa-comment:before {
  content: "\f075";
}
.fa-magnet:before {
  content: "\f076";
}
.fa-chevron-up:before {
  content: "\f077";
}
.fa-chevron-down:before {
  content: "\f078";
}
.fa-retweet:before {
  content: "\f079";
}
.fa-shopping-cart:before {
  content: "\f07a";
}
.fa-folder:before {
  content: "\f07b";
}
.fa-folder-open:before {
  content: "\f07c";
}
.fa-arrows-v:before {
  content: "\f07d";
}
.fa-arrows-h:before {
  content: "\f07e";
}
.fa-bar-chart-o:before {
  content: "\f080";
}
.fa-twitter-square:before {
  content: "\f081";
}
.fa-facebook-square:before {
  content: "\f082";
}
.fa-camera-retro:before {
  content: "\f083";
}
.fa-key:before {
  content: "\f084";
}
.fa-gears:before,
.fa-cogs:before {
  content: "\f085";
}
.fa-comments:before {
  content: "\f086";
}
.fa-thumbs-o-up:before {
  content: "\f087";
}
.fa-thumbs-o-down:before {
  content: "\f088";
}
.fa-star-half:before {
  content: "\f089";
}
.fa-heart-o:before {
  content: "\f08a";
}
.fa-sign-out:before {
  content: "\f08b";
}
.fa-linkedin-square:before {
  content: "\f08c";
}
.fa-thumb-tack:before {
  content: "\f08d";
}
.fa-external-link:before {
  content: "\f08e";
}
.fa-sign-in:before {
  content: "\f090";
}
.fa-trophy:before {
  content: "\f091";
}
.fa-github-square:before {
  content: "\f092";
}
.fa-upload:before {
  content: "\f093";
}
.fa-lemon-o:before {
  content: "\f094";
}
.fa-phone:before {
  content: "\f095";
}
.fa-square-o:before {
  content: "\f096";
}
.fa-bookmark-o:before {
  content: "\f097";
}
.fa-phone-square:before {
  content: "\f098";
}
.fa-twitter:before {
  content: "\f099";
}
.fa-facebook:before {
  content: "\f09a";
}
.fa-github:before {
  content: "\f09b";
}
.fa-unlock:before {
  content: "\f09c";
}
.fa-credit-card:before {
  content: "\f09d";
}
.fa-rss:before {
  content: "\f09e";
}
.fa-hdd-o:before {
  content: "\f0a0";
}
.fa-bullhorn:before {
  content: "\f0a1";
}
.fa-bell:before {
  content: "\f0f3";
}
.fa-certificate:before {
  content: "\f0a3";
}
.fa-hand-o-right:before {
  content: "\f0a4";
}
.fa-hand-o-left:before {
  content: "\f0a5";
}
.fa-hand-o-up:before {
  content: "\f0a6";
}
.fa-hand-o-down:before {
  content: "\f0a7";
}
.fa-arrow-circle-left:before {
  content: "\f0a8";
}
.fa-arrow-circle-right:before {
  content: "\f0a9";
}
.fa-arrow-circle-up:before {
  content: "\f0aa";
}
.fa-arrow-circle-down:before {
  content: "\f0ab";
}
.fa-globe:before {
  content: "\f0ac";
}
.fa-wrench:before {
  content: "\f0ad";
}
.fa-tasks:before {
  content: "\f0ae";
}
.fa-filter:before {
  content: "\f0b0";
}
.fa-briefcase:before {
  content: "\f0b1";
}
.fa-arrows-alt:before {
  content: "\f0b2";
}
.fa-group:before,
.fa-users:before {
  content: "\f0c0";
}
.fa-chain:before,
.fa-link:before {
  content: "\f0c1";
}
.fa-cloud:before {
  content: "\f0c2";
}
.fa-flask:before {
  content: "\f0c3";
}
.fa-cut:before,
.fa-scissors:before {
  content: "\f0c4";
}
.fa-copy:before,
.fa-files-o:before {
  content: "\f0c5";
}
.fa-paperclip:before {
  content: "\f0c6";
}
.fa-save:before,
.fa-floppy-o:before {
  content: "\f0c7";
}
.fa-square:before {
  content: "\f0c8";
}
.fa-navicon:before,
.fa-reorder:before,
.fa-bars:before {
  content: "\f0c9";
}
.fa-list-ul:before {
  content: "\f0ca";
}
.fa-list-ol:before {
  content: "\f0cb";
}
.fa-strikethrough:before {
  content: "\f0cc";
}
.fa-underline:before {
  content: "\f0cd";
}
.fa-table:before {
  content: "\f0ce";
}
.fa-magic:before {
  content: "\f0d0";
}
.fa-truck:before {
  content: "\f0d1";
}
.fa-pinterest:before {
  content: "\f0d2";
}
.fa-pinterest-square:before {
  content: "\f0d3";
}
.fa-google-plus-square:before {
  content: "\f0d4";
}
.fa-google-plus:before {
  content: "\f0d5";
}
.fa-money:before {
  content: "\f0d6";
}
.fa-caret-down:before {
  content: "\f0d7";
}
.fa-caret-up:before {
  content: "\f0d8";
}
.fa-caret-left:before {
  content: "\f0d9";
}
.fa-caret-right:before {
  content: "\f0da";
}
.fa-columns:before {
  content: "\f0db";
}
.fa-unsorted:before,
.fa-sort:before {
  content: "\f0dc";
}
.fa-sort-down:before,
.fa-sort-desc:before {
  content: "\f0dd";
}
.fa-sort-up:before,
.fa-sort-asc:before {
  content: "\f0de";
}
.fa-envelope:before {
  content: "\f0e0";
}
.fa-linkedin:before {
  content: "\f0e1";
}
.fa-rotate-left:before,
.fa-undo:before {
  content: "\f0e2";
}
.fa-legal:before,
.fa-gavel:before {
  content: "\f0e3";
}
.fa-dashboard:before,
.fa-tachometer:before {
  content: "\f0e4";
}
.fa-comment-o:before {
  content: "\f0e5";
}
.fa-comments-o:before {
  content: "\f0e6";
}
.fa-flash:before,
.fa-bolt:before {
  content: "\f0e7";
}
.fa-sitemap:before {
  content: "\f0e8";
}
.fa-umbrella:before {
  content: "\f0e9";
}
.fa-paste:before,
.fa-clipboard:before {
  content: "\f0ea";
}
.fa-lightbulb-o:before {
  content: "\f0eb";
}
.fa-exchange:before {
  content: "\f0ec";
}
.fa-cloud-download:before {
  content: "\f0ed";
}
.fa-cloud-upload:before {
  content: "\f0ee";
}
.fa-user-md:before {
  content: "\f0f0";
}
.fa-stethoscope:before {
  content: "\f0f1";
}
.fa-suitcase:before {
  content: "\f0f2";
}
.fa-bell-o:before {
  content: "\f0a2";
}
.fa-coffee:before {
  content: "\f0f4";
}
.fa-cutlery:before {
  content: "\f0f5";
}
.fa-file-text-o:before {
  content: "\f0f6";
}
.fa-building-o:before {
  content: "\f0f7";
}
.fa-hospital-o:before {
  content: "\f0f8";
}
.fa-ambulance:before {
  content: "\f0f9";
}
.fa-medkit:before {
  content: "\f0fa";
}
.fa-fighter-jet:before {
  content: "\f0fb";
}
.fa-beer:before {
  content: "\f0fc";
}
.fa-h-square:before {
  content: "\f0fd";
}
.fa-plus-square:before {
  content: "\f0fe";
}
.fa-angle-double-left:before {
  content: "\f100";
}
.fa-angle-double-right:before {
  content: "\f101";
}
.fa-angle-double-up:before {
  content: "\f102";
}
.fa-angle-double-down:before {
  content: "\f103";
}
.fa-angle-left:before {
  content: "\f104";
}
.fa-angle-right:before {
  content: "\f105";
}
.fa-angle-up:before {
  content: "\f106";
}
.fa-angle-down:before {
  content: "\f107";
}
.fa-desktop:before {
  content: "\f108";
}
.fa-laptop:before {
  content: "\f109";
}
.fa-tablet:before {
  content: "\f10a";
}
.fa-mobile-phone:before,
.fa-mobile:before {
  content: "\f10b";
}
.fa-circle-o:before {
  content: "\f10c";
}
.fa-quote-left:before {
  content: "\f10d";
}
.fa-quote-right:before {
  content: "\f10e";
}
.fa-spinner:before {
  content: "\f110";
}
.fa-circle:before {
  content: "\f111";
}
.fa-mail-reply:before,
.fa-reply:before {
  content: "\f112";
}
.fa-github-alt:before {
  content: "\f113";
}
.fa-folder-o:before {
  content: "\f114";
}
.fa-folder-open-o:before {
  content: "\f115";
}
.fa-smile-o:before {
  content: "\f118";
}
.fa-frown-o:before {
  content: "\f119";
}
.fa-meh-o:before {
  content: "\f11a";
}
.fa-gamepad:before {
  content: "\f11b";
}
.fa-keyboard-o:before {
  content: "\f11c";
}
.fa-flag-o:before {
  content: "\f11d";
}
.fa-flag-checkered:before {
  content: "\f11e";
}
.fa-terminal:before {
  content: "\f120";
}
.fa-code:before {
  content: "\f121";
}
.fa-mail-reply-all:before,
.fa-reply-all:before {
  content: "\f122";
}
.fa-star-half-empty:before,
.fa-star-half-full:before,
.fa-star-half-o:before {
  content: "\f123";
}
.fa-location-arrow:before {
  content: "\f124";
}
.fa-crop:before {
  content: "\f125";
}
.fa-code-fork:before {
  content: "\f126";
}
.fa-unlink:before,
.fa-chain-broken:before {
  content: "\f127";
}
.fa-question:before {
  content: "\f128";
}
.fa-info:before {
  content: "\f129";
}
.fa-exclamation:before {
  content: "\f12a";
}
.fa-superscript:before {
  content: "\f12b";
}
.fa-subscript:before {
  content: "\f12c";
}
.fa-eraser:before {
  content: "\f12d";
}
.fa-puzzle-piece:before {
  content: "\f12e";
}
.fa-microphone:before {
  content: "\f130";
}
.fa-microphone-slash:before {
  content: "\f131";
}
.fa-shield:before {
  content: "\f132";
}
.fa-calendar-o:before {
  content: "\f133";
}
.fa-fire-extinguisher:before {
  content: "\f134";
}
.fa-rocket:before {
  content: "\f135";
}
.fa-maxcdn:before {
  content: "\f136";
}
.fa-chevron-circle-left:before {
  content: "\f137";
}
.fa-chevron-circle-right:before {
  content: "\f138";
}
.fa-chevron-circle-up:before {
  content: "\f139";
}
.fa-chevron-circle-down:before {
  content: "\f13a";
}
.fa-html5:before {
  content: "\f13b";
}
.fa-css3:before {
  content: "\f13c";
}
.fa-anchor:before {
  content: "\f13d";
}
.fa-unlock-alt:before {
  content: "\f13e";
}
.fa-bullseye:before {
  content: "\f140";
}
.fa-ellipsis-h:before {
  content: "\f141";
}
.fa-ellipsis-v:before {
  content: "\f142";
}
.fa-rss-square:before {
  content: "\f143";
}
.fa-play-circle:before {
  content: "\f144";
}
.fa-ticket:before {
  content: "\f145";
}
.fa-minus-square:before {
  content: "\f146";
}
.fa-minus-square-o:before {
  content: "\f147";
}
.fa-level-up:before {
  content: "\f148";
}
.fa-level-down:before {
  content: "\f149";
}
.fa-check-square:before {
  content: "\f14a";
}
.fa-pencil-square:before {
  content: "\f14b";
}
.fa-external-link-square:before {
  content: "\f14c";
}
.fa-share-square:before {
  content: "\f14d";
}
.fa-compass:before {
  content: "\f14e";
}
.fa-toggle-down:before,
.fa-caret-square-o-down:before {
  content: "\f150";
}
.fa-toggle-up:before,
.fa-caret-square-o-up:before {
  content: "\f151";
}
.fa-toggle-right:before,
.fa-caret-square-o-right:before {
  content: "\f152";
}
.fa-euro:before,
.fa-eur:before {
  content: "\f153";
}
.fa-gbp:before {
  content: "\f154";
}
.fa-dollar:before,
.fa-usd:before {
  content: "\f155";
}
.fa-rupee:before,
.fa-inr:before {
  content: "\f156";
}
.fa-cny:before,
.fa-rmb:before,
.fa-yen:before,
.fa-jpy:before {
  content: "\f157";
}
.fa-ruble:before,
.fa-rouble:before,
.fa-rub:before {
  content: "\f158";
}
.fa-won:before,
.fa-krw:before {
  content: "\f159";
}
.fa-bitcoin:before,
.fa-btc:before {
  content: "\f15a";
}
.fa-file:before {
  content: "\f15b";
}
.fa-file-text:before {
  content: "\f15c";
}
.fa-sort-alpha-asc:before {
  content: "\f15d";
}
.fa-sort-alpha-desc:before {
  content: "\f15e";
}
.fa-sort-amount-asc:before {
  content: "\f160";
}
.fa-sort-amount-desc:before {
  content: "\f161";
}
.fa-sort-numeric-asc:before {
  content: "\f162";
}
.fa-sort-numeric-desc:before {
  content: "\f163";
}
.fa-thumbs-up:before {
  content: "\f164";
}
.fa-thumbs-down:before {
  content: "\f165";
}
.fa-youtube-square:before {
  content: "\f166";
}
.fa-youtube:before {
  content: "\f167";
}
.fa-xing:before {
  content: "\f168";
}
.fa-xing-square:before {
  content: "\f169";
}
.fa-youtube-play:before {
  content: "\f16a";
}
.fa-dropbox:before {
  content: "\f16b";
}
.fa-stack-overflow:before {
  content: "\f16c";
}
.fa-instagram:before {
  content: "\f16d";
}
.fa-flickr:before {
  content: "\f16e";
}
.fa-adn:before {
  content: "\f170";
}
.fa-bitbucket:before {
  content: "\f171";
}
.fa-bitbucket-square:before {
  content: "\f172";
}
.fa-tumblr:before {
  content: "\f173";
}
.fa-tumblr-square:before {
  content: "\f174";
}
.fa-long-arrow-down:before {
  content: "\f175";
}
.fa-long-arrow-up:before {
  content: "\f176";
}
.fa-long-arrow-left:before {
  content: "\f177";
}
.fa-long-arrow-right:before {
  content: "\f178";
}
.fa-apple:before {
  content: "\f179";
}
.fa-windows:before {
  content: "\f17a";
}
.fa-android:before {
  content: "\f17b";
}
.fa-linux:before {
  content: "\f17c";
}
.fa-dribbble:before {
  content: "\f17d";
}
.fa-skype:before {
  content: "\f17e";
}
.fa-foursquare:before {
  content: "\f180";
}
.fa-trello:before {
  content: "\f181";
}
.fa-female:before {
  content: "\f182";
}
.fa-male:before {
  content: "\f183";
}
.fa-gittip:before {
  content: "\f184";
}
.fa-sun-o:before {
  content: "\f185";
}
.fa-moon-o:before {
  content: "\f186";
}
.fa-archive:before {
  content: "\f187";
}
.fa-bug:before {
  content: "\f188";
}
.fa-vk:before {
  content: "\f189";
}
.fa-weibo:before {
  content: "\f18a";
}
.fa-renren:before {
  content: "\f18b";
}
.fa-pagelines:before {
  content: "\f18c";
}
.fa-stack-exchange:before {
  content: "\f18d";
}
.fa-arrow-circle-o-right:before {
  content: "\f18e";
}
.fa-arrow-circle-o-left:before {
  content: "\f190";
}
.fa-toggle-left:before,
.fa-caret-square-o-left:before {
  content: "\f191";
}
.fa-dot-circle-o:before {
  content: "\f192";
}
.fa-wheelchair:before {
  content: "\f193";
}
.fa-vimeo-square:before {
  content: "\f194";
}
.fa-turkish-lira:before,
.fa-try:before {
  content: "\f195";
}
.fa-plus-square-o:before {
  content: "\f196";
}
.fa-space-shuttle:before {
  content: "\f197";
}
.fa-slack:before {
  content: "\f198";
}
.fa-envelope-square:before {
  content: "\f199";
}
.fa-wordpress:before {
  content: "\f19a";
}
.fa-openid:before {
  content: "\f19b";
}
.fa-institution:before,
.fa-bank:before,
.fa-university:before {
  content: "\f19c";
}
.fa-mortar-board:before,
.fa-graduation-cap:before {
  content: "\f19d";
}
.fa-yahoo:before {
  content: "\f19e";
}
.fa-google:before {
  content: "\f1a0";
}
.fa-reddit:before {
  content: "\f1a1";
}
.fa-reddit-square:before {
  content: "\f1a2";
}
.fa-stumbleupon-circle:before {
  content: "\f1a3";
}
.fa-stumbleupon:before {
  content: "\f1a4";
}
.fa-delicious:before {
  content: "\f1a5";
}
.fa-digg:before {
  content: "\f1a6";
}
.fa-pied-piper-square:before,
.fa-pied-piper:before {
  content: "\f1a7";
}
.fa-pied-piper-alt:before {
  content: "\f1a8";
}
.fa-drupal:before {
  content: "\f1a9";
}
.fa-joomla:before {
  content: "\f1aa";
}
.fa-language:before {
  content: "\f1ab";
}
.fa-fax:before {
  content: "\f1ac";
}
.fa-building:before {
  content: "\f1ad";
}
.fa-child:before {
  content: "\f1ae";
}
.fa-paw:before {
  content: "\f1b0";
}
.fa-spoon:before {
  content: "\f1b1";
}
.fa-cube:before {
  content: "\f1b2";
}
.fa-cubes:before {
  content: "\f1b3";
}
.fa-behance:before {
  content: "\f1b4";
}
.fa-behance-square:before {
  content: "\f1b5";
}
.fa-steam:before {
  content: "\f1b6";
}
.fa-steam-square:before {
  content: "\f1b7";
}
.fa-recycle:before {
  content: "\f1b8";
}
.fa-automobile:before,
.fa-car:before {
  content: "\f1b9";
}
.fa-cab:before,
.fa-taxi:before {
  content: "\f1ba";
}
.fa-tree:before {
  content: "\f1bb";
}
.fa-spotify:before {
  content: "\f1bc";
}
.fa-deviantart:before {
  content: "\f1bd";
}
.fa-soundcloud:before {
  content: "\f1be";
}
.fa-database:before {
  content: "\f1c0";
}
.fa-file-pdf-o:before {
  content: "\f1c1";
}
.fa-file-word-o:before {
  content: "\f1c2";
}
.fa-file-excel-o:before {
  content: "\f1c3";
}
.fa-file-powerpoint-o:before {
  content: "\f1c4";
}
.fa-file-photo-o:before,
.fa-file-picture-o:before,
.fa-file-image-o:before {
  content: "\f1c5";
}
.fa-file-zip-o:before,
.fa-file-archive-o:before {
  content: "\f1c6";
}
.fa-file-sound-o:before,
.fa-file-audio-o:before {
  content: "\f1c7";
}
.fa-file-movie-o:before,
.fa-file-video-o:before {
  content: "\f1c8";
}
.fa-file-code-o:before {
  content: "\f1c9";
}
.fa-vine:before {
  content: "\f1ca";
}
.fa-codepen:before {
  content: "\f1cb";
}
.fa-jsfiddle:before {
  content: "\f1cc";
}
.fa-life-bouy:before,
.fa-life-saver:before,
.fa-support:before,
.fa-life-ring:before {
  content: "\f1cd";
}
.fa-circle-o-notch:before {
  content: "\f1ce";
}
.fa-ra:before,
.fa-rebel:before {
  content: "\f1d0";
}
.fa-ge:before,
.fa-empire:before {
  content: "\f1d1";
}
.fa-git-square:before {
  content: "\f1d2";
}
.fa-git:before {
  content: "\f1d3";
}
.fa-hacker-news:before {
  content: "\f1d4";
}
.fa-tencent-weibo:before {
  content: "\f1d5";
}
.fa-qq:before {
  content: "\f1d6";
}
.fa-wechat:before,
.fa-weixin:before {
  content: "\f1d7";
}
.fa-send:before,
.fa-paper-plane:before {
  content: "\f1d8";
}
.fa-send-o:before,
.fa-paper-plane-o:before {
  content: "\f1d9";
}
.fa-history:before {
  content: "\f1da";
}
.fa-circle-thin:before {
  content: "\f1db";
}
.fa-header:before {
  content: "\f1dc";
}
.fa-paragraph:before {
  content: "\f1dd";
}
.fa-sliders:before {
  content: "\f1de";
}
.fa-share-alt:before {
  content: "\f1e0";
}
.fa-share-alt-square:before {
  content: "\f1e1";
}
.fa-bomb:before {
  content: "\f1e2";
}
:host {
  display: inline-block;
  box-sizing: border-box;
  font-size: 1.5rem;
  perspective: 1000;
  position: relative;
}
:host .flipper {
  width: 1.75em;
  height: 1.75em;
  line-height: 1.75em;
  display: flex;
  align-items: center;
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  transform-style: preserve-3d;
  cursor: default;
}
:host .flipper.active {
  transform: rotateY(180deg);
  -webkit-transform: rotateY(180deg);
}
:host .flipper.active.pressed {
  transform: rotateY(180deg) scale(0.95, 0.95);
  -webkit-transform: rotateY(180deg) scale(0.95, 0.95);
}
:host .flipper.pressed {
  transform: scale(0.95, 0.95);
  -webkit-transform: scale(0.95, 0.95);
}
:host .flipper.enabled {
  cursor: pointer;
}
:host .selector {
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
  transform: rotateY(90deg);
  -webkit-transform: rotateY(90deg);
  background-color: rgba(255, 255, 255, 0.85);
  position: absolute;
  left: 0;
  width: 100%;
  height: .1em;
}
:host .selector.selected {
  transform: rotateY(0deg);
  -webkit-transform: rotateY(0deg);
}
:host .toolicon {
  box-sizing: border-box;
  min-width: 100%;
  min-height: 100%;
  width: 100%;
  backface-visibility: hidden;
  -webkit-backface-visibility: hidden;
}
:host .back {
  color: rgba(255, 255, 255, 0.61);
}
:host .front {
  color: rgba(255, 255, 255, 0.33);
  z-index: 2;
  transform: rotateY(180deg);
  -webkit-transform: rotateY(180deg);
}
:host .front.enabled {
  color: #ffffff;
}
</style>
  <section id="button" on-click="{{click}}">
    <span id="selector" class="selector"></span>
    <span id="tool" class="flipper {{ {active: active, enabled: enabled} | tokenList }}">
      <i class="toolicon front fa {{ icon }} fa-stack-1x {{ {enabled: enabled} | tokenList }}"></i>
      <i class="toolicon back fa {{ icon }} fa-stack-1x"></i>
    </span>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-toolbar/src/ui-toolbar-button.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-toolbar-button", {
            selectedChanged: function() {
                if (this.selected) {
                    return this.$.selector.classList.add("selected");
                } else {
                    return this.$.selector.classList.remove("selected");
                }
            },
            pointerdown: function() {
                if (this.enabled) {
                    return this.$.tool.classList.add("pressed");
                }
            },
            pointerup: function() {
                return this.$.tool.classList.remove("pressed");
            },
            click: function(evt) {
                if (!this.enabled) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    return false;
                }
            },
            pointerenter: function() {},
            pointerleave: function() {},
            pointerclick: function(evt) {
                if (this.toggle) {
                    return this.active = !this.active;
                }
            },
            created: function() {
                this.toggle = false;
                this.active = true;
                return this.enabled = true;
            },
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>


<polymer-element name="ui-toolbar" attributes="">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  background-color: #333333;
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
  display: flex;
  box-sizing: border-box;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
}
</style>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-toolbar/src/ui-toolbar.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-toolbar", {
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-resizebox" attributes="left right">
<template>
  <style>:host {
  display: inline-block;
  box-sizing: border-box;
  position: relative;
  overflow-y: auto;
  overflow-x: hidden;
}
:host #splitter {
  box-sizing: border-box;
  cursor: col-resize;
  position: absolute;
  top: 0;
  bottom: 0;
  width: 0.5em;
  background-color: transparent;
  z-index: 1;
}
:host #display {
  box-sizing: border-box;
  position: relative;
  width: 100%;
  height: 100%;
}
::content > * {
  box-sizing: border-box;
}
:host([right]) {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
}
:host([right]) #splitter {
  left: 0;
}
:host([left]) {
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
}
:host([left]) #splitter {
  right: 0;
}
</style>
  <section id="splitter" on-trackstart="{{trackStart}}" on-track="{{track}}"></section>
  <section id="display">
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-resizebox/src/ui-resizebox.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-resizebox", {
            trackStart: function() {
                return this.size = parseInt(getComputedStyle(this)["width"]);
            },
            track: function(evt) {
                var delta;
                delta = evt["dx"];
                if (this.left != null) {
                    delta *= -1;
                }
                return this.style["width"] = "" + (this.size - delta) + "px";
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<style>body /deep/ .tile-1 {
  flex: 0 0 90%;
  max-height: 90%;
}
body /deep/ .tile-2 {
  flex: 0 0 50%;
  max-height: 50%;
}
body /deep/ .tile-3 {
  flex: 0 0 50%;
  max-height: 50%;
}
body /deep/ .tile-4 {
  flex: 0 0 50%;
  max-height: 50%;
}
body /deep/ .tile-5 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-6 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-7 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-8 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-9 {
  flex: 0 0 33%;
  max-height: 33%;
}
body /deep/ .tile-10 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-11 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-12 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-13 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-14 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-15 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-16 {
  flex: 0 0 25%;
  max-height: 25%;
}
body /deep/ .tile-17 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-18 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-19 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-20 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-21 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-22 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-23 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-24 {
  flex: 0 0 20%;
  max-height: 20%;
}
body /deep/ .tile-25 {
  flex: 0 0 20%;
  max-height: 20%;
}
</style>
<polymer-element name="ui-grid-tiler" attributes="selector">
<template>
  <style>:host {
  display: flex;
  text-align: center;
  overflow: hidden;
  width: 100%;
  height: 100%;
  flex-wrap: wrap;
  align-items: center;
  align-content: center;
  justify-content: center;
}
</style>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-grid-tiler/src/ui-grid-tiler.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        (function(global) {
            (function() {
                var undefined;
                var arrayPool = [], objectPool = [];
                var idCounter = 0;
                var keyPrefix = +new Date() + "";
                var largeArraySize = 75;
                var maxPoolSize = 40;
                var whitespace = " 	\f ﻿" + "\n\r\u2028\u2029" + " ᠎             　";
                var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
                var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
                var reFlags = /\w*$/;
                var reFuncName = /^\s*function[ \n\r\t]+\w/;
                var reInterpolate = /<%=([\s\S]+?)%>/g;
                var reLeadingSpacesAndZeros = RegExp("^[" + whitespace + "]*0+(?=.$)");
                var reNoMatch = /($^)/;
                var reThis = /\bthis\b/;
                var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
                var contextProps = [ "Array", "Boolean", "Date", "Function", "Math", "Number", "Object", "RegExp", "String", "_", "attachEvent", "clearTimeout", "isFinite", "isNaN", "parseInt", "setTimeout" ];
                var templateCounter = 0;
                var argsClass = "[object Arguments]", arrayClass = "[object Array]", boolClass = "[object Boolean]", dateClass = "[object Date]", funcClass = "[object Function]", numberClass = "[object Number]", objectClass = "[object Object]", regexpClass = "[object RegExp]", stringClass = "[object String]";
                var cloneableClasses = {};
                cloneableClasses[funcClass] = false;
                cloneableClasses[argsClass] = cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] = cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;
                var debounceOptions = {
                    leading: false,
                    maxWait: 0,
                    trailing: false
                };
                var descriptor = {
                    configurable: false,
                    enumerable: false,
                    value: null,
                    writable: false
                };
                var objectTypes = {
                    "boolean": false,
                    "function": true,
                    object: true,
                    number: false,
                    string: false,
                    undefined: false
                };
                var stringEscapes = {
                    "\\": "\\",
                    "'": "'",
                    "\n": "n",
                    "\r": "r",
                    "	": "t",
                    "\u2028": "u2028",
                    "\u2029": "u2029"
                };
                var root = objectTypes[typeof window] && window || this;
                var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;
                var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;
                var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
                var freeGlobal = objectTypes[typeof global] && global;
                if (freeGlobal && (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
                    root = freeGlobal;
                }
                function baseIndexOf(array, value, fromIndex) {
                    var index = (fromIndex || 0) - 1, length = array ? array.length : 0;
                    while (++index < length) {
                        if (array[index] === value) {
                            return index;
                        }
                    }
                    return -1;
                }
                function cacheIndexOf(cache, value) {
                    var type = typeof value;
                    cache = cache.cache;
                    if (type == "boolean" || value == null) {
                        return cache[value] ? 0 : -1;
                    }
                    if (type != "number" && type != "string") {
                        type = "object";
                    }
                    var key = type == "number" ? value : keyPrefix + value;
                    cache = (cache = cache[type]) && cache[key];
                    return type == "object" ? cache && baseIndexOf(cache, value) > -1 ? 0 : -1 : cache ? 0 : -1;
                }
                function cachePush(value) {
                    var cache = this.cache, type = typeof value;
                    if (type == "boolean" || value == null) {
                        cache[value] = true;
                    } else {
                        if (type != "number" && type != "string") {
                            type = "object";
                        }
                        var key = type == "number" ? value : keyPrefix + value, typeCache = cache[type] || (cache[type] = {});
                        if (type == "object") {
                            (typeCache[key] || (typeCache[key] = [])).push(value);
                        } else {
                            typeCache[key] = true;
                        }
                    }
                }
                function charAtCallback(value) {
                    return value.charCodeAt(0);
                }
                function compareAscending(a, b) {
                    var ac = a.criteria, bc = b.criteria, index = -1, length = ac.length;
                    while (++index < length) {
                        var value = ac[index], other = bc[index];
                        if (value !== other) {
                            if (value > other || typeof value == "undefined") {
                                return 1;
                            }
                            if (value < other || typeof other == "undefined") {
                                return -1;
                            }
                        }
                    }
                    return a.index - b.index;
                }
                function createCache(array) {
                    var index = -1, length = array.length, first = array[0], mid = array[length / 2 | 0], last = array[length - 1];
                    if (first && typeof first == "object" && mid && typeof mid == "object" && last && typeof last == "object") {
                        return false;
                    }
                    var cache = getObject();
                    cache["false"] = cache["null"] = cache["true"] = cache["undefined"] = false;
                    var result = getObject();
                    result.array = array;
                    result.cache = cache;
                    result.push = cachePush;
                    while (++index < length) {
                        result.push(array[index]);
                    }
                    return result;
                }
                function escapeStringChar(match) {
                    return "\\" + stringEscapes[match];
                }
                function getArray() {
                    return arrayPool.pop() || [];
                }
                function getObject() {
                    return objectPool.pop() || {
                        array: null,
                        cache: null,
                        criteria: null,
                        "false": false,
                        index: 0,
                        "null": false,
                        number: null,
                        object: null,
                        push: null,
                        string: null,
                        "true": false,
                        undefined: false,
                        value: null
                    };
                }
                function releaseArray(array) {
                    array.length = 0;
                    if (arrayPool.length < maxPoolSize) {
                        arrayPool.push(array);
                    }
                }
                function releaseObject(object) {
                    var cache = object.cache;
                    if (cache) {
                        releaseObject(cache);
                    }
                    object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
                    if (objectPool.length < maxPoolSize) {
                        objectPool.push(object);
                    }
                }
                function slice(array, start, end) {
                    start || (start = 0);
                    if (typeof end == "undefined") {
                        end = array ? array.length : 0;
                    }
                    var index = -1, length = end - start || 0, result = Array(length < 0 ? 0 : length);
                    while (++index < length) {
                        result[index] = array[start + index];
                    }
                    return result;
                }
                function runInContext(context) {
                    context = context ? _.defaults(root.Object(), context, _.pick(root, contextProps)) : root;
                    var Array = context.Array, Boolean = context.Boolean, Date = context.Date, Function = context.Function, Math = context.Math, Number = context.Number, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
                    var arrayRef = [];
                    var objectProto = Object.prototype;
                    var oldDash = context._;
                    var toString = objectProto.toString;
                    var reNative = RegExp("^" + String(toString).replace(/[.*+?^${}()|[\]\\]/g, "\\$&").replace(/toString| for [^\]]+/g, ".*?") + "$");
                    var ceil = Math.ceil, clearTimeout = context.clearTimeout, floor = Math.floor, fnToString = Function.prototype.toString, getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf, hasOwnProperty = objectProto.hasOwnProperty, push = arrayRef.push, setTimeout = context.setTimeout, splice = arrayRef.splice, unshift = arrayRef.unshift;
                    var defineProperty = function() {
                        try {
                            var o = {}, func = isNative(func = Object.defineProperty) && func, result = func(o, o, o) && func;
                        } catch (e) {}
                        return result;
                    }();
                    var nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate, nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray, nativeIsFinite = context.isFinite, nativeIsNaN = context.isNaN, nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys, nativeMax = Math.max, nativeMin = Math.min, nativeParseInt = context.parseInt, nativeRandom = Math.random;
                    var ctorByClass = {};
                    ctorByClass[arrayClass] = Array;
                    ctorByClass[boolClass] = Boolean;
                    ctorByClass[dateClass] = Date;
                    ctorByClass[funcClass] = Function;
                    ctorByClass[objectClass] = Object;
                    ctorByClass[numberClass] = Number;
                    ctorByClass[regexpClass] = RegExp;
                    ctorByClass[stringClass] = String;
                    function lodash(value) {
                        return value && typeof value == "object" && !isArray(value) && hasOwnProperty.call(value, "__wrapped__") ? value : new lodashWrapper(value);
                    }
                    function lodashWrapper(value, chainAll) {
                        this.__chain__ = !!chainAll;
                        this.__wrapped__ = value;
                    }
                    lodashWrapper.prototype = lodash.prototype;
                    var support = lodash.support = {};
                    support.funcDecomp = !isNative(context.WinRTError) && reThis.test(runInContext);
                    support.funcNames = typeof Function.name == "string";
                    lodash.templateSettings = {
                        escape: /<%-([\s\S]+?)%>/g,
                        evaluate: /<%([\s\S]+?)%>/g,
                        interpolate: reInterpolate,
                        variable: "",
                        imports: {
                            _: lodash
                        }
                    };
                    function baseBind(bindData) {
                        var func = bindData[0], partialArgs = bindData[2], thisArg = bindData[4];
                        function bound() {
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (this instanceof bound) {
                                var thisBinding = baseCreate(func.prototype), result = func.apply(thisBinding, args || arguments);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisArg, args || arguments);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseClone(value, isDeep, callback, stackA, stackB) {
                        if (callback) {
                            var result = callback(value);
                            if (typeof result != "undefined") {
                                return result;
                            }
                        }
                        var isObj = isObject(value);
                        if (isObj) {
                            var className = toString.call(value);
                            if (!cloneableClasses[className]) {
                                return value;
                            }
                            var ctor = ctorByClass[className];
                            switch (className) {
                              case boolClass:
                              case dateClass:
                                return new ctor(+value);

                              case numberClass:
                              case stringClass:
                                return new ctor(value);

                              case regexpClass:
                                result = ctor(value.source, reFlags.exec(value));
                                result.lastIndex = value.lastIndex;
                                return result;
                            }
                        } else {
                            return value;
                        }
                        var isArr = isArray(value);
                        if (isDeep) {
                            var initedStack = !stackA;
                            stackA || (stackA = getArray());
                            stackB || (stackB = getArray());
                            var length = stackA.length;
                            while (length--) {
                                if (stackA[length] == value) {
                                    return stackB[length];
                                }
                            }
                            result = isArr ? ctor(value.length) : {};
                        } else {
                            result = isArr ? slice(value) : assign({}, value);
                        }
                        if (isArr) {
                            if (hasOwnProperty.call(value, "index")) {
                                result.index = value.index;
                            }
                            if (hasOwnProperty.call(value, "input")) {
                                result.input = value.input;
                            }
                        }
                        if (!isDeep) {
                            return result;
                        }
                        stackA.push(value);
                        stackB.push(result);
                        (isArr ? forEach : forOwn)(value, function(objValue, key) {
                            result[key] = baseClone(objValue, isDeep, callback, stackA, stackB);
                        });
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseCreate(prototype, properties) {
                        return isObject(prototype) ? nativeCreate(prototype) : {};
                    }
                    if (!nativeCreate) {
                        baseCreate = function() {
                            function Object() {}
                            return function(prototype) {
                                if (isObject(prototype)) {
                                    Object.prototype = prototype;
                                    var result = new Object();
                                    Object.prototype = null;
                                }
                                return result || context.Object();
                            };
                        }();
                    }
                    function baseCreateCallback(func, thisArg, argCount) {
                        if (typeof func != "function") {
                            return identity;
                        }
                        if (typeof thisArg == "undefined" || !("prototype" in func)) {
                            return func;
                        }
                        var bindData = func.__bindData__;
                        if (typeof bindData == "undefined") {
                            if (support.funcNames) {
                                bindData = !func.name;
                            }
                            bindData = bindData || !support.funcDecomp;
                            if (!bindData) {
                                var source = fnToString.call(func);
                                if (!support.funcNames) {
                                    bindData = !reFuncName.test(source);
                                }
                                if (!bindData) {
                                    bindData = reThis.test(source);
                                    setBindData(func, bindData);
                                }
                            }
                        }
                        if (bindData === false || bindData !== true && bindData[1] & 1) {
                            return func;
                        }
                        switch (argCount) {
                          case 1:
                            return function(value) {
                                return func.call(thisArg, value);
                            };

                          case 2:
                            return function(a, b) {
                                return func.call(thisArg, a, b);
                            };

                          case 3:
                            return function(value, index, collection) {
                                return func.call(thisArg, value, index, collection);
                            };

                          case 4:
                            return function(accumulator, value, index, collection) {
                                return func.call(thisArg, accumulator, value, index, collection);
                            };
                        }
                        return bind(func, thisArg);
                    }
                    function baseCreateWrapper(bindData) {
                        var func = bindData[0], bitmask = bindData[1], partialArgs = bindData[2], partialRightArgs = bindData[3], thisArg = bindData[4], arity = bindData[5];
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, key = func;
                        function bound() {
                            var thisBinding = isBind ? thisArg : this;
                            if (partialArgs) {
                                var args = slice(partialArgs);
                                push.apply(args, arguments);
                            }
                            if (partialRightArgs || isCurry) {
                                args || (args = slice(arguments));
                                if (partialRightArgs) {
                                    push.apply(args, partialRightArgs);
                                }
                                if (isCurry && args.length < arity) {
                                    bitmask |= 16 & ~32;
                                    return baseCreateWrapper([ func, isCurryBound ? bitmask : bitmask & ~3, args, null, thisArg, arity ]);
                                }
                            }
                            args || (args = arguments);
                            if (isBindKey) {
                                func = thisBinding[key];
                            }
                            if (this instanceof bound) {
                                thisBinding = baseCreate(func.prototype);
                                var result = func.apply(thisBinding, args);
                                return isObject(result) ? result : thisBinding;
                            }
                            return func.apply(thisBinding, args);
                        }
                        setBindData(bound, bindData);
                        return bound;
                    }
                    function baseDifference(array, values) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, isLarge = length >= largeArraySize && indexOf === baseIndexOf, result = [];
                        if (isLarge) {
                            var cache = createCache(values);
                            if (cache) {
                                indexOf = cacheIndexOf;
                                values = cache;
                            } else {
                                isLarge = false;
                            }
                        }
                        while (++index < length) {
                            var value = array[index];
                            if (indexOf(values, value) < 0) {
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseObject(values);
                        }
                        return result;
                    }
                    function baseFlatten(array, isShallow, isStrict, fromIndex) {
                        var index = (fromIndex || 0) - 1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value && typeof value == "object" && typeof value.length == "number" && (isArray(value) || isArguments(value))) {
                                if (!isShallow) {
                                    value = baseFlatten(value, isShallow, isStrict);
                                }
                                var valIndex = -1, valLength = value.length, resIndex = result.length;
                                result.length += valLength;
                                while (++valIndex < valLength) {
                                    result[resIndex++] = value[valIndex];
                                }
                            } else if (!isStrict) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function baseIsEqual(a, b, callback, isWhere, stackA, stackB) {
                        if (callback) {
                            var result = callback(a, b);
                            if (typeof result != "undefined") {
                                return !!result;
                            }
                        }
                        if (a === b) {
                            return a !== 0 || 1 / a == 1 / b;
                        }
                        var type = typeof a, otherType = typeof b;
                        if (a === a && !(a && objectTypes[type]) && !(b && objectTypes[otherType])) {
                            return false;
                        }
                        if (a == null || b == null) {
                            return a === b;
                        }
                        var className = toString.call(a), otherClass = toString.call(b);
                        if (className == argsClass) {
                            className = objectClass;
                        }
                        if (otherClass == argsClass) {
                            otherClass = objectClass;
                        }
                        if (className != otherClass) {
                            return false;
                        }
                        switch (className) {
                          case boolClass:
                          case dateClass:
                            return +a == +b;

                          case numberClass:
                            return a != +a ? b != +b : a == 0 ? 1 / a == 1 / b : a == +b;

                          case regexpClass:
                          case stringClass:
                            return a == String(b);
                        }
                        var isArr = className == arrayClass;
                        if (!isArr) {
                            var aWrapped = hasOwnProperty.call(a, "__wrapped__"), bWrapped = hasOwnProperty.call(b, "__wrapped__");
                            if (aWrapped || bWrapped) {
                                return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB);
                            }
                            if (className != objectClass) {
                                return false;
                            }
                            var ctorA = a.constructor, ctorB = b.constructor;
                            if (ctorA != ctorB && !(isFunction(ctorA) && ctorA instanceof ctorA && isFunction(ctorB) && ctorB instanceof ctorB) && ("constructor" in a && "constructor" in b)) {
                                return false;
                            }
                        }
                        var initedStack = !stackA;
                        stackA || (stackA = getArray());
                        stackB || (stackB = getArray());
                        var length = stackA.length;
                        while (length--) {
                            if (stackA[length] == a) {
                                return stackB[length] == b;
                            }
                        }
                        var size = 0;
                        result = true;
                        stackA.push(a);
                        stackB.push(b);
                        if (isArr) {
                            length = a.length;
                            size = b.length;
                            result = size == length;
                            if (result || isWhere) {
                                while (size--) {
                                    var index = length, value = b[size];
                                    if (isWhere) {
                                        while (index--) {
                                            if (result = baseIsEqual(a[index], value, callback, isWhere, stackA, stackB)) {
                                                break;
                                            }
                                        }
                                    } else if (!(result = baseIsEqual(a[size], value, callback, isWhere, stackA, stackB))) {
                                        break;
                                    }
                                }
                            }
                        } else {
                            forIn(b, function(value, key, b) {
                                if (hasOwnProperty.call(b, key)) {
                                    size++;
                                    return result = hasOwnProperty.call(a, key) && baseIsEqual(a[key], value, callback, isWhere, stackA, stackB);
                                }
                            });
                            if (result && !isWhere) {
                                forIn(a, function(value, key, a) {
                                    if (hasOwnProperty.call(a, key)) {
                                        return result = --size > -1;
                                    }
                                });
                            }
                        }
                        stackA.pop();
                        stackB.pop();
                        if (initedStack) {
                            releaseArray(stackA);
                            releaseArray(stackB);
                        }
                        return result;
                    }
                    function baseMerge(object, source, callback, stackA, stackB) {
                        (isArray(source) ? forEach : forOwn)(source, function(source, key) {
                            var found, isArr, result = source, value = object[key];
                            if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
                                var stackLength = stackA.length;
                                while (stackLength--) {
                                    if (found = stackA[stackLength] == source) {
                                        value = stackB[stackLength];
                                        break;
                                    }
                                }
                                if (!found) {
                                    var isShallow;
                                    if (callback) {
                                        result = callback(value, source);
                                        if (isShallow = typeof result != "undefined") {
                                            value = result;
                                        }
                                    }
                                    if (!isShallow) {
                                        value = isArr ? isArray(value) ? value : [] : isPlainObject(value) ? value : {};
                                    }
                                    stackA.push(source);
                                    stackB.push(value);
                                    if (!isShallow) {
                                        baseMerge(value, source, callback, stackA, stackB);
                                    }
                                }
                            } else {
                                if (callback) {
                                    result = callback(value, source);
                                    if (typeof result == "undefined") {
                                        result = source;
                                    }
                                }
                                if (typeof result != "undefined") {
                                    value = result;
                                }
                            }
                            object[key] = value;
                        });
                    }
                    function baseRandom(min, max) {
                        return min + floor(nativeRandom() * (max - min + 1));
                    }
                    function baseUniq(array, isSorted, callback) {
                        var index = -1, indexOf = getIndexOf(), length = array ? array.length : 0, result = [];
                        var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf, seen = callback || isLarge ? getArray() : result;
                        if (isLarge) {
                            var cache = createCache(seen);
                            indexOf = cacheIndexOf;
                            seen = cache;
                        }
                        while (++index < length) {
                            var value = array[index], computed = callback ? callback(value, index, array) : value;
                            if (isSorted ? !index || seen[seen.length - 1] !== computed : indexOf(seen, computed) < 0) {
                                if (callback || isLarge) {
                                    seen.push(computed);
                                }
                                result.push(value);
                            }
                        }
                        if (isLarge) {
                            releaseArray(seen.array);
                            releaseObject(seen);
                        } else if (callback) {
                            releaseArray(seen);
                        }
                        return result;
                    }
                    function createAggregator(setter) {
                        return function(collection, callback, thisArg) {
                            var result = {};
                            callback = lodash.createCallback(callback, thisArg, 3);
                            var index = -1, length = collection ? collection.length : 0;
                            if (typeof length == "number") {
                                while (++index < length) {
                                    var value = collection[index];
                                    setter(result, value, callback(value, index, collection), collection);
                                }
                            } else {
                                forOwn(collection, function(value, key, collection) {
                                    setter(result, value, callback(value, key, collection), collection);
                                });
                            }
                            return result;
                        };
                    }
                    function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
                        var isBind = bitmask & 1, isBindKey = bitmask & 2, isCurry = bitmask & 4, isCurryBound = bitmask & 8, isPartial = bitmask & 16, isPartialRight = bitmask & 32;
                        if (!isBindKey && !isFunction(func)) {
                            throw new TypeError();
                        }
                        if (isPartial && !partialArgs.length) {
                            bitmask &= ~16;
                            isPartial = partialArgs = false;
                        }
                        if (isPartialRight && !partialRightArgs.length) {
                            bitmask &= ~32;
                            isPartialRight = partialRightArgs = false;
                        }
                        var bindData = func && func.__bindData__;
                        if (bindData && bindData !== true) {
                            bindData = slice(bindData);
                            if (bindData[2]) {
                                bindData[2] = slice(bindData[2]);
                            }
                            if (bindData[3]) {
                                bindData[3] = slice(bindData[3]);
                            }
                            if (isBind && !(bindData[1] & 1)) {
                                bindData[4] = thisArg;
                            }
                            if (!isBind && bindData[1] & 1) {
                                bitmask |= 8;
                            }
                            if (isCurry && !(bindData[1] & 4)) {
                                bindData[5] = arity;
                            }
                            if (isPartial) {
                                push.apply(bindData[2] || (bindData[2] = []), partialArgs);
                            }
                            if (isPartialRight) {
                                unshift.apply(bindData[3] || (bindData[3] = []), partialRightArgs);
                            }
                            bindData[1] |= bitmask;
                            return createWrapper.apply(null, bindData);
                        }
                        var creater = bitmask == 1 || bitmask === 17 ? baseBind : baseCreateWrapper;
                        return creater([ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ]);
                    }
                    function escapeHtmlChar(match) {
                        return htmlEscapes[match];
                    }
                    function getIndexOf() {
                        var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
                        return result;
                    }
                    function isNative(value) {
                        return typeof value == "function" && reNative.test(value);
                    }
                    var setBindData = !defineProperty ? noop : function(func, value) {
                        descriptor.value = value;
                        defineProperty(func, "__bindData__", descriptor);
                    };
                    function shimIsPlainObject(value) {
                        var ctor, result;
                        if (!(value && toString.call(value) == objectClass) || (ctor = value.constructor, 
                        isFunction(ctor) && !(ctor instanceof ctor))) {
                            return false;
                        }
                        forIn(value, function(value, key) {
                            result = key;
                        });
                        return typeof result == "undefined" || hasOwnProperty.call(value, result);
                    }
                    function unescapeHtmlChar(match) {
                        return htmlUnescapes[match];
                    }
                    function isArguments(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == argsClass || false;
                    }
                    var isArray = nativeIsArray || function(value) {
                        return value && typeof value == "object" && typeof value.length == "number" && toString.call(value) == arrayClass || false;
                    };
                    var shimKeys = function(object) {
                        var index, iterable = object, result = [];
                        if (!iterable) return result;
                        if (!objectTypes[typeof object]) return result;
                        for (index in iterable) {
                            if (hasOwnProperty.call(iterable, index)) {
                                result.push(index);
                            }
                        }
                        return result;
                    };
                    var keys = !nativeKeys ? shimKeys : function(object) {
                        if (!isObject(object)) {
                            return [];
                        }
                        return nativeKeys(object);
                    };
                    var htmlEscapes = {
                        "&": "&amp;",
                        "<": "&lt;",
                        ">": "&gt;",
                        '"': "&quot;",
                        "'": "&#39;"
                    };
                    var htmlUnescapes = invert(htmlEscapes);
                    var reEscapedHtml = RegExp("(" + keys(htmlUnescapes).join("|") + ")", "g"), reUnescapedHtml = RegExp("[" + keys(htmlEscapes).join("") + "]", "g");
                    var assign = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        if (argsLength > 3 && typeof args[argsLength - 2] == "function") {
                            var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);
                        } else if (argsLength > 2 && typeof args[argsLength - 1] == "function") {
                            callback = args[--argsLength];
                        }
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    result[index] = callback ? callback(result[index], iterable[index]) : iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function clone(value, isDeep, callback, thisArg) {
                        if (typeof isDeep != "boolean" && isDeep != null) {
                            thisArg = callback;
                            callback = isDeep;
                            isDeep = false;
                        }
                        return baseClone(value, isDeep, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function cloneDeep(value, callback, thisArg) {
                        return baseClone(value, true, typeof callback == "function" && baseCreateCallback(callback, thisArg, 1));
                    }
                    function create(prototype, properties) {
                        var result = baseCreate(prototype);
                        return properties ? assign(result, properties) : result;
                    }
                    var defaults = function(object, source, guard) {
                        var index, iterable = object, result = iterable;
                        if (!iterable) return result;
                        var args = arguments, argsIndex = 0, argsLength = typeof guard == "number" ? 2 : args.length;
                        while (++argsIndex < argsLength) {
                            iterable = args[argsIndex];
                            if (iterable && objectTypes[typeof iterable]) {
                                var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                                while (++ownIndex < length) {
                                    index = ownProps[ownIndex];
                                    if (typeof result[index] == "undefined") result[index] = iterable[index];
                                }
                            }
                        }
                        return result;
                    };
                    function findKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    function findLastKey(object, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwnRight(object, function(value, key, object) {
                            if (callback(value, key, object)) {
                                result = key;
                                return false;
                            }
                        });
                        return result;
                    }
                    var forIn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        for (index in iterable) {
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forInRight(object, callback, thisArg) {
                        var pairs = [];
                        forIn(object, function(value, key) {
                            pairs.push(key, value);
                        });
                        var length = pairs.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(pairs[length--], pairs[length], object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    var forOwn = function(collection, callback, thisArg) {
                        var index, iterable = collection, result = iterable;
                        if (!iterable) return result;
                        if (!objectTypes[typeof iterable]) return result;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        var ownIndex = -1, ownProps = objectTypes[typeof iterable] && keys(iterable), length = ownProps ? ownProps.length : 0;
                        while (++ownIndex < length) {
                            index = ownProps[ownIndex];
                            if (callback(iterable[index], index, collection) === false) return result;
                        }
                        return result;
                    };
                    function forOwnRight(object, callback, thisArg) {
                        var props = keys(object), length = props.length;
                        callback = baseCreateCallback(callback, thisArg, 3);
                        while (length--) {
                            var key = props[length];
                            if (callback(object[key], key, object) === false) {
                                break;
                            }
                        }
                        return object;
                    }
                    function functions(object) {
                        var result = [];
                        forIn(object, function(value, key) {
                            if (isFunction(value)) {
                                result.push(key);
                            }
                        });
                        return result.sort();
                    }
                    function has(object, key) {
                        return object ? hasOwnProperty.call(object, key) : false;
                    }
                    function invert(object) {
                        var index = -1, props = keys(object), length = props.length, result = {};
                        while (++index < length) {
                            var key = props[index];
                            result[object[key]] = key;
                        }
                        return result;
                    }
                    function isBoolean(value) {
                        return value === true || value === false || value && typeof value == "object" && toString.call(value) == boolClass || false;
                    }
                    function isDate(value) {
                        return value && typeof value == "object" && toString.call(value) == dateClass || false;
                    }
                    function isElement(value) {
                        return value && value.nodeType === 1 || false;
                    }
                    function isEmpty(value) {
                        var result = true;
                        if (!value) {
                            return result;
                        }
                        var className = toString.call(value), length = value.length;
                        if (className == arrayClass || className == stringClass || className == argsClass || className == objectClass && typeof length == "number" && isFunction(value.splice)) {
                            return !length;
                        }
                        forOwn(value, function() {
                            return result = false;
                        });
                        return result;
                    }
                    function isEqual(a, b, callback, thisArg) {
                        return baseIsEqual(a, b, typeof callback == "function" && baseCreateCallback(callback, thisArg, 2));
                    }
                    function isFinite(value) {
                        return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
                    }
                    function isFunction(value) {
                        return typeof value == "function";
                    }
                    function isObject(value) {
                        return !!(value && objectTypes[typeof value]);
                    }
                    function isNaN(value) {
                        return isNumber(value) && value != +value;
                    }
                    function isNull(value) {
                        return value === null;
                    }
                    function isNumber(value) {
                        return typeof value == "number" || value && typeof value == "object" && toString.call(value) == numberClass || false;
                    }
                    var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
                        if (!(value && toString.call(value) == objectClass)) {
                            return false;
                        }
                        var valueOf = value.valueOf, objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);
                        return objProto ? value == objProto || getPrototypeOf(value) == objProto : shimIsPlainObject(value);
                    };
                    function isRegExp(value) {
                        return value && typeof value == "object" && toString.call(value) == regexpClass || false;
                    }
                    function isString(value) {
                        return typeof value == "string" || value && typeof value == "object" && toString.call(value) == stringClass || false;
                    }
                    function isUndefined(value) {
                        return typeof value == "undefined";
                    }
                    function mapValues(object, callback, thisArg) {
                        var result = {};
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forOwn(object, function(value, key, object) {
                            result[key] = callback(value, key, object);
                        });
                        return result;
                    }
                    function merge(object) {
                        var args = arguments, length = 2;
                        if (!isObject(object)) {
                            return object;
                        }
                        if (typeof args[2] != "number") {
                            length = args.length;
                        }
                        if (length > 3 && typeof args[length - 2] == "function") {
                            var callback = baseCreateCallback(args[--length - 1], args[length--], 2);
                        } else if (length > 2 && typeof args[length - 1] == "function") {
                            callback = args[--length];
                        }
                        var sources = slice(arguments, 1, length), index = -1, stackA = getArray(), stackB = getArray();
                        while (++index < length) {
                            baseMerge(object, sources[index], callback, stackA, stackB);
                        }
                        releaseArray(stackA);
                        releaseArray(stackB);
                        return object;
                    }
                    function omit(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var props = [];
                            forIn(object, function(value, key) {
                                props.push(key);
                            });
                            props = baseDifference(props, baseFlatten(arguments, true, false, 1));
                            var index = -1, length = props.length;
                            while (++index < length) {
                                var key = props[index];
                                result[key] = object[key];
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (!callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function pairs(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            var key = props[index];
                            result[index] = [ key, object[key] ];
                        }
                        return result;
                    }
                    function pick(object, callback, thisArg) {
                        var result = {};
                        if (typeof callback != "function") {
                            var index = -1, props = baseFlatten(arguments, true, false, 1), length = isObject(object) ? props.length : 0;
                            while (++index < length) {
                                var key = props[index];
                                if (key in object) {
                                    result[key] = object[key];
                                }
                            }
                        } else {
                            callback = lodash.createCallback(callback, thisArg, 3);
                            forIn(object, function(value, key, object) {
                                if (callback(value, key, object)) {
                                    result[key] = value;
                                }
                            });
                        }
                        return result;
                    }
                    function transform(object, callback, accumulator, thisArg) {
                        var isArr = isArray(object);
                        if (accumulator == null) {
                            if (isArr) {
                                accumulator = [];
                            } else {
                                var ctor = object && object.constructor, proto = ctor && ctor.prototype;
                                accumulator = baseCreate(proto);
                            }
                        }
                        if (callback) {
                            callback = lodash.createCallback(callback, thisArg, 4);
                            (isArr ? forEach : forOwn)(object, function(value, index, object) {
                                return callback(accumulator, value, index, object);
                            });
                        }
                        return accumulator;
                    }
                    function values(object) {
                        var index = -1, props = keys(object), length = props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = object[props[index]];
                        }
                        return result;
                    }
                    function at(collection) {
                        var args = arguments, index = -1, props = baseFlatten(args, true, false, 1), length = args[2] && args[2][args[1]] === collection ? 1 : props.length, result = Array(length);
                        while (++index < length) {
                            result[index] = collection[props[index]];
                        }
                        return result;
                    }
                    function contains(collection, target, fromIndex) {
                        var index = -1, indexOf = getIndexOf(), length = collection ? collection.length : 0, result = false;
                        fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
                        if (isArray(collection)) {
                            result = indexOf(collection, target, fromIndex) > -1;
                        } else if (typeof length == "number") {
                            result = (isString(collection) ? collection.indexOf(target, fromIndex) : indexOf(collection, target, fromIndex)) > -1;
                        } else {
                            forOwn(collection, function(value) {
                                if (++index >= fromIndex) {
                                    return !(result = value === target);
                                }
                            });
                        }
                        return result;
                    }
                    var countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1;
                    });
                    function every(collection, callback, thisArg) {
                        var result = true;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (!(result = !!callback(collection[index], index, collection))) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return result = !!callback(value, index, collection);
                            });
                        }
                        return result;
                    }
                    function filter(collection, callback, thisArg) {
                        var result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result.push(value);
                                }
                            });
                        }
                        return result;
                    }
                    function find(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                var value = collection[index];
                                if (callback(value, index, collection)) {
                                    return value;
                                }
                            }
                        } else {
                            var result;
                            forOwn(collection, function(value, index, collection) {
                                if (callback(value, index, collection)) {
                                    result = value;
                                    return false;
                                }
                            });
                            return result;
                        }
                    }
                    function findLast(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        forEachRight(collection, function(value, index, collection) {
                            if (callback(value, index, collection)) {
                                result = value;
                                return false;
                            }
                        });
                        return result;
                    }
                    function forEach(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (callback(collection[index], index, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, callback);
                        }
                        return collection;
                    }
                    function forEachRight(collection, callback, thisArg) {
                        var length = collection ? collection.length : 0;
                        callback = callback && typeof thisArg == "undefined" ? callback : baseCreateCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            while (length--) {
                                if (callback(collection[length], length, collection) === false) {
                                    break;
                                }
                            }
                        } else {
                            var props = keys(collection);
                            length = props.length;
                            forOwn(collection, function(value, key, collection) {
                                key = props ? props[--length] : --length;
                                return callback(collection[key], key, collection);
                            });
                        }
                        return collection;
                    }
                    var groupBy = createAggregator(function(result, value, key) {
                        (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
                    });
                    var indexBy = createAggregator(function(result, value, key) {
                        result[key] = value;
                    });
                    function invoke(collection, methodName) {
                        var args = slice(arguments, 2), index = -1, isFunc = typeof methodName == "function", length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
                        });
                        return result;
                    }
                    function map(collection, callback, thisArg) {
                        var index = -1, length = collection ? collection.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        if (typeof length == "number") {
                            var result = Array(length);
                            while (++index < length) {
                                result[index] = callback(collection[index], index, collection);
                            }
                        } else {
                            result = [];
                            forOwn(collection, function(value, key, collection) {
                                result[++index] = callback(value, key, collection);
                            });
                        }
                        return result;
                    }
                    function max(collection, callback, thisArg) {
                        var computed = -Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value > result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current > computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    function min(collection, callback, thisArg) {
                        var computed = Infinity, result = computed;
                        if (typeof callback != "function" && thisArg && thisArg[callback] === collection) {
                            callback = null;
                        }
                        if (callback == null && isArray(collection)) {
                            var index = -1, length = collection.length;
                            while (++index < length) {
                                var value = collection[index];
                                if (value < result) {
                                    result = value;
                                }
                            }
                        } else {
                            callback = callback == null && isString(collection) ? charAtCallback : lodash.createCallback(callback, thisArg, 3);
                            forEach(collection, function(value, index, collection) {
                                var current = callback(value, index, collection);
                                if (current < computed) {
                                    computed = current;
                                    result = value;
                                }
                            });
                        }
                        return result;
                    }
                    var pluck = map;
                    function reduce(collection, callback, accumulator, thisArg) {
                        if (!collection) return accumulator;
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        var index = -1, length = collection.length;
                        if (typeof length == "number") {
                            if (noaccum) {
                                accumulator = collection[++index];
                            }
                            while (++index < length) {
                                accumulator = callback(accumulator, collection[index], index, collection);
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                            });
                        }
                        return accumulator;
                    }
                    function reduceRight(collection, callback, accumulator, thisArg) {
                        var noaccum = arguments.length < 3;
                        callback = lodash.createCallback(callback, thisArg, 4);
                        forEachRight(collection, function(value, index, collection) {
                            accumulator = noaccum ? (noaccum = false, value) : callback(accumulator, value, index, collection);
                        });
                        return accumulator;
                    }
                    function reject(collection, callback, thisArg) {
                        callback = lodash.createCallback(callback, thisArg, 3);
                        return filter(collection, function(value, index, collection) {
                            return !callback(value, index, collection);
                        });
                    }
                    function sample(collection, n, guard) {
                        if (collection && typeof collection.length != "number") {
                            collection = values(collection);
                        }
                        if (n == null || guard) {
                            return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
                        }
                        var result = shuffle(collection);
                        result.length = nativeMin(nativeMax(0, n), result.length);
                        return result;
                    }
                    function shuffle(collection) {
                        var index = -1, length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        forEach(collection, function(value) {
                            var rand = baseRandom(0, ++index);
                            result[index] = result[rand];
                            result[rand] = value;
                        });
                        return result;
                    }
                    function size(collection) {
                        var length = collection ? collection.length : 0;
                        return typeof length == "number" ? length : keys(collection).length;
                    }
                    function some(collection, callback, thisArg) {
                        var result;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        var index = -1, length = collection ? collection.length : 0;
                        if (typeof length == "number") {
                            while (++index < length) {
                                if (result = callback(collection[index], index, collection)) {
                                    break;
                                }
                            }
                        } else {
                            forOwn(collection, function(value, index, collection) {
                                return !(result = callback(value, index, collection));
                            });
                        }
                        return !!result;
                    }
                    function sortBy(collection, callback, thisArg) {
                        var index = -1, isArr = isArray(callback), length = collection ? collection.length : 0, result = Array(typeof length == "number" ? length : 0);
                        if (!isArr) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        forEach(collection, function(value, key, collection) {
                            var object = result[++index] = getObject();
                            if (isArr) {
                                object.criteria = map(callback, function(key) {
                                    return value[key];
                                });
                            } else {
                                (object.criteria = getArray())[0] = callback(value, key, collection);
                            }
                            object.index = index;
                            object.value = value;
                        });
                        length = result.length;
                        result.sort(compareAscending);
                        while (length--) {
                            var object = result[length];
                            result[length] = object.value;
                            if (!isArr) {
                                releaseArray(object.criteria);
                            }
                            releaseObject(object);
                        }
                        return result;
                    }
                    function toArray(collection) {
                        if (collection && typeof collection.length == "number") {
                            return slice(collection);
                        }
                        return values(collection);
                    }
                    var where = filter;
                    function compact(array) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        while (++index < length) {
                            var value = array[index];
                            if (value) {
                                result.push(value);
                            }
                        }
                        return result;
                    }
                    function difference(array) {
                        return baseDifference(array, baseFlatten(arguments, true, true, 1));
                    }
                    function findIndex(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            if (callback(array[index], index, array)) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function findLastIndex(array, callback, thisArg) {
                        var length = array ? array.length : 0;
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (length--) {
                            if (callback(array[length], length, array)) {
                                return length;
                            }
                        }
                        return -1;
                    }
                    function first(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = -1;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[0] : undefined;
                            }
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, n), length));
                    }
                    function flatten(array, isShallow, callback, thisArg) {
                        if (typeof isShallow != "boolean" && isShallow != null) {
                            thisArg = callback;
                            callback = typeof isShallow != "function" && thisArg && thisArg[isShallow] === array ? null : isShallow;
                            isShallow = false;
                        }
                        if (callback != null) {
                            array = map(array, callback, thisArg);
                        }
                        return baseFlatten(array, isShallow);
                    }
                    function indexOf(array, value, fromIndex) {
                        if (typeof fromIndex == "number") {
                            var length = array ? array.length : 0;
                            fromIndex = fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0;
                        } else if (fromIndex) {
                            var index = sortedIndex(array, value);
                            return array[index] === value ? index : -1;
                        }
                        return baseIndexOf(array, value, fromIndex);
                    }
                    function initial(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : callback || n;
                        }
                        return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
                    }
                    function intersection() {
                        var args = [], argsIndex = -1, argsLength = arguments.length, caches = getArray(), indexOf = getIndexOf(), trustIndexOf = indexOf === baseIndexOf, seen = getArray();
                        while (++argsIndex < argsLength) {
                            var value = arguments[argsIndex];
                            if (isArray(value) || isArguments(value)) {
                                args.push(value);
                                caches.push(trustIndexOf && value.length >= largeArraySize && createCache(argsIndex ? args[argsIndex] : seen));
                            }
                        }
                        var array = args[0], index = -1, length = array ? array.length : 0, result = [];
                        outer: while (++index < length) {
                            var cache = caches[0];
                            value = array[index];
                            if ((cache ? cacheIndexOf(cache, value) : indexOf(seen, value)) < 0) {
                                argsIndex = argsLength;
                                (cache || seen).push(value);
                                while (--argsIndex) {
                                    cache = caches[argsIndex];
                                    if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value)) < 0) {
                                        continue outer;
                                    }
                                }
                                result.push(value);
                            }
                        }
                        while (argsLength--) {
                            cache = caches[argsLength];
                            if (cache) {
                                releaseObject(cache);
                            }
                        }
                        releaseArray(caches);
                        releaseArray(seen);
                        return result;
                    }
                    function last(array, callback, thisArg) {
                        var n = 0, length = array ? array.length : 0;
                        if (typeof callback != "number" && callback != null) {
                            var index = length;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (index-- && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback;
                            if (n == null || thisArg) {
                                return array ? array[length - 1] : undefined;
                            }
                        }
                        return slice(array, nativeMax(0, length - n));
                    }
                    function lastIndexOf(array, value, fromIndex) {
                        var index = array ? array.length : 0;
                        if (typeof fromIndex == "number") {
                            index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
                        }
                        while (index--) {
                            if (array[index] === value) {
                                return index;
                            }
                        }
                        return -1;
                    }
                    function pull(array) {
                        var args = arguments, argsIndex = 0, argsLength = args.length, length = array ? array.length : 0;
                        while (++argsIndex < argsLength) {
                            var index = -1, value = args[argsIndex];
                            while (++index < length) {
                                if (array[index] === value) {
                                    splice.call(array, index--, 1);
                                    length--;
                                }
                            }
                        }
                        return array;
                    }
                    function range(start, end, step) {
                        start = +start || 0;
                        step = typeof step == "number" ? step : +step || 1;
                        if (end == null) {
                            end = start;
                            start = 0;
                        }
                        var index = -1, length = nativeMax(0, ceil((end - start) / (step || 1))), result = Array(length);
                        while (++index < length) {
                            result[index] = start;
                            start += step;
                        }
                        return result;
                    }
                    function remove(array, callback, thisArg) {
                        var index = -1, length = array ? array.length : 0, result = [];
                        callback = lodash.createCallback(callback, thisArg, 3);
                        while (++index < length) {
                            var value = array[index];
                            if (callback(value, index, array)) {
                                result.push(value);
                                splice.call(array, index--, 1);
                                length--;
                            }
                        }
                        return result;
                    }
                    function rest(array, callback, thisArg) {
                        if (typeof callback != "number" && callback != null) {
                            var n = 0, index = -1, length = array ? array.length : 0;
                            callback = lodash.createCallback(callback, thisArg, 3);
                            while (++index < length && callback(array[index], index, array)) {
                                n++;
                            }
                        } else {
                            n = callback == null || thisArg ? 1 : nativeMax(0, callback);
                        }
                        return slice(array, n);
                    }
                    function sortedIndex(array, value, callback, thisArg) {
                        var low = 0, high = array ? array.length : low;
                        callback = callback ? lodash.createCallback(callback, thisArg, 1) : identity;
                        value = callback(value);
                        while (low < high) {
                            var mid = low + high >>> 1;
                            callback(array[mid]) < value ? low = mid + 1 : high = mid;
                        }
                        return low;
                    }
                    function union() {
                        return baseUniq(baseFlatten(arguments, true, true));
                    }
                    function uniq(array, isSorted, callback, thisArg) {
                        if (typeof isSorted != "boolean" && isSorted != null) {
                            thisArg = callback;
                            callback = typeof isSorted != "function" && thisArg && thisArg[isSorted] === array ? null : isSorted;
                            isSorted = false;
                        }
                        if (callback != null) {
                            callback = lodash.createCallback(callback, thisArg, 3);
                        }
                        return baseUniq(array, isSorted, callback);
                    }
                    function without(array) {
                        return baseDifference(array, slice(arguments, 1));
                    }
                    function xor() {
                        var index = -1, length = arguments.length;
                        while (++index < length) {
                            var array = arguments[index];
                            if (isArray(array) || isArguments(array)) {
                                var result = result ? baseUniq(baseDifference(result, array).concat(baseDifference(array, result))) : array;
                            }
                        }
                        return result || [];
                    }
                    function zip() {
                        var array = arguments.length > 1 ? arguments : arguments[0], index = -1, length = array ? max(pluck(array, "length")) : 0, result = Array(length < 0 ? 0 : length);
                        while (++index < length) {
                            result[index] = pluck(array, index);
                        }
                        return result;
                    }
                    function zipObject(keys, values) {
                        var index = -1, length = keys ? keys.length : 0, result = {};
                        if (!values && length && !isArray(keys[0])) {
                            values = [];
                        }
                        while (++index < length) {
                            var key = keys[index];
                            if (values) {
                                result[key] = values[index];
                            } else if (key) {
                                result[key[0]] = key[1];
                            }
                        }
                        return result;
                    }
                    function after(n, func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (--n < 1) {
                                return func.apply(this, arguments);
                            }
                        };
                    }
                    function bind(func, thisArg) {
                        return arguments.length > 2 ? createWrapper(func, 17, slice(arguments, 2), null, thisArg) : createWrapper(func, 1, null, null, thisArg);
                    }
                    function bindAll(object) {
                        var funcs = arguments.length > 1 ? baseFlatten(arguments, true, false, 1) : functions(object), index = -1, length = funcs.length;
                        while (++index < length) {
                            var key = funcs[index];
                            object[key] = createWrapper(object[key], 1, null, null, object);
                        }
                        return object;
                    }
                    function bindKey(object, key) {
                        return arguments.length > 2 ? createWrapper(key, 19, slice(arguments, 2), null, object) : createWrapper(key, 3, null, null, object);
                    }
                    function compose() {
                        var funcs = arguments, length = funcs.length;
                        while (length--) {
                            if (!isFunction(funcs[length])) {
                                throw new TypeError();
                            }
                        }
                        return function() {
                            var args = arguments, length = funcs.length;
                            while (length--) {
                                args = [ funcs[length].apply(this, args) ];
                            }
                            return args[0];
                        };
                    }
                    function curry(func, arity) {
                        arity = typeof arity == "number" ? arity : +arity || func.length;
                        return createWrapper(func, 4, null, null, null, arity);
                    }
                    function debounce(func, wait, options) {
                        var args, maxTimeoutId, result, stamp, thisArg, timeoutId, trailingCall, lastCalled = 0, maxWait = false, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        wait = nativeMax(0, wait) || 0;
                        if (options === true) {
                            var leading = true;
                            trailing = false;
                        } else if (isObject(options)) {
                            leading = options.leading;
                            maxWait = "maxWait" in options && (nativeMax(wait, options.maxWait) || 0);
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        var delayed = function() {
                            var remaining = wait - (now() - stamp);
                            if (remaining <= 0) {
                                if (maxTimeoutId) {
                                    clearTimeout(maxTimeoutId);
                                }
                                var isCalled = trailingCall;
                                maxTimeoutId = timeoutId = trailingCall = undefined;
                                if (isCalled) {
                                    lastCalled = now();
                                    result = func.apply(thisArg, args);
                                    if (!timeoutId && !maxTimeoutId) {
                                        args = thisArg = null;
                                    }
                                }
                            } else {
                                timeoutId = setTimeout(delayed, remaining);
                            }
                        };
                        var maxDelayed = function() {
                            if (timeoutId) {
                                clearTimeout(timeoutId);
                            }
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if (trailing || maxWait !== wait) {
                                lastCalled = now();
                                result = func.apply(thisArg, args);
                                if (!timeoutId && !maxTimeoutId) {
                                    args = thisArg = null;
                                }
                            }
                        };
                        return function() {
                            args = arguments;
                            stamp = now();
                            thisArg = this;
                            trailingCall = trailing && (timeoutId || !leading);
                            if (maxWait === false) {
                                var leadingCall = leading && !timeoutId;
                            } else {
                                if (!maxTimeoutId && !leading) {
                                    lastCalled = stamp;
                                }
                                var remaining = maxWait - (stamp - lastCalled), isCalled = remaining <= 0;
                                if (isCalled) {
                                    if (maxTimeoutId) {
                                        maxTimeoutId = clearTimeout(maxTimeoutId);
                                    }
                                    lastCalled = stamp;
                                    result = func.apply(thisArg, args);
                                } else if (!maxTimeoutId) {
                                    maxTimeoutId = setTimeout(maxDelayed, remaining);
                                }
                            }
                            if (isCalled && timeoutId) {
                                timeoutId = clearTimeout(timeoutId);
                            } else if (!timeoutId && wait !== maxWait) {
                                timeoutId = setTimeout(delayed, wait);
                            }
                            if (leadingCall) {
                                isCalled = true;
                                result = func.apply(thisArg, args);
                            }
                            if (isCalled && !timeoutId && !maxTimeoutId) {
                                args = thisArg = null;
                            }
                            return result;
                        };
                    }
                    function defer(func) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 1);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, 1);
                    }
                    function delay(func, wait) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var args = slice(arguments, 2);
                        return setTimeout(function() {
                            func.apply(undefined, args);
                        }, wait);
                    }
                    function memoize(func, resolver) {
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        var memoized = function() {
                            var cache = memoized.cache, key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
                            return hasOwnProperty.call(cache, key) ? cache[key] : cache[key] = func.apply(this, arguments);
                        };
                        memoized.cache = {};
                        return memoized;
                    }
                    function once(func) {
                        var ran, result;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        return function() {
                            if (ran) {
                                return result;
                            }
                            ran = true;
                            result = func.apply(this, arguments);
                            func = null;
                            return result;
                        };
                    }
                    function partial(func) {
                        return createWrapper(func, 16, slice(arguments, 1));
                    }
                    function partialRight(func) {
                        return createWrapper(func, 32, null, slice(arguments, 1));
                    }
                    function throttle(func, wait, options) {
                        var leading = true, trailing = true;
                        if (!isFunction(func)) {
                            throw new TypeError();
                        }
                        if (options === false) {
                            leading = false;
                        } else if (isObject(options)) {
                            leading = "leading" in options ? options.leading : leading;
                            trailing = "trailing" in options ? options.trailing : trailing;
                        }
                        debounceOptions.leading = leading;
                        debounceOptions.maxWait = wait;
                        debounceOptions.trailing = trailing;
                        return debounce(func, wait, debounceOptions);
                    }
                    function wrap(value, wrapper) {
                        return createWrapper(wrapper, 16, [ value ]);
                    }
                    function constant(value) {
                        return function() {
                            return value;
                        };
                    }
                    function createCallback(func, thisArg, argCount) {
                        var type = typeof func;
                        if (func == null || type == "function") {
                            return baseCreateCallback(func, thisArg, argCount);
                        }
                        if (type != "object") {
                            return property(func);
                        }
                        var props = keys(func), key = props[0], a = func[key];
                        if (props.length == 1 && a === a && !isObject(a)) {
                            return function(object) {
                                var b = object[key];
                                return a === b && (a !== 0 || 1 / a == 1 / b);
                            };
                        }
                        return function(object) {
                            var length = props.length, result = false;
                            while (length--) {
                                if (!(result = baseIsEqual(object[props[length]], func[props[length]], null, true))) {
                                    break;
                                }
                            }
                            return result;
                        };
                    }
                    function escape(string) {
                        return string == null ? "" : String(string).replace(reUnescapedHtml, escapeHtmlChar);
                    }
                    function identity(value) {
                        return value;
                    }
                    function mixin(object, source, options) {
                        var chain = true, methodNames = source && functions(source);
                        if (!source || !options && !methodNames.length) {
                            if (options == null) {
                                options = source;
                            }
                            ctor = lodashWrapper;
                            source = object;
                            object = lodash;
                            methodNames = functions(source);
                        }
                        if (options === false) {
                            chain = false;
                        } else if (isObject(options) && "chain" in options) {
                            chain = options.chain;
                        }
                        var ctor = object, isFunc = isFunction(ctor);
                        forEach(methodNames, function(methodName) {
                            var func = object[methodName] = source[methodName];
                            if (isFunc) {
                                ctor.prototype[methodName] = function() {
                                    var chainAll = this.__chain__, value = this.__wrapped__, args = [ value ];
                                    push.apply(args, arguments);
                                    var result = func.apply(object, args);
                                    if (chain || chainAll) {
                                        if (value === result && isObject(result)) {
                                            return this;
                                        }
                                        result = new ctor(result);
                                        result.__chain__ = chainAll;
                                    }
                                    return result;
                                };
                            }
                        });
                    }
                    function noConflict() {
                        context._ = oldDash;
                        return this;
                    }
                    function noop() {}
                    var now = isNative(now = Date.now) && now || function() {
                        return new Date().getTime();
                    };
                    var parseInt = nativeParseInt(whitespace + "08") == 8 ? nativeParseInt : function(value, radix) {
                        return nativeParseInt(isString(value) ? value.replace(reLeadingSpacesAndZeros, "") : value, radix || 0);
                    };
                    function property(key) {
                        return function(object) {
                            return object[key];
                        };
                    }
                    function random(min, max, floating) {
                        var noMin = min == null, noMax = max == null;
                        if (floating == null) {
                            if (typeof min == "boolean" && noMax) {
                                floating = min;
                                min = 1;
                            } else if (!noMax && typeof max == "boolean") {
                                floating = max;
                                noMax = true;
                            }
                        }
                        if (noMin && noMax) {
                            max = 1;
                        }
                        min = +min || 0;
                        if (noMax) {
                            max = min;
                            min = 0;
                        } else {
                            max = +max || 0;
                        }
                        if (floating || min % 1 || max % 1) {
                            var rand = nativeRandom();
                            return nativeMin(min + rand * (max - min + parseFloat("1e-" + ((rand + "").length - 1))), max);
                        }
                        return baseRandom(min, max);
                    }
                    function result(object, key) {
                        if (object) {
                            var value = object[key];
                            return isFunction(value) ? object[key]() : value;
                        }
                    }
                    function template(text, data, options) {
                        var settings = lodash.templateSettings;
                        text = String(text || "");
                        options = defaults({}, options, settings);
                        var imports = defaults({}, options.imports, settings.imports), importsKeys = keys(imports), importsValues = values(imports);
                        var isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                        var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
                        text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                            interpolateValue || (interpolateValue = esTemplateValue);
                            source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                            if (escapeValue) {
                                source += "' +\n__e(" + escapeValue + ") +\n'";
                            }
                            if (evaluateValue) {
                                isEvaluating = true;
                                source += "';\n" + evaluateValue + ";\n__p += '";
                            }
                            if (interpolateValue) {
                                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                            }
                            index = offset + match.length;
                            return match;
                        });
                        source += "';\n";
                        var variable = options.variable, hasVariable = variable;
                        if (!hasVariable) {
                            variable = "obj";
                            source = "with (" + variable + ") {\n" + source + "\n}\n";
                        }
                        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                        source = "function(" + variable + ") {\n" + (hasVariable ? "" : variable + " || (" + variable + " = {});\n") + "var __t, __p = '', __e = _.escape" + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                        var sourceURL = "\n/*\n//# sourceURL=" + (options.sourceURL || "/lodash/template/source[" + templateCounter++ + "]") + "\n*/";
                        try {
                            var result = Function(importsKeys, "return " + source + sourceURL).apply(undefined, importsValues);
                        } catch (e) {
                            e.source = source;
                            throw e;
                        }
                        if (data) {
                            return result(data);
                        }
                        result.source = source;
                        return result;
                    }
                    function times(n, callback, thisArg) {
                        n = (n = +n) > -1 ? n : 0;
                        var index = -1, result = Array(n);
                        callback = baseCreateCallback(callback, thisArg, 1);
                        while (++index < n) {
                            result[index] = callback(index);
                        }
                        return result;
                    }
                    function unescape(string) {
                        return string == null ? "" : String(string).replace(reEscapedHtml, unescapeHtmlChar);
                    }
                    function uniqueId(prefix) {
                        var id = ++idCounter;
                        return String(prefix == null ? "" : prefix) + id;
                    }
                    function chain(value) {
                        value = new lodashWrapper(value);
                        value.__chain__ = true;
                        return value;
                    }
                    function tap(value, interceptor) {
                        interceptor(value);
                        return value;
                    }
                    function wrapperChain() {
                        this.__chain__ = true;
                        return this;
                    }
                    function wrapperToString() {
                        return String(this.__wrapped__);
                    }
                    function wrapperValueOf() {
                        return this.__wrapped__;
                    }
                    lodash.after = after;
                    lodash.assign = assign;
                    lodash.at = at;
                    lodash.bind = bind;
                    lodash.bindAll = bindAll;
                    lodash.bindKey = bindKey;
                    lodash.chain = chain;
                    lodash.compact = compact;
                    lodash.compose = compose;
                    lodash.constant = constant;
                    lodash.countBy = countBy;
                    lodash.create = create;
                    lodash.createCallback = createCallback;
                    lodash.curry = curry;
                    lodash.debounce = debounce;
                    lodash.defaults = defaults;
                    lodash.defer = defer;
                    lodash.delay = delay;
                    lodash.difference = difference;
                    lodash.filter = filter;
                    lodash.flatten = flatten;
                    lodash.forEach = forEach;
                    lodash.forEachRight = forEachRight;
                    lodash.forIn = forIn;
                    lodash.forInRight = forInRight;
                    lodash.forOwn = forOwn;
                    lodash.forOwnRight = forOwnRight;
                    lodash.functions = functions;
                    lodash.groupBy = groupBy;
                    lodash.indexBy = indexBy;
                    lodash.initial = initial;
                    lodash.intersection = intersection;
                    lodash.invert = invert;
                    lodash.invoke = invoke;
                    lodash.keys = keys;
                    lodash.map = map;
                    lodash.mapValues = mapValues;
                    lodash.max = max;
                    lodash.memoize = memoize;
                    lodash.merge = merge;
                    lodash.min = min;
                    lodash.omit = omit;
                    lodash.once = once;
                    lodash.pairs = pairs;
                    lodash.partial = partial;
                    lodash.partialRight = partialRight;
                    lodash.pick = pick;
                    lodash.pluck = pluck;
                    lodash.property = property;
                    lodash.pull = pull;
                    lodash.range = range;
                    lodash.reject = reject;
                    lodash.remove = remove;
                    lodash.rest = rest;
                    lodash.shuffle = shuffle;
                    lodash.sortBy = sortBy;
                    lodash.tap = tap;
                    lodash.throttle = throttle;
                    lodash.times = times;
                    lodash.toArray = toArray;
                    lodash.transform = transform;
                    lodash.union = union;
                    lodash.uniq = uniq;
                    lodash.values = values;
                    lodash.where = where;
                    lodash.without = without;
                    lodash.wrap = wrap;
                    lodash.xor = xor;
                    lodash.zip = zip;
                    lodash.zipObject = zipObject;
                    lodash.collect = map;
                    lodash.drop = rest;
                    lodash.each = forEach;
                    lodash.eachRight = forEachRight;
                    lodash.extend = assign;
                    lodash.methods = functions;
                    lodash.object = zipObject;
                    lodash.select = filter;
                    lodash.tail = rest;
                    lodash.unique = uniq;
                    lodash.unzip = zip;
                    mixin(lodash);
                    lodash.clone = clone;
                    lodash.cloneDeep = cloneDeep;
                    lodash.contains = contains;
                    lodash.escape = escape;
                    lodash.every = every;
                    lodash.find = find;
                    lodash.findIndex = findIndex;
                    lodash.findKey = findKey;
                    lodash.findLast = findLast;
                    lodash.findLastIndex = findLastIndex;
                    lodash.findLastKey = findLastKey;
                    lodash.has = has;
                    lodash.identity = identity;
                    lodash.indexOf = indexOf;
                    lodash.isArguments = isArguments;
                    lodash.isArray = isArray;
                    lodash.isBoolean = isBoolean;
                    lodash.isDate = isDate;
                    lodash.isElement = isElement;
                    lodash.isEmpty = isEmpty;
                    lodash.isEqual = isEqual;
                    lodash.isFinite = isFinite;
                    lodash.isFunction = isFunction;
                    lodash.isNaN = isNaN;
                    lodash.isNull = isNull;
                    lodash.isNumber = isNumber;
                    lodash.isObject = isObject;
                    lodash.isPlainObject = isPlainObject;
                    lodash.isRegExp = isRegExp;
                    lodash.isString = isString;
                    lodash.isUndefined = isUndefined;
                    lodash.lastIndexOf = lastIndexOf;
                    lodash.mixin = mixin;
                    lodash.noConflict = noConflict;
                    lodash.noop = noop;
                    lodash.now = now;
                    lodash.parseInt = parseInt;
                    lodash.random = random;
                    lodash.reduce = reduce;
                    lodash.reduceRight = reduceRight;
                    lodash.result = result;
                    lodash.runInContext = runInContext;
                    lodash.size = size;
                    lodash.some = some;
                    lodash.sortedIndex = sortedIndex;
                    lodash.template = template;
                    lodash.unescape = unescape;
                    lodash.uniqueId = uniqueId;
                    lodash.all = every;
                    lodash.any = some;
                    lodash.detect = find;
                    lodash.findWhere = find;
                    lodash.foldl = reduce;
                    lodash.foldr = reduceRight;
                    lodash.include = contains;
                    lodash.inject = reduce;
                    mixin(function() {
                        var source = {};
                        forOwn(lodash, function(func, methodName) {
                            if (!lodash.prototype[methodName]) {
                                source[methodName] = func;
                            }
                        });
                        return source;
                    }(), false);
                    lodash.first = first;
                    lodash.last = last;
                    lodash.sample = sample;
                    lodash.take = first;
                    lodash.head = first;
                    forOwn(lodash, function(func, methodName) {
                        var callbackable = methodName !== "sample";
                        if (!lodash.prototype[methodName]) {
                            lodash.prototype[methodName] = function(n, guard) {
                                var chainAll = this.__chain__, result = func(this.__wrapped__, n, guard);
                                return !chainAll && (n == null || guard && !(callbackable && typeof n == "function")) ? result : new lodashWrapper(result, chainAll);
                            };
                        }
                    });
                    lodash.VERSION = "2.4.1";
                    lodash.prototype.chain = wrapperChain;
                    lodash.prototype.toString = wrapperToString;
                    lodash.prototype.value = wrapperValueOf;
                    lodash.prototype.valueOf = wrapperValueOf;
                    forEach([ "join", "pop", "shift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            var chainAll = this.__chain__, result = func.apply(this.__wrapped__, arguments);
                            return chainAll ? new lodashWrapper(result, chainAll) : result;
                        };
                    });
                    forEach([ "push", "reverse", "sort", "unshift" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            func.apply(this.__wrapped__, arguments);
                            return this;
                        };
                    });
                    forEach([ "concat", "slice", "splice" ], function(methodName) {
                        var func = arrayRef[methodName];
                        lodash.prototype[methodName] = function() {
                            return new lodashWrapper(func.apply(this.__wrapped__, arguments), this.__chain__);
                        };
                    });
                    return lodash;
                }
                var _ = runInContext();
                if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
                    root._ = _;
                    define(function() {
                        return _;
                    });
                } else if (freeExports && freeModule) {
                    if (moduleExports) {
                        (freeModule.exports = _)._ = _;
                    } else {
                        freeExports._ = _;
                    }
                } else {
                    root._ = _;
                }
            }).call(this);
        }).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {} ],
    2: [ function(require, module, exports) {
        module.exports = function(element, callback) {
            function addResizeListener(element, callback) {
                if (window.OverflowEvent) {
                    element.addEventListener("overflowchanged", function(e) {
                        callback.call(this, e);
                    });
                } else {
                    element.addEventListener("overflow", function(e) {
                        callback.call(this, e);
                    });
                    element.addEventListener("underflow", function(e) {
                        callback.call(this, e);
                    });
                }
            }
            function EventQueue() {
                this.q = [];
                this.add = function(ev) {
                    this.q.push(ev);
                };
                var i, j;
                this.call = function() {
                    for (i = 0, j = this.q.length; i < j; i++) {
                        this.q[i].call();
                    }
                };
            }
            function getComputedStyle(element, prop) {
                if (element.currentStyle) {
                    return element.currentStyle[prop];
                } else if (window.getComputedStyle) {
                    return window.getComputedStyle(element, null).getPropertyValue(prop);
                } else {
                    return element.style[prop];
                }
            }
            function attachResizeEvent(element, resized) {
                if (!element.resizedAttached) {
                    element.resizedAttached = new EventQueue();
                    element.resizedAttached.add(resized);
                } else if (element.resizedAttached) {
                    element.resizedAttached.add(resized);
                    return;
                }
                var myResized = function() {
                    if (setupSensor()) {
                        element.resizedAttached.call();
                    }
                };
                element.resizeSensor = document.createElement("div");
                element.resizeSensor.className = "resize-sensor";
                var style = "position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1;";
                element.resizeSensor.style.cssText = style;
                element.resizeSensor.innerHTML = '<div class="resize-sensor-overflow" style="' + style + '">' + "<div></div>" + "</div>" + '<div class="resize-sensor-underflow" style="' + style + '">' + "<div></div>" + "</div>";
                element.appendChild(element.resizeSensor);
                if ("absolute" !== getComputedStyle(element, "position")) {
                    element.style.position = "relative";
                }
                var x = -1, y = -1, firstStyle = element.resizeSensor.firstElementChild.firstChild.style, lastStyle = element.resizeSensor.lastElementChild.firstChild.style;
                function setupSensor() {
                    var change = false, width = element.resizeSensor.offsetWidth, height = element.resizeSensor.offsetHeight;
                    if (x != width) {
                        firstStyle.width = width - 1 + "px";
                        lastStyle.width = width + 1 + "px";
                        change = true;
                        x = width;
                    }
                    if (y != height) {
                        firstStyle.height = height - 1 + "px";
                        lastStyle.height = height + 1 + "px";
                        change = true;
                        y = height;
                    }
                    return change;
                }
                setupSensor();
                addResizeListener(element.resizeSensor, myResized);
                addResizeListener(element.resizeSensor.firstElementChild, myResized);
                addResizeListener(element.resizeSensor.lastElementChild, myResized);
            }
            if ("array" === typeof element || "undefined" !== typeof jQuery && element instanceof jQuery || "undefined" !== typeof Elements && element instanceof Elements) {
                var i = 0, j = element.length;
                for (;i < j; i++) {
                    attachResizeEvent(element[i], callback);
                }
            } else {
                attachResizeEvent(element, callback);
            }
        };
    }, {} ],
    3: [ function(require, module, exports) {
        var ResizeSensor, _;
        _ = require("lodash");
        ResizeSensor = require("./ResizeSensor");
        Polymer("ui-grid-tiler", {
            resize: function() {
                var children, visible;
                if (this.selector || this.children) {
                    children = this.querySelectorAll(this.selector);
                }
                visible = 0;
                _.each(children, function(tile) {
                    if (tile.clientWidth > 0 && tile.clientHeight > 0) {
                        return visible += 1;
                    }
                });
                return _.each(children, function(tile) {
                    var classes;
                    classes = tile.classList.impl || tile.classList;
                    _.each(classes, function(check) {
                        if (check.slice(0, 5) === "tile-") {
                            return tile.classList.remove(check);
                        }
                    });
                    return tile.classList.add("tile-" + visible);
                });
            },
            childrenMutated: function() {
                this.resize();
                return this.onMutation(this, function(_this) {
                    return function() {
                        return _this.childrenMutated();
                    };
                }(this));
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                this.sensor = new ResizeSensor(this, function(_this) {
                    return function() {
                        return _this.resize();
                    };
                }(this));
                window.addEventListener("resize", function(_this) {
                    return function() {
                        return _this.resize();
                    };
                }(this));
                this.resize();
                return this.onMutation(this, function(_this) {
                    return function() {
                        return _this.childrenMutated();
                    };
                }(this));
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {
        "./ResizeSensor": 2,
        lodash: 1
    } ]
}, {}, [ 3 ]);</script>
</polymer-element>

<polymer-element name="ui-progress" attributes="percentage">
<template>
  <style>.hide {
  display: none !important;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(0, 0, 0, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease;
  -webkit-transition: opacity 0.2s ease;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease, opacity 0.2s ease;
  -webkit-transition: height 0.2s ease, opacity 0.2s ease;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(0, 0, 0, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease, opacity 0.2s ease;
  -webkit-transition: width 0.2s ease, opacity 0.2s ease;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
.sheen {
  background-image: linear-gradient(rgba(255, 255, 255, 0.01), rgba(0, 0, 0, 0.1));
}
:host {
  display: inline-block;
}
#bar {
  display: block;
  position: fixed;
  z-index: 999999;
  top: 0;
  left: 0;
  right: 0;
  height: 2px;
  background-color: transparent;
}
#fill {
  display: inline-block;
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  background: #ef272d;
  transition: 0.2s ease;
  -webkit-transition: 0.2s ease;
}
#leader {
  display: inline-block;
  position: absolute;
  min-width: 10px;
  width: 1%;
  right: 0;
  height: 100%;
  background: #ef272d;
  box-shadow: 0 0 10px #ef272d;
}
</style>
  <section id="bar">
    <section id="fill" fadeout=""><section id="leader"></section></section>
  </section>
  <content></content>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-progress/src/ui-progress.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        var TRICKLE_RATE, TRICKLE_TIMER;
        TRICKLE_TIMER = 800;
        TRICKLE_RATE = 2;
        Polymer("ui-progress", {
            percentageChanged: function() {
                this.$.fill.style.width = "" + this.percentage + "%";
                if (Number(this.percentage) >= 100 || Number(this.percentage) <= 0) {
                    this.$.fill.setAttribute("hide", "");
                    return setTimeout(function(_this) {
                        return function() {
                            return _this.percentage = 0;
                        };
                    }(this), TRICKLE_TIMER);
                } else {
                    this.$.fill.removeAttribute("hide");
                    return setTimeout(function(_this) {
                        return function() {
                            return _this.percentage = Number(_this.percentage) + Math.random() * TRICKLE_RATE;
                        };
                    }(this), TRICKLE_TIMER);
                }
            },
            start: function(percentage) {
                return this.percentage = percentage || 1;
            },
            stop: function(percentage) {
                return this.percentage = 100;
            },
            created: function() {},
            ready: function() {},
            attached: function() {},
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<polymer-element name="ui-modal" attributes="" on-click="{{hide}}" on-transitionend="{{backgroundAnimation}}" on-animationend="{{displayAnimation}}" offscreen="" hide="">
<template>
  <style>.hide {
  display: none !important;
}
.flat {
  background-image: linear-gradient(rgba(51, 51, 51, 0.01), rgba(51, 51, 51, 0.02) 80%, rgba(51, 51, 51, 0.01));
}
.ultra-dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.85), rgba(51, 51, 51, 0.91) 80%, rgba(51, 51, 51, 0.89));
}
.dark-tint {
  background-image: linear-gradient(rgba(51, 51, 51, 0.61), rgba(51, 51, 51, 0.67) 80%, rgba(51, 51, 51, 0.65));
}
.light-tint {
  background-image: linear-gradient(rgba(255, 255, 255, 0.61), rgba(255, 255, 255, 0.67) 80%, rgba(255, 255, 255, 0.65));
}
.border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.1) inset;
}
.focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset;
}
.input-focused-border {
  box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
  -webkit-box-shadow: 0px 0px 0px 1px rgba(51, 51, 51, 0.33) inset, 0.3em 0em 0em 0em rgba(51, 51, 51, 0.33) inset;
}
.cannot-select-text {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -khtml-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
.solid.flag:before {
  font-size: 1.5em;
  content: "\25a3";
  font-style: normal;
}
.yellow.flag:before {
  -webkit-text-fill-color: #fae843;
  -webkit-text-stroke: 1px #454545;
}
.red.flag:before {
  -webkit-text-fill-color: #ef272d;
  -webkit-text-stroke: 1px #454545;
}
.green.flag:before {
  -webkit-text-fill-color: #c8ed8d;
  -webkit-text-stroke: 1px #454545;
}
.grey.flag:before {
  -webkit-text-fill-color: rgba(51, 51, 51, 0.61);
  -webkit-text-stroke: 1px #454545;
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[fadeout] {
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
[fadeout][hide] {
  opacity: 0 !important;
}
[closeup] {
  opacity: 1.0;
  transition: height 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: height 0.2s ease-out, opacity 0.2s ease-out;
}
[closeup][hide] {
  display: inline-block !important;
  height: 0 !important;
  opacity: 0 !important;
}
[tile] {
  padding: 1em;
  background-color: rgba(51, 51, 51, 0.1);
  border: 1px solid rgba(51, 51, 51, 0.1);
}
[animated] {
  opacity: 1.0;
  transition: width 0.2s ease-out, opacity 0.2s ease-out;
  -webkit-transition: width 0.2s ease-out, opacity 0.2s ease-out;
}
[animated][hide] {
  display: inline-block !important;
  width: 0 !important;
  opacity: 0 !important;
}
[offscreen] {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUp {
  animation: slideUp 1s 1 ease-out;
  -webkit-animation: slideUp 1s 1 ease-out;
}
.slideDown {
  animation: slideDown 1s 1 ease-out;
  -webkit-animation: slideDown 1s 1 ease-out;
}
.slideUpKeyframes 0% {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
.slideUpKeyframes 0% {
  transform: translateY(500%);
  -webkit-transform: translateY(500%);
}
.slideUpKeyframes 50% {
  transform: translateY(-8%);
  -webkit-transform: translateY(-8%);
}
.slideUpKeyframes 65% {
  transform: translateY(2%);
  -webkit-transform: translateY(2%);
}
.slideUpKeyframes 80% {
  transform: translateY(-2%);
  -webkit-transform: translateY(-2%);
}
.slideUpKeyframes 95% {
  transform: translateY(1%);
  -webkit-transform: translateY(1%);
}
.slideUpKeyframes 100% {
  transform: translateY(0%);
  -webkit-transform: translateY(0%);
}
@keyframes slideUp {
  0% {
    transform: translateY(2000em);
    -webkit-transform: translateY(2000em);
  }
  0% {
    transform: translateY(500%);
    -webkit-transform: translateY(500%);
  }
  50% {
    transform: translateY(-8%);
    -webkit-transform: translateY(-8%);
  }
  65% {
    transform: translateY(2%);
    -webkit-transform: translateY(2%);
  }
  80% {
    transform: translateY(-2%);
    -webkit-transform: translateY(-2%);
  }
  95% {
    transform: translateY(1%);
    -webkit-transform: translateY(1%);
  }
  100% {
    transform: translateY(0%);
    -webkit-transform: translateY(0%);
  }
}
@-webkit-keyframes slideUp {
  0% {
    transform: translateY(2000em);
    -webkit-transform: translateY(2000em);
  }
  0% {
    transform: translateY(500%);
    -webkit-transform: translateY(500%);
  }
  50% {
    transform: translateY(-8%);
    -webkit-transform: translateY(-8%);
  }
  65% {
    transform: translateY(2%);
    -webkit-transform: translateY(2%);
  }
  80% {
    transform: translateY(-2%);
    -webkit-transform: translateY(-2%);
  }
  95% {
    transform: translateY(1%);
    -webkit-transform: translateY(1%);
  }
  100% {
    transform: translateY(0%);
    -webkit-transform: translateY(0%);
  }
}
.slideDownKeyframes 0% {
  transform: translateY(0%);
  -webkit-transform: translateY(0%);
}
.slideDownKeyframes 99% {
  transform: translateY(500%);
  -webkit-transform: translateY(500%);
}
.slideDownKeyframes 100% {
  transform: translateY(2000em);
  -webkit-transform: translateY(2000em);
}
@keyframes slideDown {
  0% {
    transform: translateY(0%);
    -webkit-transform: translateY(0%);
  }
  99% {
    transform: translateY(500%);
    -webkit-transform: translateY(500%);
  }
  100% {
    transform: translateY(2000em);
    -webkit-transform: translateY(2000em);
  }
}
@-webkit-keyframes slideDown {
  0% {
    transform: translateY(0%);
    -webkit-transform: translateY(0%);
  }
  99% {
    transform: translateY(500%);
    -webkit-transform: translateY(500%);
  }
  100% {
    transform: translateY(2000em);
    -webkit-transform: translateY(2000em);
  }
}
.rainbowKeyframes 0% {
  color: #ef272d;
}
.rainbowKeyframes 20% {
  color: #ef272d;
}
.rainbowKeyframes 40% {
  color: #fae843;
}
.rainbowKeyframes 60% {
  color: #c8ed8d;
}
.rainbowKeyframes 80% {
  color: #0088cc;
}
.rainbowKeyframes 100% {
  color: #ac92ec;
}
@keyframes rainbow {
  0% {
    color: #ef272d;
  }
  20% {
    color: #ef272d;
  }
  40% {
    color: #fae843;
  }
  60% {
    color: #c8ed8d;
  }
  80% {
    color: #0088cc;
  }
  100% {
    color: #ac92ec;
  }
}
@-webkit-keyframes rainbow {
  0% {
    color: #ef272d;
  }
  20% {
    color: #ef272d;
  }
  40% {
    color: #fae843;
  }
  60% {
    color: #c8ed8d;
  }
  80% {
    color: #0088cc;
  }
  100% {
    color: #ac92ec;
  }
}
[rainbow] {
  animation: rainbow 2s infinite linear;
  -webkit-animation: rainbow 2s infinite linear;
}
[slideup] {
  animation: slideUp 0.5s 1 linear;
  -webkit-animation: slideUp 0.5s 1 linear;
}
[slidedown] {
  animation: slideDown 0.2s 1 linear;
  -webkit-animation: slideDown 0.2s 1 linear;
}
:host {
  position: fixed;
  display: flex;
  align-items: center;
  justify-content: center;
  top: 0;
  left: 0;
  right: 0;
  height: 100%;
  z-index: 999999;
  background-color: rgba(51, 51, 51, 0.61);
  opacity: 1.0;
  transition: opacity 0.2s ease-out;
  -webkit-transition: opacity 0.2s ease-out;
}
:host([hide]) {
  opacity: 0;
}
:host([offscreen]) {
  top: 10%;
}
#display {
  max-width: 50%;
  max-height: 50%;
  background-color: #ffffff;
  box-shadow: 0px 4px 1em rgba(51, 51, 51, 0.61);
  -webkit-box-shadow: 0px 4px 1em rgba(51, 51, 51, 0.61);
}
</style>
  <section id="display">
    <content></content>
  </section>
</template>
<script built="/Users/wballard/git/custom-elements/ui-toolkit/node_modules/ui-modal/src/ui-modal.litcoffee">(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;
                if (!u && a) return a(o, !0);
                if (i) return i(o, !0);
                throw new Error("Cannot find module '" + o + "'");
            }
            var f = n[o] = {
                exports: {}
            };
            t[o][0].call(f.exports, function(e) {
                var n = t[o][1][e];
                return s(n ? n : e);
            }, f, f.exports, e, t, n, r);
        }
        return n[o].exports;
    }
    var i = typeof require == "function" && require;
    for (var o = 0; o < r.length; o++) s(r[o]);
    return s;
})({
    1: [ function(require, module, exports) {
        Polymer("ui-modal", {
            show: function() {
                this.$.display.setAttribute("offscreen", "");
                this.removeAttribute("offscreen");
                this.removeAttribute("hide");
                return this.showing = true;
            },
            hide: function(evt) {
                this.$.display.setAttribute("slidedown", "");
                this.hiding = true;
                return evt != null ? evt.stopPropagation() : void 0;
            },
            backgroundAnimation: function(evt) {
                console.log("transition", evt);
                if (this.showing) {
                    this.$.display.setAttribute("slideup", "");
                }
                if (this.hiding) {
                    this.setAttribute("offscreen", "");
                    this.hiding = false;
                    return this.fire("hidden");
                }
            },
            displayAnimation: function(evt) {
                console.log("animation", evt);
                if (this.showing) {
                    this.$.display.removeAttribute("offscreen");
                    this.$.display.removeAttribute("slideup");
                    this.showing = false;
                    this.fire("shown");
                }
                if (this.hiding) {
                    this.$.display.setAttribute("offscreen", "");
                    this.$.display.removeAttribute("slidedown");
                    return this.setAttribute("hide", "");
                }
            },
            created: function() {},
            ready: function() {},
            attached: function() {
                return this.addEventListener("webkitAnimationEnd", function(_this) {
                    return function(evt) {
                        return _this.displayAnimation(evt);
                    };
                }(this));
            },
            domReady: function() {},
            detached: function() {}
        });
    }, {} ]
}, {}, [ 1 ]);</script>
</polymer-element>

<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<!--
@group Polymer Core Elements

The `core-ajax` element exposes `XMLHttpRequest` functionality.

    <core-ajax
        auto
        url="http://gdata.youtube.com/feeds/api/videos/"
        params='{"alt":"json", "q":"chrome"}'
        handleAs="json"
        on-core-response="{{handleResponse}}"></core-ajax>
 
With `auto` set to `true`, the element performs a request whenever
its `url` or `params` properties are changed.

Note: The `params` attribute must be double quoted JSON.

You can trigger a request explicitly by calling `go` on the
element.

@element core-ajax
@status beta
@homepage github.io
-->
<!--
Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<!--
/**
 * @group Polymer Core Elements
 *
 * core-xhr can be used to perform XMLHttpRequests.
 *
 *     <core-xhr id="xhr"></core-xhr>
 *     ...
 *     this.$.xhr.request({url: url, params: params, callback: callback});
 *
 * @element core-xhr
 */
-->

<!-- did not import ../polymer/polymer.html-->

<polymer-element name="core-xhr" hidden>

  <script>

    Polymer('core-xhr', {

      /**
       * Sends a HTTP request to the server and returns the XHR object.
       *
       * @method request
       * @param {Object} inOptions
       *    @param {String} inOptions.url The url to which the request is sent.
       *    @param {String} inOptions.method The HTTP method to use, default is GET.
       *    @param {boolean} inOptions.sync By default, all requests are sent asynchronously. To send synchronous requests, set to true.
       *    @param {Object} inOptions.params Data to be sent to the server.
       *    @param {Object} inOptions.body The content for the request body for POST method.
       *    @param {Object} inOptions.headers HTTP request headers.
       *    @param {String} inOptions.responseType The response type. Default is 'text'.
       *    @param {boolean} inOptions.withCredentials Whether or not to send credentials on the request. Default is false.
       *    @param {Object} inOptions.callback Called when request is completed.
       * @returns {Object} XHR object.
       */
      request: function(options) {
        var xhr = new XMLHttpRequest();
        var url = options.url;
        var method = options.method || 'GET';
        var async = !options.sync;
        //
        var params = this.toQueryString(options.params);
        if (params && method == 'GET') {
          url += (url.indexOf('?') > 0 ? '&' : '?') + params;
        }
        var xhrParams = this.isBodyMethod(method) ? (options.body || params) : null;
        //
        xhr.open(method, url, async);
        if (options.responseType) {
          xhr.responseType = options.responseType;
        }
        if (options.withCredentials) {
          xhr.withCredentials = true;
        }
        this.makeReadyStateHandler(xhr, options.callback);
        this.setRequestHeaders(xhr, options.headers);
        xhr.send(xhrParams);
        if (!async) {
          xhr.onreadystatechange(xhr);
        }
        return xhr;
      },
    
      toQueryString: function(params) {
        var r = [];
        for (var n in params) {
          var v = params[n];
          n = encodeURIComponent(n);
          r.push(v == null ? n : (n + '=' + encodeURIComponent(v)));
        }
        return r.join('&');
      },

      isBodyMethod: function(method) {
        return this.bodyMethods[(method || '').toUpperCase()];
      },
      
      bodyMethods: {
        POST: 1,
        PUT: 1,
        DELETE: 1
      },

      makeReadyStateHandler: function(xhr, callback) {
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            callback && callback.call(null, xhr.response, xhr);
          }
        };
      },

      setRequestHeaders: function(xhr, headers) {
        if (headers) {
          for (var name in headers) {
            xhr.setRequestHeader(name, headers[name]);
          }
        }
      }

    });

  </script>
  
</polymer-element>

<polymer-element name="core-ajax" attributes="url handleAs auto params response method headers body contentType withCredentials">
  <script>

    Polymer('core-ajax', {
      /**
       * Fired when a response is received.
       * 
       * @event core-response
       */
 
      /**
       * Fired when an error is received.
       * 
       * @event core-error
       */
 
      /**
       * Fired whenever a response or an error is received.
       *
       * @event core-complete
       */

      /**
       * The URL target of the request.
       * 
       * @attribute url
       * @type string
       * @default ''
       */
      url: '',

      /**
       * Specifies what data to store in the `response` property, and
       * to deliver as `event.response` in `response` events.
       * 
       * One of:
       * 
       *    `text`: uses `XHR.responseText`.
       *    
       *    `xml`: uses `XHR.responseXML`.
       *    
       *    `json`: uses `XHR.responseText` parsed as JSON.
       *
       *    `arraybuffer`: uses `XHR.response`.
       *
       *    `blob`: uses `XHR.response`.
       *
       *    `document`: uses `XHR.response`.
       *  
       * @attribute handleAs
       * @type string
       * @default 'text'
       */
      handleAs: '',

      /**
       * If true, automatically performs an Ajax request when either `url` or `params` changes.
       *
       * @attribute auto
       * @type boolean
       * @default false
       */
      auto: false,

      /**
       * Parameters to send to the specified URL, as JSON.
       *  
       * @attribute params
       * @type string (JSON)
       * @default ''
       */
      params: '',

      /**
       * Returns the response object.
       *
       * @attribute response
       * @type Object
       * @default null
       */
      response: null,

      /**
       * The HTTP method to use such as 'GET', 'POST', 'PUT', or 'DELETE'.
       * Default is 'GET'.
       *
       * @attribute method
       * @type string
       * @default ''
       */
      method: '',

      /**
       * HTTP request headers to send.
       *
       * Example:
       *
       *     <core-ajax 
       *         auto
       *         url="http://somesite.com"
       *         headers='{"X-Requested-With": "XMLHttpRequest"}'
       *         handleAs="json"
       *         on-core-response="{{handleResponse}}"></core-ajax>
       *  
       * @attribute headers
       * @type Object
       * @default null
       */
      headers: null,

      /**
       * Optional raw body content to send when method === "POST".
       *
       * Example:
       *
       *     <core-ajax method="POST" auto url="http://somesite.com"
       *         body='{"foo":1, "bar":2}'>
       *     </core-ajax>
       *  
       * @attribute body
       * @type Object
       * @default null
       */
      body: null,

      /**
       * Content type to use when sending data.
       *
       * @attribute contentType
       * @type string
       * @default 'application/x-www-form-urlencoded'
       */
      contentType: 'application/x-www-form-urlencoded',

      /**
       * Set the withCredentials flag on the request.
       * 
       * @attribute withCredentials
       * @type boolean
       * @default false
       */
      withCredentials: false,
      
      ready: function() {
        this.xhr = document.createElement('core-xhr');
      },

      receive: function(response, xhr) {
        if (this.isSuccess(xhr)) {
          this.processResponse(xhr);
        } else {
          this.error(xhr);
        }
        this.complete(xhr);
      },

      isSuccess: function(xhr) {
        var status = xhr.status || 0;
        return !status || (status >= 200 && status < 300);
      },

      processResponse: function(xhr) {
        var response = this.evalResponse(xhr);
        this.response = response;
        this.fire('core-response', {response: response, xhr: xhr});
      },

      error: function(xhr) {
        var response = xhr.status + ': ' + xhr.responseText;
        this.fire('core-error', {response: response, xhr: xhr});
      },

      complete: function(xhr) {
        this.fire('core-complete', {response: xhr.status, xhr: xhr});
      },

      evalResponse: function(xhr) {
        return this[(this.handleAs || 'text') + 'Handler'](xhr);
      },

      xmlHandler: function(xhr) {
        return xhr.responseXML;
      },

      textHandler: function(xhr) {
        return xhr.responseText;
      },

      jsonHandler: function(xhr) {
        var r = xhr.responseText;
        try {
          return JSON.parse(r);
        } catch (x) {
          return r;
        }
      },

      documentHandler: function(xhr) {
        return xhr.response;
      },

      blobHandler: function(xhr) {
        return xhr.response;
      },

      arraybufferHandler: function(xhr) {
        return xhr.response;
      },

      urlChanged: function() {
        if (!this.handleAs) {
          var ext = String(this.url).split('.').pop();
          switch (ext) {
            case 'json':
              this.handleAs = 'json';
              break;
          }
        }
        this.autoGo();
      },

      paramsChanged: function() {
        this.autoGo();
      },

      autoChanged: function() {
        this.autoGo();
      },

      // TODO(sorvell): multiple side-effects could call autoGo 
      // during one micro-task, use a job to have only one action 
      // occur
      autoGo: function() {
        if (this.auto) {
          this.goJob = this.job(this.goJob, this.go, 0);
        }
      },

      /**
       * Performs an Ajax request to the specified URL.
       *
       * @method go
       */
      go: function() {
        var args = this.xhrArgs || {};
        // TODO(sjmiles): we may want XHR to default to POST if body is set
        args.body = this.body || args.body;
        args.params = this.params || args.params;
        if (args.params && typeof(args.params) == 'string') {
          args.params = JSON.parse(args.params);
        }
        args.headers = this.headers || args.headers || {};
        if (args.headers && typeof(args.headers) == 'string') {
          args.headers = JSON.parse(args.headers);
        }
        if (this.contentType) {
          args.headers['content-type'] = this.contentType;
        }
        if (this.handleAs === 'arraybuffer' || this.handleAs === 'blob' ||
            this.handleAs === 'document') {
          args.responseType = this.handleAs;
        }
        args.withCredentials = this.withCredentials;
        args.callback = this.receive.bind(this);
        args.url = this.url;
        args.method = this.method;
        return args.url && this.xhr.request(args);
      }

    });

  </script>
</polymer-element>

